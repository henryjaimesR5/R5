{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"R5 Framework","text":"<p>Framework moderno de Python con Inyecci\u00f3n de Dependencias, Cliente HTTP y Tareas en Background</p>   ![Python Version](https://img.shields.io/badge/python-3.14%2B-blue) ![License](https://img.shields.io/badge/license-MIT-green) ![Status](https://img.shields.io/badge/status-active-success)"},{"location":"#que-es-r5","title":"\u00bfQu\u00e9 es R5?","text":"<p>R5 es un framework ligero y modular para Python que proporciona tres componentes fundamentales:</p> <ul> <li>\ud83d\udd0c IoC Container - Inyecci\u00f3n de dependencias autom\u00e1tica y type-safe</li> <li>\ud83c\udf10 HTTP Client - Cliente HTTP as\u00edncrono con pooling, retry y Result pattern</li> <li>\u26a1 Background Tasks - Sistema de ejecuci\u00f3n de tareas concurrentes con anyio</li> </ul>"},{"location":"#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"#inyeccion-de-dependencias-simple","title":"\u2728 Inyecci\u00f3n de Dependencias Simple","text":"<pre><code>from R5.ioc import singleton, inject\n\n@singleton\nclass UserService:\n    def get_user(self, user_id: int):\n        return {\"id\": user_id, \"name\": \"John\"}\n\n@inject\nasync def process_user(service: UserService, user_id: int):\n    return service.get_user(user_id)\n\nuser = await process_user(user_id=1)\n</code></pre>"},{"location":"#cliente-http-poderoso","title":"\ud83d\ude80 Cliente HTTP Poderoso","text":"<pre><code>from R5.http import Http\nfrom R5.ioc import inject\n\n@inject\nasync def fetch_data(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n    user = result.to(UserDTO)\n    return user\n</code></pre>"},{"location":"#background-tasks-integradas","title":"\ud83d\udd04 Background Tasks Integradas","text":"<pre><code>from R5.background import Background\nfrom R5.ioc import inject\n\n@inject\nasync def queue_tasks(bg: Background):\n    await bg.add(send_email, \"user@example.com\")\n    await bg.add(process_payment, payment_id)\n    await bg.add(update_cache, cache_key)\n</code></pre>"},{"location":"#por-que-r5","title":"\u00bfPor qu\u00e9 R5?","text":""},{"location":"#simple-y-directo","title":"\ud83c\udfaf Simple y Directo","text":"<p>Sin configuraci\u00f3n complicada. Usa decoradores simples como <code>@singleton</code>, <code>@inject</code> y empieza a trabajar inmediatamente.</p>"},{"location":"#type-safe","title":"\ud83d\udd12 Type-Safe","text":"<p>Aprovecha el sistema de tipos de Python para inyecci\u00f3n autom\u00e1tica y detecci\u00f3n temprana de errores.</p>"},{"location":"#alto-rendimiento","title":"\u26a1 Alto Rendimiento","text":"<ul> <li>Connection pooling autom\u00e1tico en HTTP client</li> <li>Tareas concurrentes con anyio</li> <li>Recursos gestionados con context managers</li> </ul>"},{"location":"#modular","title":"\ud83e\udde9 Modular","text":"<p>Usa solo lo que necesitas. Cada m\u00f3dulo funciona independientemente:</p> <ul> <li><code>R5.ioc</code> - Container e inyecci\u00f3n</li> <li><code>R5.http</code> - Cliente HTTP</li> <li><code>R5.background</code> - Tareas background</li> </ul>"},{"location":"#patrones-modernos","title":"\ud83c\udfa8 Patrones Modernos","text":"<ul> <li>Result Pattern para manejo de errores</li> <li>Resource Pattern para lifecycle management</li> <li>Builder Pattern para configuraci\u00f3n fluida</li> </ul>"},{"location":"#instalacion-rapida","title":"Instalaci\u00f3n R\u00e1pida","text":"<pre><code># Con pip\npip install r5\n\n# Con uv\nuv add r5\n</code></pre>"},{"location":"#ejemplo-completo","title":"Ejemplo Completo","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom R5.ioc import singleton, inject, config\nfrom R5.http import Http\nfrom R5.background import Background\n\n@config(file='.env')\nclass AppConfig:\n    api_url: str = \"https://api.example.com\"\n    api_key: str = \"\"\n\n@singleton\nclass EmailService:\n    async def send(self, to: str, subject: str):\n        print(f\"Sending email to {to}: {subject}\")\n\n@dataclass\nclass UserDTO:\n    id: int\n    name: str\n    email: str\n\n@inject\nasync def main(\n    config: AppConfig,\n    http: Http,\n    bg: Background,\n    email: EmailService\n):\n    result = await http.get(f\"{config.api_url}/users/1\")\n    user = result.to(UserDTO)\n\n    if user:\n        await bg.add(email.send, user.email, \"Welcome!\")\n        print(f\"User: {user.name}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li> <p> Quick Start</p> <p>Empieza a usar R5 en minutos</p> </li> <li> <p> Gu\u00edas</p> <p>Aprende los conceptos fundamentales</p> </li> <li> <p> Ejemplos</p> <p>Ejemplos pr\u00e1cticos y patrones</p> </li> <li> <p> API Reference</p> <p>Documentaci\u00f3n completa de la API</p> </li> </ul>"},{"location":"#licencia","title":"Licencia","text":"<p>MIT License - Libre para uso personal y comercial.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Todos los cambios notables en R5 ser\u00e1n documentados aqu\u00ed.</p> <p>El formato est\u00e1 basado en Keep a Changelog, y este proyecto adhiere a Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Documentaci\u00f3n completa con MkDocs y mkdocstrings</li> <li>Ejemplos de uso b\u00e1sicos y avanzados</li> <li>Gu\u00edas para IoC, HTTP y Background</li> <li>Patrones de dise\u00f1o comunes</li> </ul>"},{"location":"changelog/#010-2025-01-25","title":"0.1.0 - 2025-01-25","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>IoC Container con inyecci\u00f3n de dependencias autom\u00e1tica</li> <li>Decoradores <code>@singleton</code>, <code>@factory</code>, <code>@resource</code></li> <li>Decorador <code>@inject</code> para inyecci\u00f3n autom\u00e1tica</li> <li>Decorador <code>@config</code> para configuraci\u00f3n multi-formato</li> <li>Soporte para .env, JSON, YAML, Properties</li> <li>Detecci\u00f3n de dependencias circulares</li> <li> <p>Type-safe dependency resolution</p> </li> <li> <p>Cliente HTTP as\u00edncrono</p> </li> <li>Connection pooling con httpx</li> <li>Result pattern para manejo de errores</li> <li>Retry autom\u00e1tico configurable</li> <li>Handlers (before/after)</li> <li>Proxy rotation</li> <li>Mapeo autom\u00e1tico a DTOs (Pydantic, dataclasses)</li> <li> <p>Configuraci\u00f3n flexible de timeouts</p> </li> <li> <p>Sistema de Background Tasks</p> </li> <li>Ejecuci\u00f3n concurrente con anyio</li> <li>Thread pool para tareas s\u00edncronas</li> <li>Inyecci\u00f3n IoC en tareas</li> <li>Error handling robusto</li> <li>Lifecycle management autom\u00e1tico</li> </ul>"},{"location":"changelog/#technical","title":"Technical","text":"<ul> <li>Python 3.14+ requerido</li> <li>Dependencias principales:</li> <li>anyio &gt;= 4.12.0</li> <li>dependency-injector &gt;= 4.48.3</li> <li>httpx &gt;= 0.28.1</li> <li>pydantic &gt;= 2.12.5</li> <li>pyyaml &gt;= 6.0.3</li> </ul>"},{"location":"changelog/#001-2025-01-01","title":"0.0.1 - 2025-01-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Initial project setup</li> <li>Basic project structure</li> </ul>"},{"location":"changelog/#tipos-de-cambios","title":"Tipos de Cambios","text":"<ul> <li><code>Added</code> - Nuevas funcionalidades</li> <li><code>Changed</code> - Cambios en funcionalidades existentes</li> <li><code>Deprecated</code> - Funcionalidades que ser\u00e1n removidas</li> <li><code>Removed</code> - Funcionalidades removidas</li> <li><code>Fixed</code> - Correcci\u00f3n de bugs</li> <li><code>Security</code> - Correcciones de seguridad</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>\u00a1Gracias por tu inter\u00e9s en contribuir a R5!</p>"},{"location":"contributing/#como-contribuir","title":"C\u00f3mo Contribuir","text":""},{"location":"contributing/#1-fork-y-clone","title":"1. Fork y Clone","text":"<pre><code># Fork el repositorio en GitHub\ngit clone https://github.com/tu-usuario/R5.git\ncd R5\n</code></pre>"},{"location":"contributing/#2-instalar-dependencias","title":"2. Instalar Dependencias","text":"<pre><code># Instalar uv si no lo tienes\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Instalar dependencias\nuv sync\nuv sync --group dev\n</code></pre>"},{"location":"contributing/#3-crear-branch","title":"3. Crear Branch","text":"<pre><code>git checkout -b feature/nueva-funcionalidad\n</code></pre>"},{"location":"contributing/#4-hacer-cambios","title":"4. Hacer Cambios","text":"<ul> <li>Escribe c\u00f3digo limpio y documentado</li> <li>Sigue las convenciones de c\u00f3digo existentes</li> <li>Agrega tests para nuevas funcionalidades</li> <li>Actualiza la documentaci\u00f3n si es necesario</li> </ul>"},{"location":"contributing/#5-ejecutar-tests","title":"5. Ejecutar Tests","text":"<pre><code># Ejecutar todos los tests\nuv run pytest\n\n# Con coverage\nuv run pytest --cov=R5 --cov-report=html\n\n# Tests espec\u00edficos\nuv run pytest tests/ioc/\n</code></pre>"},{"location":"contributing/#6-verificar-codigo","title":"6. Verificar C\u00f3digo","text":"<pre><code># Type checking\nuv run mypy R5/\n\n# Linting\nuv run ruff check R5/\n\n# Format\nuv run ruff format R5/\n</code></pre>"},{"location":"contributing/#7-commit-y-push","title":"7. Commit y Push","text":"<pre><code>git add .\ngit commit -m \"feat: agregar nueva funcionalidad\"\ngit push origin feature/nueva-funcionalidad\n</code></pre>"},{"location":"contributing/#8-crear-pull-request","title":"8. Crear Pull Request","text":"<ul> <li>Ve a GitHub y crea un Pull Request</li> <li>Describe los cambios realizados</li> <li>Referencia issues relacionados</li> </ul>"},{"location":"contributing/#convenciones-de-codigo","title":"Convenciones de C\u00f3digo","text":""},{"location":"contributing/#style-guide","title":"Style Guide","text":"<ul> <li>Seguir PEP 8</li> <li>Usar type hints en todas las funciones</li> <li>M\u00e1ximo 88 caracteres por l\u00ednea (Black default)</li> <li>Docstrings en Google style</li> </ul>"},{"location":"contributing/#commits","title":"Commits","text":"<p>Usar Conventional Commits:</p> <ul> <li><code>feat:</code> Nueva funcionalidad</li> <li><code>fix:</code> Correcci\u00f3n de bugs</li> <li><code>docs:</code> Cambios en documentaci\u00f3n</li> <li><code>test:</code> Agregar o modificar tests</li> <li><code>refactor:</code> Refactorizaci\u00f3n de c\u00f3digo</li> <li><code>chore:</code> Tareas de mantenimiento</li> </ul> <p>Ejemplos: <pre><code>feat: add retry mechanism to HTTP client\nfix: resolve circular dependency in IoC container\ndocs: update getting started guide\ntest: add tests for configuration loader\n</code></pre></p>"},{"location":"contributing/#estructura-del-proyecto","title":"Estructura del Proyecto","text":"<pre><code>R5/\n\u251c\u2500\u2500 R5/\n\u2502   \u251c\u2500\u2500 ioc/          # IoC Container\n\u2502   \u251c\u2500\u2500 http/         # HTTP Client\n\u2502   \u2514\u2500\u2500 background.py # Background Tasks\n\u251c\u2500\u2500 tests/            # Tests\n\u251c\u2500\u2500 docs/             # Documentaci\u00f3n\n\u2514\u2500\u2500 examples/         # Ejemplos\n</code></pre>"},{"location":"contributing/#tests","title":"Tests","text":""},{"location":"contributing/#escribir-tests","title":"Escribir Tests","text":"<pre><code>import pytest\nfrom R5.ioc import Container, singleton, inject\n\ndef test_singleton_behavior():\n    Container.reset()\n\n    @singleton\n    class MyService:\n        def __init__(self):\n            self.value = \"test\"\n\n    instance1 = Container.resolve(MyService)\n    instance2 = Container.resolve(MyService)\n\n    assert instance1 is instance2\n\n@pytest.mark.asyncio\nasync def test_async_injection():\n    @inject\n    async def handler(service: MyService):\n        return service.value\n\n    result = await handler()\n    assert result == \"test\"\n</code></pre>"},{"location":"contributing/#fixtures","title":"Fixtures","text":"<pre><code>@pytest.fixture\ndef clean_container():\n    snapshot = Container.snapshot()\n    yield\n    Container.restore(snapshot)\n</code></pre>"},{"location":"contributing/#documentacion","title":"Documentaci\u00f3n","text":""},{"location":"contributing/#actualizar-docs","title":"Actualizar Docs","text":"<pre><code># Instalar dependencias de docs\nuv sync --group docs\n\n# Servir documentaci\u00f3n localmente\nuv run mkdocs serve\n\n# Build documentaci\u00f3n\nuv run mkdocs build\n</code></pre>"},{"location":"contributing/#escribir-docs","title":"Escribir Docs","text":"<ul> <li>Usar Markdown</li> <li>Incluir ejemplos de c\u00f3digo</li> <li>Agregar diagramas cuando sea \u00fatil</li> <li>Mantener consistencia con docs existentes</li> </ul>"},{"location":"contributing/#reportar-issues","title":"Reportar Issues","text":""},{"location":"contributing/#bug-reports","title":"Bug Reports","text":"<p>Incluir: - Versi\u00f3n de R5 - Versi\u00f3n de Python - C\u00f3digo para reproducir el bug - Comportamiento esperado vs actual - Stack trace si aplica</p>"},{"location":"contributing/#feature-requests","title":"Feature Requests","text":"<p>Incluir: - Descripci\u00f3n clara de la funcionalidad - Casos de uso - Ejemplos de API propuesta - Por qu\u00e9 es \u00fatil para el framework</p>"},{"location":"contributing/#codigo-de-conducta","title":"C\u00f3digo de Conducta","text":"<ul> <li>Ser respetuoso y profesional</li> <li>Aceptar cr\u00edticas constructivas</li> <li>Enfocarse en lo mejor para el proyecto</li> <li>Mostrar empat\u00eda hacia otros contribuidores</li> </ul>"},{"location":"contributing/#licencia","title":"Licencia","text":"<p>Al contribuir, aceptas que tus contribuciones se licencien bajo la licencia MIT.</p>"},{"location":"contributing/#preguntas","title":"Preguntas","text":"<p>Si tienes preguntas, abre un issue o contacta a los maintainers.</p> <p>\u00a1Gracias por contribuir a R5! \ud83c\udf89</p>"},{"location":"api/background/","title":"Background API Reference","text":"<p>Documentaci\u00f3n completa de la API del m\u00f3dulo Background.</p>"},{"location":"api/background/#background","title":"Background","text":""},{"location":"api/background/#R5.background.Background","title":"Background","text":"<pre><code>Background(max_workers: int = 40)\n</code></pre> <p>Sistema de ejecuci\u00f3n de tareas en background con anyio.</p> <p>Resource que gestiona: - TaskGroup para ejecuci\u00f3n concurrente - Thread pool configurable para tareas sync - Inyecci\u00f3n IoC autom\u00e1tica en tareas - Manejo de errores sin propagaci\u00f3n</p> <p>Uso con @inject (recomendado):     @inject     async def my_service(bg: Background):         await bg.add(send_email, \"user@example.com\")         await bg.add(process_payment, payment_id)</p> <p>Uso con context manager (control expl\u00edcito de lifecycle):     async with await Container.resolve(Background) as bg:         await bg.add(task1)         await bg.add(task2)     # Cleanup autom\u00e1tico al salir</p> Source code in <code>R5/background.py</code> <pre><code>def __init__(self, max_workers: int = 40) -&gt; None:\n    self._task_group: TaskGroup | None = None\n    self._max_workers = max_workers\n    self._limiter = CapacityLimiter(max_workers)\n    self._ioc_cache: dict[type[Any], Any] = {}\n    self._started = False\n</code></pre>"},{"location":"api/background/#R5.background.Background.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Background\n</code></pre> Source code in <code>R5/background.py</code> <pre><code>async def __aenter__(self) -&gt; 'Background':\n    return self\n</code></pre>"},{"location":"api/background/#R5.background.Background.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb) -&gt; None\n</code></pre> Source code in <code>R5/background.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    if self._started and self._task_group:\n        try:\n            await self._task_group.__aexit__(None, None, None)\n        finally:\n            self._started = False\n            self._task_group = None\n            self._ioc_cache.clear()\n            logger.debug(\"Background shutdown completed\")\n</code></pre>"},{"location":"api/background/#R5.background.Background.add","title":"add  <code>async</code>","text":"<pre><code>add(func: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; None\n</code></pre> Source code in <code>R5/background.py</code> <pre><code>async def add(self, func: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; None:\n    if not self._started:\n        self._task_group = create_task_group()\n        await self._task_group.__aenter__()\n        self._started = True\n        logger.debug(f\"Background initialized with {self._max_workers} workers\")\n\n    wrapped_func = self._wrap_with_ioc(func)\n\n    if inspect.iscoroutinefunction(wrapped_func):\n        self._task_group.start_soon(\n            self._safe_async_task, wrapped_func, args, kwargs\n        )\n    else:\n        self._task_group.start_soon(\n            self._safe_sync_task, wrapped_func, args, kwargs\n        )\n</code></pre>"},{"location":"api/http/","title":"HTTP API Reference","text":"<p>Documentaci\u00f3n completa de la API del m\u00f3dulo HTTP.</p>"},{"location":"api/http/#http-client","title":"Http Client","text":""},{"location":"api/http/#R5.http.http.Http","title":"Http","text":"<pre><code>Http(config: HttpConfig)\n</code></pre> <p>Cliente HTTP unificado con pool y proxy rotation.</p> <p>Singleton que gestiona: - Connection pooling con httpx.AsyncClient - Proxy rotation con round-robin - Configuraci\u00f3n centralizada - Result pattern para manejo de errores</p> Uso <p>@inject async def my_service(http: Http):     result = await http.get(\"/users/1\")     user = result.to(UserDTO)</p> <p>Inicializa Http client.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>HttpConfig</code> <p>Configuraci\u00f3n HTTP inyectada por IoC</p> required Source code in <code>R5/http/http.py</code> <pre><code>@inject\ndef __init__(self, config: HttpConfig):\n    \"\"\"Inicializa Http client.\n\n    Args:\n        config: Configuraci\u00f3n HTTP inyectada por IoC\n    \"\"\"\n    self._config = config\n    self._client: Optional[httpx.AsyncClient] = None\n\n    self._proxies = config.proxies\n    self._proxy_cycle = cycle(config.proxies) if config.proxies else None\n\n    self._before_handlers: list[Callable[[httpx.Request], None]] = []\n    self._after_handlers: list[Callable[[httpx.Request, httpx.Response], None]] = []\n\n    self._retry_attempts: Optional[int] = None\n    self._retry_delay: float = 1.0\n    self._retry_backoff: float = 2.0\n    self._retry_when_status: Optional[tuple[int, ...]] = None\n    self._retry_when_exception: Optional[tuple[type[Exception], ...]] = None\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Http\n</code></pre> <p>Async context manager entry.</p> <p>Llamado autom\u00e1ticamente por el resource provider.</p> Source code in <code>R5/http/http.py</code> <pre><code>async def __aenter__(self) -&gt; 'Http':\n    \"\"\"Async context manager entry.\n\n    Llamado autom\u00e1ticamente por el resource provider.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb) -&gt; None\n</code></pre> <p>Async context manager exit.</p> <p>Cierra autom\u00e1ticamente el cliente HTTP cuando el resource sale del scope (al finalizar la aplicaci\u00f3n o request).</p> Source code in <code>R5/http/http.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Async context manager exit.\n\n    Cierra autom\u00e1ticamente el cliente HTTP cuando el resource\n    sale del scope (al finalizar la aplicaci\u00f3n o request).\n    \"\"\"\n    print(\"Closing Http client...\")\n    await self.close()\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.get","title":"get  <code>async</code>","text":"<pre><code>get(url: str, params: Optional[dict] = None, headers: Optional[dict[str, str]] = None, timeout: Optional[float] = None, follow_redirects: Optional[bool] = None, on_before: Optional[Callable[[Request], None]] = None, on_after: Optional[Callable[[Request, Response], None]] = None, on_status: Optional[dict[int, Callable[[], None]]] = None, on_exception: Optional[Callable[[Exception], None]] = None, **kwargs: Any) -&gt; Result\n</code></pre> <p>GET request con handlers opcionales.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL del endpoint (requerido)</p> required <code>params</code> <code>Optional[dict]</code> <p>Query parameters</p> <code>None</code> <code>headers</code> <code>Optional[dict[str, str]]</code> <p>Headers HTTP personalizados</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout en segundos (sobrescribe config global)</p> <code>None</code> <code>follow_redirects</code> <code>Optional[bool]</code> <p>Si debe seguir redirecciones 3xx</p> <code>None</code> <code>on_before</code> <code>Optional[Callable[[Request], None]]</code> <p>Handler que se ejecuta antes de esta request</p> <code>None</code> <code>on_after</code> <code>Optional[Callable[[Request, Response], None]]</code> <p>Handler que se ejecuta despu\u00e9s de esta request</p> <code>None</code> <code>on_status</code> <code>Optional[dict[int, Callable[[], None]]]</code> <p>Dict de handlers por status {404: handler, 200: handler}</p> <code>None</code> <code>on_exception</code> <code>Optional[Callable[[Exception], None]]</code> <p>Handler para excepciones de esta request</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Argumentos adicionales para httpx.request</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result</code> <p>Result con response o exception</p> Ejemplos Source code in <code>R5/http/http.py</code> <pre><code>async def get(\n    self,\n    url: str,\n    params: Optional[dict] = None,\n    headers: Optional[dict[str, str]] = None,\n    timeout: Optional[float] = None,\n    follow_redirects: Optional[bool] = None,\n    on_before: Optional[Callable[[httpx.Request], None]] = None,\n    on_after: Optional[Callable[[httpx.Request, httpx.Response], None]] = None,\n    on_status: Optional[dict[int, Callable[[], None]]] = None,\n    on_exception: Optional[Callable[[Exception], None]] = None,\n    **kwargs: Any\n) -&gt; Result:\n    \"\"\"GET request con handlers opcionales.\n\n    Args:\n        url: URL del endpoint (requerido)\n        params: Query parameters\n        headers: Headers HTTP personalizados\n        timeout: Timeout en segundos (sobrescribe config global)\n        follow_redirects: Si debe seguir redirecciones 3xx\n        on_before: Handler que se ejecuta antes de esta request\n        on_after: Handler que se ejecuta despu\u00e9s de esta request\n        on_status: Dict de handlers por status {404: handler, 200: handler}\n        on_exception: Handler para excepciones de esta request\n        **kwargs: Argumentos adicionales para httpx.request\n\n    Returns:\n        Result con response o exception\n\n    Ejemplos:\n        # Simple\n        result = await http.get(\"/users/1\")\n\n        # Con retry\n        result = await http.retry(3, on_status=(429, 503)).get(\"/api/data\")\n\n        # Con handlers\n        result = await http.get(\n            \"/users/1\",\n            on_status={404: lambda: print(\"Not found\")},\n            on_exception=lambda e: log_error(e)\n        )\n    \"\"\"\n    return await self._request(\n        \"GET\", \n        url, \n        params=params, \n        headers=headers, \n        timeout=timeout,\n        follow_redirects=follow_redirects,\n        on_before=on_before,\n        on_after=on_after,\n        on_status=on_status,\n        on_exception=on_exception,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.get--simple","title":"Simple","text":"<p>result = await http.get(\"/users/1\")</p>"},{"location":"api/http/#R5.http.http.Http.get--con-retry","title":"Con retry","text":"<p>result = await http.retry(3, on_status=(429, 503)).get(\"/api/data\")</p>"},{"location":"api/http/#R5.http.http.Http.get--con-handlers","title":"Con handlers","text":"<p>result = await http.get(     \"/users/1\",     on_status={404: lambda: print(\"Not found\")},     on_exception=lambda e: log_error(e) )</p>"},{"location":"api/http/#R5.http.http.Http.post","title":"post  <code>async</code>","text":"<pre><code>post(url: str, json: Optional[dict] = None, data: Optional[Any] = None, content: Optional[bytes] = None, headers: Optional[dict[str, str]] = None, timeout: Optional[float] = None, follow_redirects: Optional[bool] = None, on_before: Optional[Callable[[Request], None]] = None, on_after: Optional[Callable[[Request, Response], None]] = None, on_status: Optional[dict[int, Callable[[], None]]] = None, on_exception: Optional[Callable[[Exception], None]] = None, **kwargs: Any) -&gt; Result\n</code></pre> <p>POST request con handlers opcionales.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL del endpoint (requerido)</p> required <code>json</code> <code>Optional[dict]</code> <p>Dict para enviar como JSON (Content-Type: application/json)</p> <code>None</code> <code>data</code> <code>Optional[Any]</code> <p>Datos para form-urlencoded (Content-Type: application/x-www-form-urlencoded)</p> <code>None</code> <code>content</code> <code>Optional[bytes]</code> <p>Bytes puros (archivos, im\u00e1genes)</p> <code>None</code> <code>headers</code> <code>Optional[dict[str, str]]</code> <p>Headers HTTP personalizados</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout en segundos</p> <code>None</code> <code>follow_redirects</code> <code>Optional[bool]</code> <p>Si debe seguir redirecciones 3xx</p> <code>None</code> <code>on_before</code> <code>Optional[Callable[[Request], None]]</code> <p>Handler que se ejecuta antes de esta request</p> <code>None</code> <code>on_after</code> <code>Optional[Callable[[Request, Response], None]]</code> <p>Handler que se ejecuta despu\u00e9s de esta request</p> <code>None</code> <code>on_status</code> <code>Optional[dict[int, Callable[[], None]]]</code> <p>Dict de handlers por status {201: handler, 400: handler}</p> <code>None</code> <code>on_exception</code> <code>Optional[Callable[[Exception], None]]</code> <p>Handler para excepciones de esta request</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Argumentos adicionales para httpx.request</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result</code> <p>Result con response o exception</p> Ejemplos Source code in <code>R5/http/http.py</code> <pre><code>async def post(\n    self,\n    url: str,\n    json: Optional[dict] = None,\n    data: Optional[Any] = None,\n    content: Optional[bytes] = None,\n    headers: Optional[dict[str, str]] = None,\n    timeout: Optional[float] = None,\n    follow_redirects: Optional[bool] = None,\n    on_before: Optional[Callable[[httpx.Request], None]] = None,\n    on_after: Optional[Callable[[httpx.Request, httpx.Response], None]] = None,\n    on_status: Optional[dict[int, Callable[[], None]]] = None,\n    on_exception: Optional[Callable[[Exception], None]] = None,\n    **kwargs: Any\n) -&gt; Result:\n    \"\"\"POST request con handlers opcionales.\n\n    Args:\n        url: URL del endpoint (requerido)\n        json: Dict para enviar como JSON (Content-Type: application/json)\n        data: Datos para form-urlencoded (Content-Type: application/x-www-form-urlencoded)\n        content: Bytes puros (archivos, im\u00e1genes)\n        headers: Headers HTTP personalizados\n        timeout: Timeout en segundos\n        follow_redirects: Si debe seguir redirecciones 3xx\n        on_before: Handler que se ejecuta antes de esta request\n        on_after: Handler que se ejecuta despu\u00e9s de esta request\n        on_status: Dict de handlers por status {201: handler, 400: handler}\n        on_exception: Handler para excepciones de esta request\n        **kwargs: Argumentos adicionales para httpx.request\n\n    Returns:\n        Result con response o exception\n\n    Ejemplos:\n        # JSON\n        result = await http.post(\"/users\", json={\"name\": \"John\"})\n\n        # Con handlers\n        result = await http.post(\n            \"/users\",\n            json={\"name\": \"John\"},\n            on_status={201: lambda: print(\"Created!\")}\n        )\n    \"\"\"\n    return await self._request(\n        \"POST\", \n        url, \n        json=json, \n        data=data, \n        content=content,\n        headers=headers,\n        timeout=timeout,\n        follow_redirects=follow_redirects,\n        on_before=on_before,\n        on_after=on_after,\n        on_status=on_status,\n        on_exception=on_exception,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.post--json","title":"JSON","text":"<p>result = await http.post(\"/users\", json={\"name\": \"John\"})</p>"},{"location":"api/http/#R5.http.http.Http.post--con-handlers","title":"Con handlers","text":"<p>result = await http.post(     \"/users\",     json={\"name\": \"John\"},     on_status={201: lambda: print(\"Created!\")} )</p>"},{"location":"api/http/#R5.http.http.Http.put","title":"put  <code>async</code>","text":"<pre><code>put(url: str, json: Optional[dict] = None, data: Optional[Any] = None, content: Optional[bytes] = None, headers: Optional[dict[str, str]] = None, timeout: Optional[float] = None, follow_redirects: Optional[bool] = None, on_before: Optional[Callable[[Request], None]] = None, on_after: Optional[Callable[[Request, Response], None]] = None, on_status: Optional[dict[int, Callable[[], None]]] = None, on_exception: Optional[Callable[[Exception], None]] = None, **kwargs: Any) -&gt; Result\n</code></pre> <p>PUT request con handlers opcionales.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL del endpoint (requerido)</p> required <code>json</code> <code>Optional[dict]</code> <p>Dict para enviar como JSON</p> <code>None</code> <code>data</code> <code>Optional[Any]</code> <p>Datos para form-urlencoded</p> <code>None</code> <code>content</code> <code>Optional[bytes]</code> <p>Bytes puros</p> <code>None</code> <code>headers</code> <code>Optional[dict[str, str]]</code> <p>Headers HTTP personalizados</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout en segundos</p> <code>None</code> <code>follow_redirects</code> <code>Optional[bool]</code> <p>Si debe seguir redirecciones 3xx</p> <code>None</code> <code>on_before</code> <code>Optional[Callable[[Request], None]]</code> <p>Handler que se ejecuta antes de esta request</p> <code>None</code> <code>on_after</code> <code>Optional[Callable[[Request, Response], None]]</code> <p>Handler que se ejecuta despu\u00e9s de esta request</p> <code>None</code> <code>on_status</code> <code>Optional[dict[int, Callable[[], None]]]</code> <p>Dict de handlers por status</p> <code>None</code> <code>on_exception</code> <code>Optional[Callable[[Exception], None]]</code> <p>Handler para excepciones de esta request</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Argumentos adicionales para httpx.request</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result</code> <p>Result con response o exception</p> Source code in <code>R5/http/http.py</code> <pre><code>async def put(\n    self,\n    url: str,\n    json: Optional[dict] = None,\n    data: Optional[Any] = None,\n    content: Optional[bytes] = None,\n    headers: Optional[dict[str, str]] = None,\n    timeout: Optional[float] = None,\n    follow_redirects: Optional[bool] = None,\n    on_before: Optional[Callable[[httpx.Request], None]] = None,\n    on_after: Optional[Callable[[httpx.Request, httpx.Response], None]] = None,\n    on_status: Optional[dict[int, Callable[[], None]]] = None,\n    on_exception: Optional[Callable[[Exception], None]] = None,\n    **kwargs: Any\n) -&gt; Result:\n    \"\"\"PUT request con handlers opcionales.\n\n    Args:\n        url: URL del endpoint (requerido)\n        json: Dict para enviar como JSON\n        data: Datos para form-urlencoded\n        content: Bytes puros\n        headers: Headers HTTP personalizados\n        timeout: Timeout en segundos\n        follow_redirects: Si debe seguir redirecciones 3xx\n        on_before: Handler que se ejecuta antes de esta request\n        on_after: Handler que se ejecuta despu\u00e9s de esta request\n        on_status: Dict de handlers por status\n        on_exception: Handler para excepciones de esta request\n        **kwargs: Argumentos adicionales para httpx.request\n\n    Returns:\n        Result con response o exception\n    \"\"\"\n    return await self._request(\n        \"PUT\", \n        url, \n        json=json, \n        data=data, \n        content=content,\n        headers=headers,\n        timeout=timeout,\n        follow_redirects=follow_redirects,\n        on_before=on_before,\n        on_after=on_after,\n        on_status=on_status,\n        on_exception=on_exception,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.patch","title":"patch  <code>async</code>","text":"<pre><code>patch(url: str, json: Optional[dict] = None, data: Optional[Any] = None, content: Optional[bytes] = None, headers: Optional[dict[str, str]] = None, timeout: Optional[float] = None, follow_redirects: Optional[bool] = None, on_before: Optional[Callable[[Request], None]] = None, on_after: Optional[Callable[[Request, Response], None]] = None, on_status: Optional[dict[int, Callable[[], None]]] = None, on_exception: Optional[Callable[[Exception], None]] = None, **kwargs: Any) -&gt; Result\n</code></pre> <p>PATCH request con handlers opcionales.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL del endpoint (requerido)</p> required <code>json</code> <code>Optional[dict]</code> <p>Dict para enviar como JSON</p> <code>None</code> <code>data</code> <code>Optional[Any]</code> <p>Datos para form-urlencoded</p> <code>None</code> <code>content</code> <code>Optional[bytes]</code> <p>Bytes puros</p> <code>None</code> <code>headers</code> <code>Optional[dict[str, str]]</code> <p>Headers HTTP personalizados</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout en segundos</p> <code>None</code> <code>follow_redirects</code> <code>Optional[bool]</code> <p>Si debe seguir redirecciones 3xx</p> <code>None</code> <code>on_before</code> <code>Optional[Callable[[Request], None]]</code> <p>Handler que se ejecuta antes de esta request</p> <code>None</code> <code>on_after</code> <code>Optional[Callable[[Request, Response], None]]</code> <p>Handler que se ejecuta despu\u00e9s de esta request</p> <code>None</code> <code>on_status</code> <code>Optional[dict[int, Callable[[], None]]]</code> <p>Dict de handlers por status</p> <code>None</code> <code>on_exception</code> <code>Optional[Callable[[Exception], None]]</code> <p>Handler para excepciones de esta request</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Argumentos adicionales para httpx.request</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result</code> <p>Result con response o exception</p> Source code in <code>R5/http/http.py</code> <pre><code>async def patch(\n    self,\n    url: str,\n    json: Optional[dict] = None,\n    data: Optional[Any] = None,\n    content: Optional[bytes] = None,\n    headers: Optional[dict[str, str]] = None,\n    timeout: Optional[float] = None,\n    follow_redirects: Optional[bool] = None,\n    on_before: Optional[Callable[[httpx.Request], None]] = None,\n    on_after: Optional[Callable[[httpx.Request, httpx.Response], None]] = None,\n    on_status: Optional[dict[int, Callable[[], None]]] = None,\n    on_exception: Optional[Callable[[Exception], None]] = None,\n    **kwargs: Any\n) -&gt; Result:\n    \"\"\"PATCH request con handlers opcionales.\n\n    Args:\n        url: URL del endpoint (requerido)\n        json: Dict para enviar como JSON\n        data: Datos para form-urlencoded\n        content: Bytes puros\n        headers: Headers HTTP personalizados\n        timeout: Timeout en segundos\n        follow_redirects: Si debe seguir redirecciones 3xx\n        on_before: Handler que se ejecuta antes de esta request\n        on_after: Handler que se ejecuta despu\u00e9s de esta request\n        on_status: Dict de handlers por status\n        on_exception: Handler para excepciones de esta request\n        **kwargs: Argumentos adicionales para httpx.request\n\n    Returns:\n        Result con response o exception\n    \"\"\"\n    return await self._request(\n        \"PATCH\", \n        url, \n        json=json, \n        data=data, \n        content=content,\n        headers=headers,\n        timeout=timeout,\n        follow_redirects=follow_redirects,\n        on_before=on_before,\n        on_after=on_after,\n        on_status=on_status,\n        on_exception=on_exception,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(url: str, headers: Optional[dict[str, str]] = None, timeout: Optional[float] = None, follow_redirects: Optional[bool] = None, on_before: Optional[Callable[[Request], None]] = None, on_after: Optional[Callable[[Request, Response], None]] = None, on_status: Optional[dict[int, Callable[[], None]]] = None, on_exception: Optional[Callable[[Exception], None]] = None, **kwargs: Any) -&gt; Result\n</code></pre> <p>DELETE request con handlers opcionales.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL del endpoint (requerido)</p> required <code>headers</code> <code>Optional[dict[str, str]]</code> <p>Headers HTTP personalizados</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout en segundos</p> <code>None</code> <code>follow_redirects</code> <code>Optional[bool]</code> <p>Si debe seguir redirecciones 3xx</p> <code>None</code> <code>on_before</code> <code>Optional[Callable[[Request], None]]</code> <p>Handler que se ejecuta antes de esta request</p> <code>None</code> <code>on_after</code> <code>Optional[Callable[[Request, Response], None]]</code> <p>Handler que se ejecuta despu\u00e9s de esta request</p> <code>None</code> <code>on_status</code> <code>Optional[dict[int, Callable[[], None]]]</code> <p>Dict de handlers por status</p> <code>None</code> <code>on_exception</code> <code>Optional[Callable[[Exception], None]]</code> <p>Handler para excepciones de esta request</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Argumentos adicionales para httpx.request</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result</code> <p>Result con response o exception</p> Source code in <code>R5/http/http.py</code> <pre><code>async def delete(\n    self,\n    url: str,\n    headers: Optional[dict[str, str]] = None,\n    timeout: Optional[float] = None,\n    follow_redirects: Optional[bool] = None,\n    on_before: Optional[Callable[[httpx.Request], None]] = None,\n    on_after: Optional[Callable[[httpx.Request, httpx.Response], None]] = None,\n    on_status: Optional[dict[int, Callable[[], None]]] = None,\n    on_exception: Optional[Callable[[Exception], None]] = None,\n    **kwargs: Any\n) -&gt; Result:\n    \"\"\"DELETE request con handlers opcionales.\n\n    Args:\n        url: URL del endpoint (requerido)\n        headers: Headers HTTP personalizados\n        timeout: Timeout en segundos\n        follow_redirects: Si debe seguir redirecciones 3xx\n        on_before: Handler que se ejecuta antes de esta request\n        on_after: Handler que se ejecuta despu\u00e9s de esta request\n        on_status: Dict de handlers por status\n        on_exception: Handler para excepciones de esta request\n        **kwargs: Argumentos adicionales para httpx.request\n\n    Returns:\n        Result con response o exception\n    \"\"\"\n    return await self._request(\n        \"DELETE\", \n        url, \n        headers=headers,\n        timeout=timeout,\n        follow_redirects=follow_redirects,\n        on_before=on_before,\n        on_after=on_after,\n        on_status=on_status,\n        on_exception=on_exception,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.retry","title":"retry","text":"<pre><code>retry(attempts: int, delay: float = 1.0, backoff: float = 2.0, when_status: Optional[tuple[int, ...]] = None, when_exception: Optional[tuple[type[Exception], ...]] = None) -&gt; Http\n</code></pre> <p>Configura pol\u00edtica de retry para la siguiente request.</p> <p>Patr\u00f3n builder que permite encadenar configuraci\u00f3n antes de .get()/.post().</p> <p>Parameters:</p> Name Type Description Default <code>attempts</code> <code>int</code> <p>N\u00famero de reintentos</p> required <code>delay</code> <code>float</code> <p>Delay inicial en segundos</p> <code>1.0</code> <code>backoff</code> <code>float</code> <p>Factor de backoff exponencial</p> <code>2.0</code> <code>when_status</code> <code>Optional[tuple[int, ...]]</code> <p>Tuple de status codes que disparan retry (ej: (429, 503))</p> <code>None</code> <code>when_exception</code> <code>Optional[tuple[type[Exception], ...]]</code> <p>Tuple de tipos de excepci\u00f3n que disparan retry</p> <code>None</code> <p>Returns:</p> Type Description <code>Http</code> <p>self para permitir chaining con .get(), .post(), etc.</p> Ejemplo <p>result = await http.retry(3, delay=2, when_status=(429, 503)).get(\"/api/data\")</p> Source code in <code>R5/http/http.py</code> <pre><code>def retry(\n    self,\n    attempts: int,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    when_status: Optional[tuple[int, ...]] = None,\n    when_exception: Optional[tuple[type[Exception], ...]] = None\n) -&gt; 'Http':\n    \"\"\"Configura pol\u00edtica de retry para la siguiente request.\n\n    Patr\u00f3n builder que permite encadenar configuraci\u00f3n antes de .get()/.post().\n\n    Args:\n        attempts: N\u00famero de reintentos\n        delay: Delay inicial en segundos\n        backoff: Factor de backoff exponencial\n        when_status: Tuple de status codes que disparan retry (ej: (429, 503))\n        when_exception: Tuple de tipos de excepci\u00f3n que disparan retry\n\n    Returns:\n        self para permitir chaining con .get(), .post(), etc.\n\n    Ejemplo:\n        result = await http.retry(3, delay=2, when_status=(429, 503)).get(\"/api/data\")\n    \"\"\"\n    self._retry_attempts = attempts\n    self._retry_delay = delay\n    self._retry_backoff = backoff\n    self._retry_when_status = when_status\n    self._retry_when_exception = when_exception\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.on_before","title":"on_before","text":"<pre><code>on_before(handler: Callable[[Request], None]) -&gt; Http\n</code></pre> <p>Registra handler que se ejecuta ANTES de cada request.</p> <p>El handler recibe el httpx.Request antes de enviarlo. \u00datil para logging, modificaci\u00f3n de headers, m\u00e9tricas, etc.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[Request], None]</code> <p>Funci\u00f3n que recibe httpx.Request</p> required <p>Returns:</p> Type Description <code>Http</code> <p>self para permitir chaining</p> Ejemplo <p>http.on_before(lambda req: print(f\"\u2192 {req.method} {req.url}\")) result = await http.get(\"/users\")  # Ejecuta handler autom\u00e1ticamente</p> Source code in <code>R5/http/http.py</code> <pre><code>def on_before(self, handler: Callable[[httpx.Request], None]) -&gt; 'Http':\n    \"\"\"Registra handler que se ejecuta ANTES de cada request.\n\n    El handler recibe el httpx.Request antes de enviarlo.\n    \u00datil para logging, modificaci\u00f3n de headers, m\u00e9tricas, etc.\n\n    Args:\n        handler: Funci\u00f3n que recibe httpx.Request\n\n    Returns:\n        self para permitir chaining\n\n    Ejemplo:\n        http.on_before(lambda req: print(f\"\u2192 {req.method} {req.url}\"))\n        result = await http.get(\"/users\")  # Ejecuta handler autom\u00e1ticamente\n    \"\"\"\n    self._before_handlers.append(handler)\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.on_after","title":"on_after","text":"<pre><code>on_after(handler: Callable[[Request, Response], None]) -&gt; Http\n</code></pre> <p>Registra handler que se ejecuta DESPU\u00c9S de cada request exitosa.</p> <p>El handler recibe el httpx.Request y httpx.Response. \u00datil para logging, m\u00e9tricas, validaciones, etc.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[Request, Response], None]</code> <p>Funci\u00f3n que recibe (request, response)</p> required <p>Returns:</p> Type Description <code>Http</code> <p>self para permitir chaining</p> Ejemplo <p>http.on_after(lambda req, res: print(f\"\u2190 {res.status_code}\")) result = await http.get(\"/users\")  # Ejecuta handler autom\u00e1ticamente</p> Source code in <code>R5/http/http.py</code> <pre><code>def on_after(self, handler: Callable[[httpx.Request, httpx.Response], None]) -&gt; 'Http':\n    \"\"\"Registra handler que se ejecuta DESPU\u00c9S de cada request exitosa.\n\n    El handler recibe el httpx.Request y httpx.Response.\n    \u00datil para logging, m\u00e9tricas, validaciones, etc.\n\n    Args:\n        handler: Funci\u00f3n que recibe (request, response)\n\n    Returns:\n        self para permitir chaining\n\n    Ejemplo:\n        http.on_after(lambda req, res: print(f\"\u2190 {res.status_code}\"))\n        result = await http.get(\"/users\")  # Ejecuta handler autom\u00e1ticamente\n    \"\"\"\n    self._after_handlers.append(handler)\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Cierra el cliente y libera recursos.</p> <p>Debe llamarse al finalizar la aplicaci\u00f3n para liberar conexiones del pool correctamente.</p> Source code in <code>R5/http/http.py</code> <pre><code>async def close(self):\n    \"\"\"Cierra el cliente y libera recursos.\n\n    Debe llamarse al finalizar la aplicaci\u00f3n para liberar\n    conexiones del pool correctamente.\n    \"\"\"\n    if self._client:\n        await self._client.aclose()\n        self._client = None\n</code></pre>"},{"location":"api/http/#httpconfig","title":"HttpConfig","text":""},{"location":"api/http/#R5.http.http.HttpConfig","title":"HttpConfig","text":"<p>Configuraci\u00f3n para el cliente HTTP.</p> <p>Attributes:</p> Name Type Description <code>max_connections</code> <code>int</code> <p>M\u00e1ximo de conexiones en el pool</p> <code>max_keepalive_connections</code> <code>int</code> <p>M\u00e1ximo de conexiones keep-alive</p> <code>keepalive_expiry</code> <code>float</code> <p>Tiempo de expiraci\u00f3n de keep-alive en segundos</p> <code>connect_timeout</code> <code>float</code> <p>Timeout de conexi\u00f3n en segundos</p> <code>read_timeout</code> <code>float</code> <p>Timeout de lectura en segundos</p> <code>write_timeout</code> <code>float</code> <p>Timeout de escritura en segundos</p> <code>pool_timeout</code> <code>float</code> <p>Timeout del pool en segundos</p> <code>max_retries</code> <code>int</code> <p>N\u00famero m\u00e1ximo de reintentos</p> <code>retry_backoff_factor</code> <code>float</code> <p>Factor de backoff para reintentos</p> <code>retry_statuses</code> <code>list[int]</code> <p>Lista de status codes que disparan retry</p> <code>proxies</code> <code>list[str]</code> <p>Lista de proxies para rotaci\u00f3n</p> <code>proxy_rotation</code> <code>bool</code> <p>Si debe rotar entre proxies</p> <code>default_headers</code> <code>dict[str, str]</code> <p>Headers por defecto para todas las requests</p> <code>user_agent</code> <code>str</code> <p>User-Agent por defecto</p> <code>follow_redirects</code> <code>bool</code> <p>Si debe seguir redirecciones por defecto</p>"},{"location":"api/http/#result","title":"Result","text":""},{"location":"api/http/#R5.http.result.Result","title":"Result  <code>dataclass</code>","text":"<pre><code>Result(response: Optional[Response] = None, request: Optional[Request] = None, status: int = 0, exception: Optional[Exception] = None)\n</code></pre> <p>Wrapper para respuestas HTTP con handlers encadenados.</p> Atributos <p>response: httpx.Response (puede ser None si hubo excepci\u00f3n) request: httpx.Request (puede ser None si hubo excepci\u00f3n) status: C\u00f3digo HTTP (0 si hubo excepci\u00f3n antes de respuesta) exception: Excepci\u00f3n capturada (None si no hubo error)</p>"},{"location":"api/http/#R5.http.result.Result.from_response","title":"from_response  <code>staticmethod</code>","text":"<pre><code>from_response(response: Response) -&gt; Result\n</code></pre> <p>Crea Result desde httpx.Response exitosa.</p> Source code in <code>R5/http/result.py</code> <pre><code>@staticmethod\ndef from_response(response: httpx.Response) -&gt; 'Result':\n    \"\"\"Crea Result desde httpx.Response exitosa.\"\"\"\n    return Result(\n        response=response,\n        request=response.request,\n        status=response.status_code,\n        exception=None\n    )\n</code></pre>"},{"location":"api/http/#R5.http.result.Result.from_exception","title":"from_exception  <code>staticmethod</code>","text":"<pre><code>from_exception(error: Exception, response: Optional[Response] = None) -&gt; Result\n</code></pre> <p>Crea Result desde excepci\u00f3n.</p> Source code in <code>R5/http/result.py</code> <pre><code>@staticmethod\ndef from_exception(error: Exception, response: Optional[httpx.Response] = None) -&gt; 'Result':\n    \"\"\"Crea Result desde excepci\u00f3n.\"\"\"\n    return Result(\n        response=response,\n        request=response.request if response else None,\n        status=response.status_code if response else 0,\n        exception=error\n    )\n</code></pre>"},{"location":"api/http/#R5.http.result.Result.on_status","title":"on_status","text":"<pre><code>on_status(status_code: int, handler: Callable[[Request, Response], None]) -&gt; Result\n</code></pre> <p>Ejecuta handler si el status coincide. Retorna self para chaining.</p> Ejemplo <p>result = await http.get(\"/users/1\") result.on_status(404, lambda req, res: print(\"Not found\"))       .on_status(200, lambda req, res: print(\"OK\"))       .to(UserDTO)</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int</code> <p>C\u00f3digo HTTP a matchear</p> required <code>handler</code> <code>Callable[[Request, Response], None]</code> <p>Funci\u00f3n que recibe (request, response)</p> required <p>Returns:</p> Type Description <code>Result</code> <p>self para permitir chaining</p> Source code in <code>R5/http/result.py</code> <pre><code>def on_status(\n    self, \n    status_code: int, \n    handler: Callable[[httpx.Request, httpx.Response], None]\n) -&gt; 'Result':\n    \"\"\"Ejecuta handler si el status coincide. Retorna self para chaining.\n\n    Ejemplo:\n        result = await http.get(\"/users/1\")\n        result.on_status(404, lambda req, res: print(\"Not found\"))\n              .on_status(200, lambda req, res: print(\"OK\"))\n              .to(UserDTO)\n\n    Args:\n        status_code: C\u00f3digo HTTP a matchear\n        handler: Funci\u00f3n que recibe (request, response)\n\n    Returns:\n        self para permitir chaining\n    \"\"\"\n    if self.status == status_code and self.response and self.request:\n        handler(self.request, self.response)\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.result.Result.on_exception","title":"on_exception","text":"<pre><code>on_exception(handler: Callable[[Exception], None]) -&gt; Result\n</code></pre> <p>Ejecuta handler si hubo excepci\u00f3n. Retorna self para chaining.</p> Ejemplo <p>result = await http.get(\"/users/1\") result.on_exception(lambda e: print(f\"Error: {e}\"))       .to(UserDTO)</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[Exception], None]</code> <p>Funci\u00f3n que recibe la excepci\u00f3n</p> required <p>Returns:</p> Type Description <code>Result</code> <p>self para permitir chaining</p> Source code in <code>R5/http/result.py</code> <pre><code>def on_exception(\n    self, \n    handler: Callable[[Exception], None]\n) -&gt; 'Result':\n    \"\"\"Ejecuta handler si hubo excepci\u00f3n. Retorna self para chaining.\n\n    Ejemplo:\n        result = await http.get(\"/users/1\")\n        result.on_exception(lambda e: print(f\"Error: {e}\"))\n              .to(UserDTO)\n\n    Args:\n        handler: Funci\u00f3n que recibe la excepci\u00f3n\n\n    Returns:\n        self para permitir chaining\n    \"\"\"\n    if self.exception:\n        handler(self.exception)\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.result.Result.to","title":"to","text":"<pre><code>to(target_type: Type[T]) -&gt; Optional[T]\n</code></pre> <p>Proyecta respuesta al tipo especificado.</p> <p>Soporta: - Pydantic BaseModel - @dataclass - TypedDict - dict, list, etc.</p> Ejemplo <p>user = (await http.get(\"/users/1\")).to(UserDTO)</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Instancia del tipo si response existe y mapeo exitoso, None si falla</p> Source code in <code>R5/http/result.py</code> <pre><code>def to(self, target_type: Type[T]) -&gt; Optional[T]:\n    \"\"\"Proyecta respuesta al tipo especificado.\n\n    Soporta:\n    - Pydantic BaseModel\n    - @dataclass\n    - TypedDict\n    - dict, list, etc.\n\n    Ejemplo:\n        user = (await http.get(\"/users/1\")).to(UserDTO)\n\n    Returns:\n        Instancia del tipo si response existe y mapeo exitoso, None si falla\n    \"\"\"\n    if self.exception or not self.response:\n        return None\n\n    try:\n        return self._map_response(self.response, target_type)\n    except Exception:\n        return None\n</code></pre>"},{"location":"api/http/#errores","title":"Errores","text":""},{"location":"api/http/#httperror","title":"HttpError","text":""},{"location":"api/http/#R5.http.errors.HttpError","title":"HttpError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception para errores HTTP.</p>"},{"location":"api/http/#httptimeouterror","title":"HttpTimeoutError","text":""},{"location":"api/http/#R5.http.errors.HttpTimeoutError","title":"HttpTimeoutError","text":"<p>               Bases: <code>HttpError</code></p> <p>Error de timeout en request HTTP.</p>"},{"location":"api/http/#httpconnectionerror","title":"HttpConnectionError","text":""},{"location":"api/http/#R5.http.errors.HttpConnectionError","title":"HttpConnectionError","text":"<p>               Bases: <code>HttpError</code></p> <p>Error de conexi\u00f3n HTTP.</p>"},{"location":"api/http/#httpresponseerror","title":"HttpResponseError","text":""},{"location":"api/http/#R5.http.errors.HttpResponseError","title":"HttpResponseError","text":"<pre><code>HttpResponseError(message: str, status_code: int = 0)\n</code></pre> <p>               Bases: <code>HttpError</code></p> <p>Error en respuesta HTTP.</p> Source code in <code>R5/http/errors.py</code> <pre><code>def __init__(self, message: str, status_code: int = 0):\n    super().__init__(message)\n    self.status_code = status_code\n</code></pre>"},{"location":"api/http/#httpmappingerror","title":"HttpMappingError","text":""},{"location":"api/http/#R5.http.errors.HttpMappingError","title":"HttpMappingError","text":"<p>               Bases: <code>HttpError</code></p> <p>Error al mapear respuesta a DTO.</p>"},{"location":"api/ioc/","title":"IoC API Reference","text":"<p>Documentaci\u00f3n completa de la API del m\u00f3dulo IoC.</p>"},{"location":"api/ioc/#container","title":"Container","text":""},{"location":"api/ioc/#R5.ioc.container.Container","title":"Container","text":""},{"location":"api/ioc/#R5.ioc.container.Container.get_container","title":"get_container  <code>classmethod</code>","text":"<pre><code>get_container() -&gt; dict[type[Any] | Callable[..., Any], providers.Provider]\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef get_container(cls) -&gt; dict[type[Any] | Callable[..., Any], providers.Provider]:\n    return cls._container_by_type\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.get_provider","title":"get_provider  <code>classmethod</code>","text":"<pre><code>get_provider(provider_type: type) -&gt; providers.Provider\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef get_provider(cls, provider_type: type) -&gt; providers.Provider:\n    if provider_type not in cls._container_by_type:\n        available = [\n            f\"{t.__module__}.{t.__qualname__}\"\n            for t in cls._container_by_type.keys()\n        ]\n        raise ProviderNotFoundError(provider_type, available)\n    return cls._container_by_type[provider_type]\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.in_provider","title":"in_provider  <code>classmethod</code>","text":"<pre><code>in_provider(provider_type: type) -&gt; bool\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef in_provider(cls, provider_type: type) -&gt; bool:\n    return provider_type in cls._container_by_type\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.alias_provider","title":"alias_provider  <code>classmethod</code>","text":"<pre><code>alias_provider(alias: type, target: type) -&gt; None\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef alias_provider(cls, alias: type, target: type) -&gt; None:\n    if target not in cls._container_by_type:\n        available = [\n            f\"{t.__module__}.{t.__qualname__}\"\n            for t in cls._container_by_type.keys()\n        ]\n        raise ProviderNotFoundError(target, available)\n    cls._container_by_type[alias] = cls._container_by_type[target]\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.resolve","title":"resolve  <code>classmethod</code>","text":"<pre><code>resolve(dep_type: Type[T]) -&gt; T\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef resolve(cls, dep_type: Type[T]) -&gt; T:\n    stack = cls._resolution_stack.get()\n    if stack is None:\n        stack = []\n        cls._resolution_stack.set(stack)\n\n    dep_name = f\"{dep_type.__module__}.{dep_type.__qualname__}\"\n\n    if dep_name in stack:\n        stack.append(dep_name)\n        raise CircularDependencyError(stack)\n\n    stack.append(dep_name)\n    try:\n        provider = cls.get_provider(dep_type)\n        return provider()\n    finally:\n        stack.pop()\n        if not stack:\n            cls._resolution_stack.set(None)\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.registry_provider","title":"registry_provider  <code>classmethod</code>","text":"<pre><code>registry_provider(func_or_cls: type[Any] | Callable[..., Any], scope: Scope) -&gt; None\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef registry_provider(\n    cls,\n    func_or_cls: type[Any] | Callable[..., Any],\n    scope: Scope,\n) -&gt; None:\n    provider_scope = {\n        Scope.SINGLETON: providers.Singleton,\n        Scope.FACTORY: providers.Factory,\n        Scope.RESOURCE: providers.Resource,\n    }\n\n    if func_or_cls in cls._container_by_type:\n        warnings.warn(\n            f\"Provider for type '{func_or_cls.__name__}' is being overwritten. \"\n            f\"This might indicate duplicate registrations.\",\n            UserWarning,\n            stacklevel=4\n        )\n\n    provider_class = provider_scope[scope]\n\n    if isinstance(func_or_cls, type):\n        try:\n            sig = inspect.signature(func_or_cls.__init__)\n            params = [\n                p for p in sig.parameters.values() \n                if p.name not in ('self', 'cls') and p.annotation != inspect.Parameter.empty\n            ]\n\n            if params:\n                type_hints = get_type_hints(func_or_cls.__init__)\n                injectable_params = {}\n                for p in params:\n                    if p.name in type_hints:\n                        dep_type = type_hints[p.name]\n                        if isinstance(dep_type, type) and cls.in_provider(dep_type):\n                            injectable_params[p.name] = dep_type\n\n                if injectable_params:\n                    def factory(injectable_params=injectable_params, target_cls=func_or_cls):\n                        kwargs = {\n                            param_name: cls.resolve(dep_type)\n                            for param_name, dep_type in injectable_params.items()\n                        }\n                        return target_cls(**kwargs)\n\n                    provider = provider_class(factory)\n                    cls._container_by_type[func_or_cls] = provider\n                    return\n        except Exception:\n            pass\n\n    provider = provider_class(func_or_cls)\n    cls._container_by_type[func_or_cls] = provider\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.reset","title":"reset  <code>classmethod</code>","text":"<pre><code>reset() -&gt; None\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    cls._container_by_type.clear()\n    cls._resolution_stack.set(None)\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.snapshot","title":"snapshot  <code>classmethod</code>","text":"<pre><code>snapshot() -&gt; dict[type[Any] | Callable[..., Any], providers.Provider]\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef snapshot(cls) -&gt; dict[type[Any] | Callable[..., Any], providers.Provider]:\n    return cls._container_by_type.copy()\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.restore","title":"restore  <code>classmethod</code>","text":"<pre><code>restore(snapshot: dict[type[Any] | Callable[..., Any], Provider]) -&gt; None\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef restore(cls, snapshot: dict[type[Any] | Callable[..., Any], providers.Provider]) -&gt; None:\n    cls._container_by_type.clear()\n    cls._container_by_type.update(snapshot)\n    cls._resolution_stack.set(None)\n</code></pre>"},{"location":"api/ioc/#scope","title":"Scope","text":""},{"location":"api/ioc/#R5.ioc.container.Scope","title":"Scope","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/ioc/#decoradores","title":"Decoradores","text":""},{"location":"api/ioc/#singleton","title":"singleton","text":""},{"location":"api/ioc/#R5.ioc.providers.singleton","title":"singleton","text":"<pre><code>singleton(func_or_cls: T) -&gt; T\n</code></pre> Source code in <code>R5/ioc/providers.py</code> <pre><code>def singleton(func_or_cls: T) -&gt; T:\n    return component(scope=Scope.SINGLETON)(func_or_cls)\n</code></pre>"},{"location":"api/ioc/#factory","title":"factory","text":""},{"location":"api/ioc/#R5.ioc.providers.factory","title":"factory","text":"<pre><code>factory(func_or_cls: T) -&gt; T\n</code></pre> Source code in <code>R5/ioc/providers.py</code> <pre><code>def factory(func_or_cls: T) -&gt; T:\n    return component(scope=Scope.FACTORY)(func_or_cls)\n</code></pre>"},{"location":"api/ioc/#resource","title":"resource","text":""},{"location":"api/ioc/#R5.ioc.providers.resource","title":"resource","text":"<pre><code>resource(func_or_cls: T) -&gt; T\n</code></pre> Source code in <code>R5/ioc/providers.py</code> <pre><code>def resource(func_or_cls: T) -&gt; T:\n    return component(scope=Scope.RESOURCE)(func_or_cls)\n</code></pre>"},{"location":"api/ioc/#component","title":"component","text":""},{"location":"api/ioc/#R5.ioc.providers.component","title":"component","text":"<pre><code>component(scope: Scope) -&gt; Callable[[T], T]\n</code></pre> Source code in <code>R5/ioc/providers.py</code> <pre><code>def component(scope: Scope) -&gt; Callable[[T], T]:\n    def wrapper(func_or_cls: Any) -&gt; Any:\n        Container.registry_provider(func_or_cls, scope)\n        return func_or_cls\n\n    return wrapper\n</code></pre>"},{"location":"api/ioc/#inject","title":"inject","text":""},{"location":"api/ioc/#R5.ioc.injection.inject","title":"inject","text":"<pre><code>inject(func: F) -&gt; F\n</code></pre> Source code in <code>R5/ioc/injection.py</code> <pre><code>def inject(func: F) -&gt; F:\n    sig = inspect.signature(func)\n    deps_to_inject: dict[str, type | None] = {}\n\n    try:\n        type_hints = get_type_hints(func)\n    except Exception as e:\n        import warnings\n        warnings.warn(\n            f\"Could not resolve type hints for {func.__name__}: {e}. \"\n            f\"Falling back to raw annotations. Some dependencies may not be injected.\",\n            UserWarning,\n            stacklevel=2\n        )\n        type_hints = {}\n        for param_name, param in sig.parameters.items():\n            if param.annotation != inspect.Parameter.empty:\n                type_hints[param_name] = param.annotation\n\n    for param_name, param in sig.parameters.items():\n        if param_name in (\"self\", \"cls\"):\n            continue\n\n        if param_name not in type_hints:\n            continue\n\n        annotation = type_hints[param_name]\n\n        origin = get_origin(annotation)\n        is_optional = False\n        if origin is Union:\n            args = get_args(annotation)\n            if type(None) in args:\n                is_optional = True\n\n        concrete_type = _extract_concrete_type(annotation)\n\n        if concrete_type is None:\n            continue\n\n        if Container.in_provider(concrete_type):\n            deps_to_inject[param_name] = concrete_type\n        elif is_optional:\n            deps_to_inject[param_name] = None\n\n    new_params = []\n    found_first_injectable = False\n\n    for param_name, param in sig.parameters.items():\n        if param_name in (\"self\", \"cls\"):\n            new_params.append(param)\n            continue\n\n        if param_name in deps_to_inject:\n            found_first_injectable = True\n\n        if found_first_injectable and param_name not in deps_to_inject:\n            if param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD:\n                new_param = param.replace(kind=inspect.Parameter.KEYWORD_ONLY)\n                new_params.append(new_param)\n            else:\n                new_params.append(param)\n        else:\n            new_params.append(param)\n\n    new_sig = sig.replace(parameters=new_params)\n\n    if inspect.iscoroutinefunction(func):\n\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            injected = _inject_dependencies(\n                sig, deps_to_inject, args, kwargs, func.__name__, is_async=True\n            )\n\n            for param_name, provider_instance in injected.items():\n                if inspect.isawaitable(provider_instance):\n                    kwargs[param_name] = await provider_instance\n                else:\n                    kwargs[param_name] = provider_instance\n\n            return await func(*args, **kwargs)\n\n        async_wrapper.__signature__ = new_sig  # type: ignore\n        return async_wrapper  # type: ignore\n    else:\n\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            injected = _inject_dependencies(\n                sig, deps_to_inject, args, kwargs, func.__name__, is_async=False\n            )\n            kwargs.update(injected)\n            return func(*args, **kwargs)\n\n        sync_wrapper.__signature__ = new_sig  # type: ignore\n        return sync_wrapper  # type: ignore\n</code></pre>"},{"location":"api/ioc/#config","title":"config","text":""},{"location":"api/ioc/#R5.ioc.configuration.config","title":"config","text":"<pre><code>config(cls: type[T], *, file: str | None = None, required: bool = True, env_override: bool = True, case_sensitive: bool = False) -&gt; type[T]\n</code></pre><pre><code>config(cls: None = None, *, file: str | None = None, required: bool = True, env_override: bool = True, case_sensitive: bool = False) -&gt; Callable[[type[T]], type[T]]\n</code></pre> <pre><code>config(cls: type[T] | None = None, *, file: str | None = None, required: bool = True, env_override: bool = True, case_sensitive: bool = False) -&gt; type[T] | Callable[[type[T]], type[T]]\n</code></pre> <p>Decorador para clases de configuraci\u00f3n con carga optimizada.</p> <p>Soporta m\u00faltiples formatos: .env, .json, .yml, .yaml, .properties</p> <p>Mejoras: - Carga \u00fanica del archivo (no repetida en cada instancia) - Cache autom\u00e1tico con @lru_cache - Soporte para variables de entorno como override - Mejor conversi\u00f3n de tipos (int, float, bool, list, dict, set, tuple) - Matching flexible de claves</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | None</code> <p>Ruta al archivo de configuraci\u00f3n</p> <code>None</code> <code>required</code> <code>bool</code> <p>Si True, el archivo debe existir</p> <code>True</code> <code>env_override</code> <code>bool</code> <p>Si True, variables de entorno sobreescriben valores del archivo</p> <code>True</code> <code>case_sensitive</code> <code>bool</code> <p>Si True, respeta may\u00fasculas/min\u00fasculas en nombres de campos</p> <code>False</code> Ejemplo <p>@config(file='config.json', env_override=True) class MyConfig:     host: str = 'localhost'     port: int = 8080</p> Source code in <code>R5/ioc/configuration.py</code> <pre><code>def config(\n    cls: type[T] | None = None, \n    *, \n    file: str | None = None, \n    required: bool = True,\n    env_override: bool = True,\n    case_sensitive: bool = False,\n) -&gt; type[T] | Callable[[type[T]], type[T]]:\n    \"\"\"Decorador para clases de configuraci\u00f3n con carga optimizada.\n\n    Soporta m\u00faltiples formatos: .env, .json, .yml, .yaml, .properties\n\n    Mejoras:\n    - Carga \u00fanica del archivo (no repetida en cada instancia)\n    - Cache autom\u00e1tico con @lru_cache\n    - Soporte para variables de entorno como override\n    - Mejor conversi\u00f3n de tipos (int, float, bool, list, dict, set, tuple)\n    - Matching flexible de claves\n\n    Args:\n        file: Ruta al archivo de configuraci\u00f3n\n        required: Si True, el archivo debe existir\n        env_override: Si True, variables de entorno sobreescriben valores del archivo\n        case_sensitive: Si True, respeta may\u00fasculas/min\u00fasculas en nombres de campos\n\n    Ejemplo:\n        @config(file='config.json', env_override=True)\n        class MyConfig:\n            host: str = 'localhost'\n            port: int = 8080\n    \"\"\"\n    def decorator(cls_to_decorate: type[T]) -&gt; type[T]:\n        config_data = _load_config_data(file, required)\n        type_hints = get_type_hints(cls_to_decorate)\n\n        class ConfigClass:\n            _config_data = config_data\n            _type_hints = type_hints\n            _env_override = env_override\n            _case_sensitive = case_sensitive\n\n            def __init__(self, **kwargs: Any):\n                processed_attrs = set()\n\n                for attr_name, attr_type in self._type_hints.items():\n                    if attr_name.startswith('_'):\n                        continue\n\n                    processed_attrs.add(attr_name)\n                    value = self._get_config_value(attr_name, attr_type)\n                    setattr(self, attr_name, value)\n\n                for attr_name in dir(cls_to_decorate):\n                    if attr_name.startswith('_') or attr_name in processed_attrs:\n                        continue\n\n                    attr_value = getattr(cls_to_decorate, attr_name, None)\n                    if callable(attr_value):\n                        continue\n\n                    setattr(self, attr_name, attr_value)\n\n                for key, value in kwargs.items():\n                    setattr(self, key, value)\n\n            def _get_config_value(self, attr_name: str, attr_type: Any) -&gt; Any:\n                value = None\n                source = \"default\"\n\n                if self._env_override:\n                    env_key = attr_name.upper()\n                    env_value = os.environ.get(env_key)\n                    if env_value is not None:\n                        value = env_value\n                        source = \"env\"\n\n                if value is None and self._config_data:\n                    file_value = _match_config_key(attr_name, self._config_data, self._case_sensitive)\n                    if file_value is not None:\n                        value = file_value\n                        source = \"file\"\n\n                if value is None and hasattr(cls_to_decorate, attr_name):\n                    value = getattr(cls_to_decorate, attr_name)\n                    source = \"default\"\n\n                if value is None and not _is_optional(attr_type):\n                    warnings.warn(\n                        f\"Required field '{attr_name}' in {cls_to_decorate.__name__} \"\n                        f\"has no value in config file, environment, or default.\",\n                        UserWarning,\n                    )\n                    return None\n\n                if value is not None and source in (\"env\", \"file\"):\n                    value = _TypeConverter.convert(value, attr_type)\n\n                return value\n\n        ConfigClass.__name__ = cls_to_decorate.__name__\n        ConfigClass.__qualname__ = cls_to_decorate.__qualname__\n        ConfigClass.__module__ = cls_to_decorate.__module__\n        ConfigClass.__annotations__ = getattr(cls_to_decorate, '__annotations__', {})\n\n        Container.registry_provider(ConfigClass, Scope.SINGLETON)\n        Container.alias_provider(cls_to_decorate, ConfigClass)\n\n        return cls_to_decorate\n\n    if cls is None:\n        return decorator\n    else:\n        return decorator(cls)\n</code></pre>"},{"location":"api/ioc/#errores","title":"Errores","text":""},{"location":"api/ioc/#iocerror","title":"IoCError","text":""},{"location":"api/ioc/#R5.ioc.errors.IoCError","title":"IoCError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"api/ioc/#circulardependencyerror","title":"CircularDependencyError","text":""},{"location":"api/ioc/#R5.ioc.errors.CircularDependencyError","title":"CircularDependencyError","text":"<pre><code>CircularDependencyError(dependency_chain: list[str])\n</code></pre> <p>               Bases: <code>IoCError</code></p> Source code in <code>R5/ioc/errors.py</code> <pre><code>def __init__(self, dependency_chain: list[str]):\n    self.dependency_chain = dependency_chain\n    chain_str = \" -&gt; \".join(dependency_chain)\n    super().__init__(\n        f\"Circular dependency detected: {chain_str}\"\n    )\n</code></pre>"},{"location":"api/ioc/#providernotfounderror","title":"ProviderNotFoundError","text":""},{"location":"api/ioc/#R5.ioc.errors.ProviderNotFoundError","title":"ProviderNotFoundError","text":"<pre><code>ProviderNotFoundError(provider_type: Type, available_providers: list[str])\n</code></pre> <p>               Bases: <code>IoCError</code></p> Source code in <code>R5/ioc/errors.py</code> <pre><code>def __init__(self, provider_type: Type, available_providers: list[str]):\n    self.provider_type = provider_type\n    self.available_providers = available_providers\n\n    message = (\n        f\"Provider for type '{provider_type.__name__}' not found in container.\\n\"\n        f\"Available providers: {', '.join(available_providers) if available_providers else 'None'}\\n\"\n        f\"Did you forget to decorate {provider_type.__name__} with @singleton or @factory?\"\n    )\n    super().__init__(message)\n</code></pre>"},{"location":"api/ioc/#asyncproviderinsynccontexterror","title":"AsyncProviderInSyncContextError","text":""},{"location":"api/ioc/#R5.ioc.errors.AsyncProviderInSyncContextError","title":"AsyncProviderInSyncContextError","text":"<pre><code>AsyncProviderInSyncContextError(provider_type: Type)\n</code></pre> <p>               Bases: <code>IoCError</code></p> Source code in <code>R5/ioc/errors.py</code> <pre><code>def __init__(self, provider_type: Type):\n    self.provider_type = provider_type\n    super().__init__(\n        f\"Dependency '{provider_type.__name__}' returned an awaitable in sync context. \"\n        f\"Make the function async or ensure the provider is sync.\"\n    )\n</code></pre>"},{"location":"api/ioc/#dependencyinjectionerror","title":"DependencyInjectionError","text":""},{"location":"api/ioc/#R5.ioc.errors.DependencyInjectionError","title":"DependencyInjectionError","text":"<pre><code>DependencyInjectionError(provider_type: Type, param_name: str, func_name: str, original_error: Exception)\n</code></pre> <p>               Bases: <code>IoCError</code></p> Source code in <code>R5/ioc/errors.py</code> <pre><code>def __init__(self, provider_type: Type, param_name: str, func_name: str, original_error: Exception):\n    self.provider_type = provider_type\n    self.param_name = param_name\n    self.func_name = func_name\n    self.original_error = original_error\n\n    super().__init__(\n        f\"Failed to inject dependency '{provider_type.__name__}' \"\n        f\"for parameter '{param_name}' in function '{func_name}': {original_error}\"\n    )\n</code></pre>"},{"location":"examples/patterns/","title":"Patrones de Dise\u00f1o con R5","text":"<p>Patrones comunes implementados con R5.</p>"},{"location":"examples/patterns/#repository-pattern","title":"Repository Pattern","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Optional\nfrom R5.ioc import singleton, inject\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    def find(self, user_id: int) -&gt; Optional[dict]:\n        pass\n\n    @abstractmethod\n    def save(self, user: dict) -&gt; dict:\n        pass\n\n@singleton\nclass UserRepository(IUserRepository):\n    def __init__(self, db: DatabaseService, logger: Logger):\n        self.db = db\n        self.logger = logger\n\n    def find(self, user_id: int) -&gt; Optional[dict]:\n        self.logger.info(f\"Finding user {user_id}\")\n        return self.db.query(f\"SELECT * FROM users WHERE id = {user_id}\")\n\n    def save(self, user: dict) -&gt; dict:\n        self.logger.info(f\"Saving user {user['id']}\")\n        self.db.execute(f\"INSERT INTO users ...\")\n        return user\n\n@singleton\nclass UserService:\n    def __init__(self, repo: IUserRepository):\n        self.repo = repo\n\n    def get_user(self, user_id: int) -&gt; Optional[dict]:\n        return self.repo.find(user_id)\n</code></pre>"},{"location":"examples/patterns/#service-layer-pattern","title":"Service Layer Pattern","text":"<pre><code>@singleton\nclass EmailService:\n    async def send(self, to: str, subject: str, body: str):\n        print(f\"Sending email to {to}\")\n\n@singleton\nclass UserService:\n    def __init__(self, repo: UserRepository, email: EmailService):\n        self.repo = repo\n        self.email = email\n\n    async def register_user(self, username: str, email_addr: str):\n        user = {\"username\": username, \"email\": email_addr}\n        saved_user = self.repo.save(user)\n        await self.email.send(email_addr, \"Welcome\", \"Thanks for joining!\")\n        return saved_user\n</code></pre>"},{"location":"examples/patterns/#factory-pattern","title":"Factory Pattern","text":"<pre><code>from enum import Enum\n\nclass DatabaseType(Enum):\n    POSTGRES = \"postgres\"\n    MYSQL = \"mysql\"\n    SQLITE = \"sqlite\"\n\nclass DatabaseFactory:\n    @staticmethod\n    def create(db_type: DatabaseType):\n        if db_type == DatabaseType.POSTGRES:\n            return PostgresDatabase()\n        elif db_type == DatabaseType.MYSQL:\n            return MySQLDatabase()\n        else:\n            return SQLiteDatabase()\n\n@singleton\nclass DatabaseService:\n    def __init__(self, config: AppConfig):\n        self.db = DatabaseFactory.create(config.database_type)\n</code></pre>"},{"location":"examples/patterns/#strategy-pattern","title":"Strategy Pattern","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass PaymentStrategy(ABC):\n    @abstractmethod\n    async def process(self, amount: float) -&gt; bool:\n        pass\n\n@singleton\nclass CreditCardPayment(PaymentStrategy):\n    async def process(self, amount: float) -&gt; bool:\n        print(f\"Processing ${amount} via Credit Card\")\n        return True\n\n@singleton\nclass PayPalPayment(PaymentStrategy):\n    async def process(self, amount: float) -&gt; bool:\n        print(f\"Processing ${amount} via PayPal\")\n        return True\n\n@singleton\nclass PaymentService:\n    def __init__(\n        self,\n        credit_card: CreditCardPayment,\n        paypal: PayPalPayment\n    ):\n        self.strategies = {\n            \"credit_card\": credit_card,\n            \"paypal\": paypal\n        }\n\n    async def process_payment(self, method: str, amount: float) -&gt; bool:\n        strategy = self.strategies.get(method)\n        if not strategy:\n            raise ValueError(f\"Unknown payment method: {method}\")\n        return await strategy.process(amount)\n</code></pre>"},{"location":"examples/patterns/#observer-pattern","title":"Observer Pattern","text":"<pre><code>from typing import List, Callable\n\n@singleton\nclass EventManager:\n    def __init__(self):\n        self.observers: dict[str, List[Callable]] = {}\n\n    def subscribe(self, event_type: str, callback: Callable):\n        if event_type not in self.observers:\n            self.observers[event_type] = []\n        self.observers[event_type].append(callback)\n\n    async def notify(self, bg: Background, event_type: str, data: dict):\n        if event_type in self.observers:\n            for callback in self.observers[event_type]:\n                await bg.add(callback, data=data)\n\ndef on_order_created(logger: Logger, data: dict):\n    logger.info(f\"Order created: {data['order_id']}\")\n\ndef send_order_confirmation(email: EmailService, data: dict):\n    email.send(data[\"customer_email\"], \"Order Confirmed\", \"...\")\n\n@inject\nasync def setup_observers(event_manager: EventManager):\n    event_manager.subscribe(\"order.created\", on_order_created)\n    event_manager.subscribe(\"order.created\", send_order_confirmation)\n</code></pre>"},{"location":"examples/patterns/#command-pattern","title":"Command Pattern","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass Command(ABC):\n    @abstractmethod\n    def execute(self):\n        pass\n\nclass CreateUserCommand(Command):\n    def __init__(self, username: str, email: str):\n        self.username = username\n        self.email = email\n\n    def execute(self, user_service: UserService):\n        return user_service.create_user(self.username, self.email)\n\nclass DeleteUserCommand(Command):\n    def __init__(self, user_id: int):\n        self.user_id = user_id\n\n    def execute(self, user_service: UserService):\n        return user_service.delete_user(self.user_id)\n\n@singleton\nclass CommandBus:\n    async def dispatch(self, bg: Background, command: Command):\n        await bg.add(command.execute)\n</code></pre>"},{"location":"examples/patterns/#cqrs-pattern","title":"CQRS Pattern","text":"<pre><code># Commands (Write)\n@singleton\nclass UserCommandService:\n    def __init__(self, repo: UserRepository, events: EventManager):\n        self.repo = repo\n        self.events = events\n\n    async def create_user(self, bg: Background, username: str):\n        user = {\"id\": 123, \"username\": username}\n        self.repo.save(user)\n        await self.events.notify(bg, \"user.created\", user)\n\n# Queries (Read)\n@singleton\nclass UserQueryService:\n    def __init__(self, cache: CacheService, repo: UserRepository):\n        self.cache = cache\n        self.repo = repo\n\n    def get_user(self, user_id: int) -&gt; Optional[dict]:\n        cached = self.cache.get(f\"user:{user_id}\")\n        if cached:\n            return cached\n\n        user = self.repo.find(user_id)\n        self.cache.set(f\"user:{user_id}\", user)\n        return user\n</code></pre>"},{"location":"examples/patterns/#unit-of-work-pattern","title":"Unit of Work Pattern","text":"<pre><code>@resource\nclass UnitOfWork:\n    def __init__(self, db: DatabaseService):\n        self.db = db\n        self.changes = []\n\n    async def __aenter__(self):\n        await self.db.begin_transaction()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            await self.db.rollback()\n        else:\n            await self.db.commit()\n\n    def register_new(self, entity: dict):\n        self.changes.append((\"insert\", entity))\n\n    def register_dirty(self, entity: dict):\n        self.changes.append((\"update\", entity))\n\n@inject\nasync def use_unit_of_work(uow: UnitOfWork):\n    user = {\"id\": 1, \"name\": \"John\"}\n    uow.register_new(user)\n\n    order = {\"id\": 1, \"user_id\": 1, \"total\": 99.99}\n    uow.register_new(order)\n\n    # Commit o rollback autom\u00e1tico al salir\n</code></pre>"},{"location":"examples/patterns/#decorator-pattern","title":"Decorator Pattern","text":"<pre><code>from functools import wraps\nimport time\n\ndef timing_decorator(func):\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        start = time.time()\n        result = await func(*args, **kwargs)\n        elapsed = time.time() - start\n        print(f\"{func.__name__} took {elapsed:.3f}s\")\n        return result\n    return wrapper\n\ndef cache_decorator(func):\n    cache = {}\n\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        key = str(args) + str(kwargs)\n        if key in cache:\n            return cache[key]\n        result = await func(*args, **kwargs)\n        cache[key] = result\n        return result\n    return wrapper\n\n@singleton\nclass UserService:\n    @timing_decorator\n    @cache_decorator\n    async def get_user(self, user_id: int):\n        # Simulate expensive operation\n        await asyncio.sleep(1)\n        return {\"id\": user_id, \"name\": \"John\"}\n</code></pre>"},{"location":"examples/patterns/#builder-pattern","title":"Builder Pattern","text":"<pre><code>@factory\nclass QueryBuilder:\n    def __init__(self):\n        self.query = \"\"\n        self.params = []\n        self.where_clauses = []\n\n    def select(self, *fields):\n        self.query = f\"SELECT {', '.join(fields)}\"\n        return self\n\n    def from_table(self, table: str):\n        self.query += f\" FROM {table}\"\n        return self\n\n    def where(self, condition: str, *params):\n        self.where_clauses.append(condition)\n        self.params.extend(params)\n        return self\n\n    def build(self):\n        if self.where_clauses:\n            self.query += \" WHERE \" + \" AND \".join(self.where_clauses)\n        return (self.query, self.params)\n\n@inject\ndef use_builder(builder: QueryBuilder):\n    query, params = (builder\n        .select(\"id\", \"name\", \"email\")\n        .from_table(\"users\")\n        .where(\"age &gt; ?\", 18)\n        .where(\"active = ?\", True)\n        .build())\n\n    print(query)\n    print(params)\n</code></pre>"},{"location":"examples/patterns/#saga-pattern","title":"Saga Pattern","text":"<pre><code>from typing import List, Callable\n\n@dataclass\nclass SagaStep:\n    action: Callable\n    compensate: Callable\n\n@singleton\nclass SagaOrchestrator:\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n    async def execute(self, steps: List[SagaStep]):\n        executed = []\n\n        try:\n            for step in steps:\n                self.logger.info(f\"Executing step: {step.action.__name__}\")\n                await step.action()\n                executed.append(step)\n        except Exception as e:\n            self.logger.error(f\"Saga failed: {e}\")\n            # Compensate in reverse order\n            for step in reversed(executed):\n                self.logger.info(f\"Compensating: {step.compensate.__name__}\")\n                await step.compensate()\n            raise\n\n# Usage\nasync def create_order():\n    print(\"Creating order\")\n\nasync def rollback_order():\n    print(\"Rolling back order\")\n\nasync def reserve_inventory():\n    print(\"Reserving inventory\")\n\nasync def release_inventory():\n    print(\"Releasing inventory\")\n\nasync def process_payment():\n    print(\"Processing payment\")\n    raise Exception(\"Payment failed\")\n\nasync def refund_payment():\n    print(\"Refunding payment\")\n\n@inject\nasync def run_saga(saga: SagaOrchestrator):\n    steps = [\n        SagaStep(create_order, rollback_order),\n        SagaStep(reserve_inventory, release_inventory),\n        SagaStep(process_payment, refund_payment)\n    ]\n\n    try:\n        await saga.execute(steps)\n    except Exception:\n        print(\"Saga completed with compensation\")\n</code></pre>"},{"location":"examples/patterns/#adapter-pattern","title":"Adapter Pattern","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass PaymentGateway(ABC):\n    @abstractmethod\n    async def charge(self, amount: float) -&gt; bool:\n        pass\n\n# Third-party service\nclass StripeAPI:\n    async def create_charge(self, cents: int):\n        return {\"status\": \"success\"}\n\n# Adapter\n@singleton\nclass StripeAdapter(PaymentGateway):\n    def __init__(self):\n        self.stripe = StripeAPI()\n\n    async def charge(self, amount: float) -&gt; bool:\n        cents = int(amount * 100)\n        result = await self.stripe.create_charge(cents)\n        return result[\"status\"] == \"success\"\n\n@singleton\nclass PaymentService:\n    def __init__(self, gateway: PaymentGateway):\n        self.gateway = gateway\n\n    async def process_payment(self, amount: float) -&gt; bool:\n        return await self.gateway.charge(amount)\n</code></pre>"},{"location":"examples/patterns/#template-method-pattern","title":"Template Method Pattern","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass DataProcessor(ABC):\n    async def process(self, data: dict):\n        validated = await self.validate(data)\n        transformed = await self.transform(validated)\n        result = await self.save(transformed)\n        await self.notify(result)\n        return result\n\n    @abstractmethod\n    async def validate(self, data: dict) -&gt; dict:\n        pass\n\n    @abstractmethod\n    async def transform(self, data: dict) -&gt; dict:\n        pass\n\n    @abstractmethod\n    async def save(self, data: dict) -&gt; dict:\n        pass\n\n    async def notify(self, result: dict):\n        print(f\"Processing complete: {result}\")\n\n@singleton\nclass UserDataProcessor(DataProcessor):\n    async def validate(self, data: dict) -&gt; dict:\n        if \"email\" not in data:\n            raise ValueError(\"Email required\")\n        return data\n\n    async def transform(self, data: dict) -&gt; dict:\n        data[\"email\"] = data[\"email\"].lower()\n        return data\n\n    async def save(self, data: dict) -&gt; dict:\n        # Save to database\n        return data\n</code></pre>"},{"location":"examples/patterns/#chain-of-responsibility","title":"Chain of Responsibility","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Optional\n\nclass Handler(ABC):\n    def __init__(self):\n        self.next_handler: Optional[Handler] = None\n\n    def set_next(self, handler: 'Handler') -&gt; 'Handler':\n        self.next_handler = handler\n        return handler\n\n    async def handle(self, request: dict) -&gt; Optional[dict]:\n        result = await self.process(request)\n        if result:\n            return result\n\n        if self.next_handler:\n            return await self.next_handler.handle(request)\n\n        return None\n\n    @abstractmethod\n    async def process(self, request: dict) -&gt; Optional[dict]:\n        pass\n\n@singleton\nclass AuthenticationHandler(Handler):\n    async def process(self, request: dict) -&gt; Optional[dict]:\n        if \"token\" not in request:\n            return {\"error\": \"Authentication required\"}\n        return None\n\n@singleton\nclass AuthorizationHandler(Handler):\n    async def process(self, request: dict) -&gt; Optional[dict]:\n        if request.get(\"role\") != \"admin\":\n            return {\"error\": \"Insufficient permissions\"}\n        return None\n\n@singleton\nclass ValidationHandler(Handler):\n    async def process(self, request: dict) -&gt; Optional[dict]:\n        if \"data\" not in request:\n            return {\"error\": \"Invalid request\"}\n        return None\n\n@inject\nasync def setup_chain(\n    auth: AuthenticationHandler,\n    authz: AuthorizationHandler,\n    validate: ValidationHandler\n):\n    auth.set_next(authz).set_next(validate)\n\n    request = {\"token\": \"abc\", \"role\": \"admin\", \"data\": {}}\n    result = await auth.handle(request)\n\n    if result:\n        print(f\"Request rejected: {result}\")\n    else:\n        print(\"Request approved\")\n</code></pre>"},{"location":"examples/patterns/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Simple Examples - Ejemplos b\u00e1sicos</li> <li>Real World - Aplicaciones completas</li> <li>API Reference - Documentaci\u00f3n de la API</li> </ul>"},{"location":"examples/real-world/","title":"Ejemplos del Mundo Real","text":"<p>Ejemplos completos de aplicaciones reales usando R5.</p>"},{"location":"examples/real-world/#api-rest-completa","title":"API REST Completa","text":"<p>Una API REST con autenticaci\u00f3n, base de datos y logging.</p> <p>config.py: <pre><code>from R5.ioc import config\n\n@config(file='.env')\nclass AppConfig:\n    database_url: str = \"sqlite:///app.db\"\n    secret_key: str = \"dev-secret-key\"\n    jwt_algorithm: str = \"HS256\"\n    access_token_expire_minutes: int = 30\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n</code></pre></p> <p>services/logger.py: <pre><code>from datetime import datetime\nfrom R5.ioc import singleton\n\n@singleton\nclass Logger:\n    def info(self, message: str):\n        print(f\"[INFO] [{datetime.now()}] {message}\")\n\n    def error(self, message: str):\n        print(f\"[ERROR] [{datetime.now()}] {message}\")\n</code></pre></p> <p>services/database.py: <pre><code>from R5.ioc import singleton\n\n@singleton\nclass DatabaseService:\n    def __init__(self, config: AppConfig, logger: Logger):\n        self.config = config\n        self.logger = logger\n        self.connection = None\n\n    def connect(self):\n        self.logger.info(f\"Connecting to {self.config.database_url}\")\n        # Connection logic\n\n    def query(self, sql: str):\n        self.logger.info(f\"Executing query: {sql}\")\n        # Query logic\n</code></pre></p> <p>services/auth.py: <pre><code>from R5.ioc import singleton\nimport jwt\nfrom datetime import datetime, timedelta\n\n@singleton\nclass AuthService:\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n    def create_token(self, user_id: int) -&gt; str:\n        payload = {\n            \"user_id\": user_id,\n            \"exp\": datetime.utcnow() + timedelta(\n                minutes=self.config.access_token_expire_minutes\n            )\n        }\n        return jwt.encode(\n            payload,\n            self.config.secret_key,\n            algorithm=self.config.jwt_algorithm\n        )\n\n    def verify_token(self, token: str) -&gt; dict:\n        return jwt.decode(\n            token,\n            self.config.secret_key,\n            algorithms=[self.config.jwt_algorithm]\n        )\n</code></pre></p> <p>main.py: <pre><code>import asyncio\nfrom R5.ioc import inject\n\n@inject\nasync def main(\n    config: AppConfig,\n    db: DatabaseService,\n    auth: AuthService,\n    logger: Logger\n):\n    logger.info(\"Starting application\")\n    db.connect()\n\n    # Simulate login\n    token = auth.create_token(user_id=123)\n    logger.info(f\"Token created: {token[:20]}...\")\n\n    # Verify token\n    payload = auth.verify_token(token)\n    logger.info(f\"Token verified for user: {payload['user_id']}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"examples/real-world/#web-scraper","title":"Web Scraper","text":"<p>Scraper concurrente con rate limiting y cach\u00e9.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom R5.http import Http\nfrom R5.background import Background\nfrom R5.ioc import singleton, inject, config\n\n@config(file='.env')\nclass ScraperConfig:\n    max_concurrent: int = 5\n    request_delay: float = 1.0\n    retry_attempts: int = 3\n\n@singleton\nclass CacheService:\n    def __init__(self):\n        self._cache = {}\n\n    def get(self, url: str) -&gt; Optional[str]:\n        return self._cache.get(url)\n\n    def set(self, url: str, content: str):\n        self._cache[url] = content\n\n@singleton\nclass RateLimiter:\n    def __init__(self, config: ScraperConfig):\n        self.delay = config.request_delay\n        self.semaphore = asyncio.Semaphore(config.max_concurrent)\n\n    async def acquire(self):\n        await self.semaphore.acquire()\n        await asyncio.sleep(self.delay)\n\n    def release(self):\n        self.semaphore.release()\n\n@dataclass\nclass ScrapedData:\n    url: str\n    title: str\n    status: int\n\n@singleton\nclass Scraper:\n    def __init__(\n        self,\n        http: Http,\n        cache: CacheService,\n        limiter: RateLimiter,\n        logger: Logger\n    ):\n        self.http = http\n        self.cache = cache\n        self.limiter = limiter\n        self.logger = logger\n\n    async def scrape(self, url: str) -&gt; Optional[ScrapedData]:\n        # Check cache\n        cached = self.cache.get(url)\n        if cached:\n            self.logger.info(f\"Cache hit: {url}\")\n            return cached\n\n        # Rate limit\n        await self.limiter.acquire()\n\n        try:\n            self.logger.info(f\"Scraping: {url}\")\n            result = await self.http.get(url)\n\n            if result.status == 200:\n                data = ScrapedData(\n                    url=url,\n                    title=result.response.text[:100],\n                    status=result.status\n                )\n                self.cache.set(url, data)\n                return data\n            else:\n                self.logger.error(f\"Failed: {url} ({result.status})\")\n                return None\n        finally:\n            self.limiter.release()\n\n@inject\nasync def scrape_websites(scraper: Scraper, logger: Logger):\n    urls = [\n        \"https://example.com\",\n        \"https://example.org\",\n        \"https://example.net\"\n    ]\n\n    results = await asyncio.gather(*[\n        scraper.scrape(url) for url in urls\n    ])\n\n    logger.info(f\"Scraped {len([r for r in results if r])} pages\")\n\nif __name__ == \"__main__\":\n    asyncio.run(scrape_websites())\n</code></pre>"},{"location":"examples/real-world/#task-queue-system","title":"Task Queue System","text":"<p>Sistema de cola de tareas con workers y prioridades.</p> <pre><code>import asyncio\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import Callable, Any\nfrom R5.background import Background\nfrom R5.ioc import singleton, inject\n\nclass Priority(Enum):\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n    CRITICAL = 3\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    handler: Callable\n    args: tuple\n    kwargs: dict\n    priority: Priority\n\n@singleton\nclass TaskQueue:\n    def __init__(self):\n        self.tasks: list[Task] = []\n        self.completed: list[int] = []\n\n    def add_task(\n        self,\n        name: str,\n        handler: Callable,\n        priority: Priority = Priority.NORMAL,\n        *args,\n        **kwargs\n    ):\n        task = Task(\n            id=len(self.tasks) + 1,\n            name=name,\n            handler=handler,\n            args=args,\n            kwargs=kwargs,\n            priority=priority\n        )\n        self.tasks.append(task)\n        return task.id\n\n    def get_next_task(self) -&gt; Optional[Task]:\n        pending = [t for t in self.tasks if t.id not in self.completed]\n        if not pending:\n            return None\n\n        # Sort by priority\n        pending.sort(key=lambda t: t.priority.value, reverse=True)\n        return pending[0]\n\n    def mark_completed(self, task_id: int):\n        self.completed.append(task_id)\n\n@singleton\nclass Worker:\n    def __init__(self, queue: TaskQueue, logger: Logger):\n        self.queue = queue\n        self.logger = logger\n\n    async def process_task(self, task: Task):\n        self.logger.info(\n            f\"Processing task {task.id}: {task.name} \"\n            f\"(Priority: {task.priority.name})\"\n        )\n\n        try:\n            result = task.handler(*task.args, **task.kwargs)\n            if asyncio.iscoroutine(result):\n                await result\n\n            self.queue.mark_completed(task.id)\n            self.logger.info(f\"Task {task.id} completed\")\n        except Exception as e:\n            self.logger.error(f\"Task {task.id} failed: {e}\")\n\n@inject\nasync def run_workers(\n    bg: Background,\n    queue: TaskQueue,\n    worker: Worker,\n    logger: Logger\n):\n    # Add tasks\n    queue.add_task(\"send_email\", send_email, Priority.HIGH, \"user@example.com\")\n    queue.add_task(\"process_image\", process_image, Priority.NORMAL, \"image.jpg\")\n    queue.add_task(\"cleanup\", cleanup_temp, Priority.LOW)\n    queue.add_task(\"critical_alert\", send_alert, Priority.CRITICAL, \"System down\")\n\n    # Process tasks\n    while True:\n        task = queue.get_next_task()\n        if not task:\n            break\n\n        await bg.add(worker.process_task, task)\n\n    await asyncio.sleep(2)\n    logger.info(\"All tasks processed\")\n\ndef send_email(to: str):\n    print(f\"Sending email to {to}\")\n\ndef process_image(filename: str):\n    print(f\"Processing image: {filename}\")\n\ndef cleanup_temp():\n    print(\"Cleaning up temp files\")\n\ndef send_alert(message: str):\n    print(f\"ALERT: {message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(run_workers())\n</code></pre>"},{"location":"examples/real-world/#microservicio-api-gateway","title":"Microservicio API Gateway","text":"<p>Gateway que enruta requests a m\u00faltiples servicios.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom R5.http import Http\nfrom R5.ioc import singleton, inject, config\n\n@config(file='.env')\nclass GatewayConfig:\n    user_service_url: str = \"http://localhost:8001\"\n    order_service_url: str = \"http://localhost:8002\"\n    payment_service_url: str = \"http://localhost:8003\"\n\n@dataclass\nclass ServiceResponse:\n    service: str\n    status: int\n    data: dict\n\n@singleton\nclass ServiceRegistry:\n    def __init__(self, config: GatewayConfig):\n        self.services = {\n            \"users\": config.user_service_url,\n            \"orders\": config.order_service_url,\n            \"payments\": config.payment_service_url\n        }\n\n    def get_url(self, service: str) -&gt; Optional[str]:\n        return self.services.get(service)\n\n@singleton\nclass Gateway:\n    def __init__(\n        self,\n        http: Http,\n        registry: ServiceRegistry,\n        logger: Logger\n    ):\n        self.http = http\n        self.registry = registry\n        self.logger = logger\n\n    async def route(\n        self,\n        service: str,\n        endpoint: str,\n        method: str = \"GET\",\n        **kwargs\n    ) -&gt; ServiceResponse:\n        base_url = self.registry.get_url(service)\n        if not base_url:\n            self.logger.error(f\"Service not found: {service}\")\n            return ServiceResponse(service, 404, {\"error\": \"Service not found\"})\n\n        url = f\"{base_url}{endpoint}\"\n        self.logger.info(f\"Routing to {service}: {method} {url}\")\n\n        if method == \"GET\":\n            result = await self.http.get(url, **kwargs)\n        elif method == \"POST\":\n            result = await self.http.post(url, **kwargs)\n        else:\n            return ServiceResponse(service, 405, {\"error\": \"Method not allowed\"})\n\n        return ServiceResponse(\n            service=service,\n            status=result.status,\n            data=result.to(dict) or {}\n        )\n\n@inject\nasync def gateway_example(gateway: Gateway, logger: Logger):\n    # Route to user service\n    user_response = await gateway.route(\"users\", \"/users/1\")\n    logger.info(f\"User service: {user_response.status}\")\n\n    # Route to order service\n    order_response = await gateway.route(\n        \"orders\",\n        \"/orders\",\n        method=\"POST\",\n        json={\"user_id\": 1, \"amount\": 99.99}\n    )\n    logger.info(f\"Order service: {order_response.status}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(gateway_example())\n</code></pre>"},{"location":"examples/real-world/#sistema-de-notificaciones","title":"Sistema de Notificaciones","text":"<p>Sistema multi-canal de notificaciones (email, SMS, push).</p> <pre><code>import asyncio\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom R5.ioc import singleton, inject\nfrom R5.background import Background\n\nclass Channel(Enum):\n    EMAIL = \"email\"\n    SMS = \"sms\"\n    PUSH = \"push\"\n\n@dataclass\nclass Notification:\n    channel: Channel\n    recipient: str\n    message: str\n    priority: int = 0\n\nclass NotificationProvider(ABC):\n    @abstractmethod\n    async def send(self, recipient: str, message: str):\n        pass\n\n@singleton\nclass EmailProvider(NotificationProvider):\n    async def send(self, recipient: str, message: str):\n        print(f\"\ud83d\udce7 Email to {recipient}: {message}\")\n        await asyncio.sleep(0.1)\n\n@singleton\nclass SMSProvider(NotificationProvider):\n    async def send(self, recipient: str, message: str):\n        print(f\"\ud83d\udcf1 SMS to {recipient}: {message}\")\n        await asyncio.sleep(0.1)\n\n@singleton\nclass PushProvider(NotificationProvider):\n    async def send(self, recipient: str, message: str):\n        print(f\"\ud83d\udd14 Push to {recipient}: {message}\")\n        await asyncio.sleep(0.1)\n\n@singleton\nclass NotificationService:\n    def __init__(\n        self,\n        email: EmailProvider,\n        sms: SMSProvider,\n        push: PushProvider,\n        logger: Logger\n    ):\n        self.providers = {\n            Channel.EMAIL: email,\n            Channel.SMS: sms,\n            Channel.PUSH: push\n        }\n        self.logger = logger\n\n    async def send(self, notification: Notification):\n        provider = self.providers.get(notification.channel)\n        if not provider:\n            self.logger.error(f\"Invalid channel: {notification.channel}\")\n            return\n\n        self.logger.info(\n            f\"Sending {notification.channel.value} notification \"\n            f\"to {notification.recipient}\"\n        )\n\n        try:\n            await provider.send(notification.recipient, notification.message)\n            self.logger.info(f\"Notification sent successfully\")\n        except Exception as e:\n            self.logger.error(f\"Failed to send notification: {e}\")\n\n@inject\nasync def send_notifications(\n    bg: Background,\n    notif_service: NotificationService\n):\n    notifications = [\n        Notification(Channel.EMAIL, \"user@example.com\", \"Welcome!\"),\n        Notification(Channel.SMS, \"+1234567890\", \"Your code: 123456\"),\n        Notification(Channel.PUSH, \"device_token_123\", \"New message\"),\n    ]\n\n    for notif in notifications:\n        await bg.add(notif_service.send, notif)\n\n    await asyncio.sleep(2)\n\nif __name__ == \"__main__\":\n    asyncio.run(send_notifications())\n</code></pre>"},{"location":"examples/real-world/#event-driven-architecture","title":"Event-Driven Architecture","text":"<p>Sistema basado en eventos con suscriptores.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Callable\nfrom R5.ioc import singleton, inject\nfrom R5.background import Background\n\n@dataclass\nclass Event:\n    type: str\n    data: dict\n\n@singleton\nclass EventBus:\n    def __init__(self):\n        self.subscribers: dict[str, list[Callable]] = {}\n\n    def subscribe(self, event_type: str, handler: Callable):\n        if event_type not in self.subscribers:\n            self.subscribers[event_type] = []\n        self.subscribers[event_type].append(handler)\n\n    async def publish(self, bg: Background, event: Event):\n        if event.type not in self.subscribers:\n            return\n\n        for handler in self.subscribers[event.type]:\n            await bg.add(handler, event=event)\n\n# Event Handlers\ndef on_user_registered(logger: Logger, event: Event):\n    logger.info(f\"User registered: {event.data['email']}\")\n\ndef send_welcome_email(email_service: EmailService, event: Event):\n    email_service.send(\n        event.data[\"email\"],\n        \"Welcome!\",\n        \"Thanks for registering\"\n    )\n\ndef create_default_profile(logger: Logger, event: Event):\n    logger.info(f\"Creating profile for {event.data['username']}\")\n\n@inject\nasync def event_driven_example(bg: Background, event_bus: EventBus):\n    # Subscribe to events\n    event_bus.subscribe(\"user.registered\", on_user_registered)\n    event_bus.subscribe(\"user.registered\", send_welcome_email)\n    event_bus.subscribe(\"user.registered\", create_default_profile)\n\n    # Publish event\n    event = Event(\n        type=\"user.registered\",\n        data={\n            \"username\": \"john_doe\",\n            \"email\": \"john@example.com\"\n        }\n    )\n\n    await event_bus.publish(bg, event)\n    await asyncio.sleep(2)\n\nif __name__ == \"__main__\":\n    asyncio.run(event_driven_example())\n</code></pre>"},{"location":"examples/real-world/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Simple Examples - Ejemplos b\u00e1sicos</li> <li>Patterns - Patrones de dise\u00f1o con R5</li> <li>API Reference - Documentaci\u00f3n de la API</li> </ul>"},{"location":"examples/simple/","title":"Ejemplos Simples","text":"<p>Ejemplos b\u00e1sicos para empezar r\u00e1pidamente con R5.</p>"},{"location":"examples/simple/#ioc-hello-world","title":"IoC - Hello World","text":"<pre><code>import asyncio\nfrom R5.ioc import singleton, inject\n\n@singleton\nclass GreetingService:\n    def greet(self, name: str) -&gt; str:\n        return f\"Hello, {name}!\"\n\n@inject\nasync def main(service: GreetingService):\n    message = service.greet(\"World\")\n    print(message)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Ejecuci\u00f3n: <pre><code>uv run python hello.py\n# Output: Hello, World!\n</code></pre></p>"},{"location":"examples/simple/#http-fetch-api","title":"HTTP - Fetch API","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom R5.http import Http\nfrom R5.ioc import inject\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n    username: str\n\n@inject\nasync def fetch_user(http: Http):\n    result = await http.get(\"https://jsonplaceholder.typicode.com/users/1\")\n    user = result.to(User)\n\n    if user:\n        print(f\"\u2705 User: {user.name}\")\n        print(f\"   Email: {user.email}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(fetch_user())\n</code></pre> <p>Ejecuci\u00f3n: <pre><code>uv run python fetch_user.py\n</code></pre></p>"},{"location":"examples/simple/#background-tareas-simples","title":"Background - Tareas Simples","text":"<pre><code>import asyncio\nfrom R5.background import Background\nfrom R5.ioc import inject\n\ndef process_item(item_id: int):\n    print(f\"Processing item {item_id}\")\n\n@inject\nasync def main(bg: Background):\n    for i in range(5):\n        await bg.add(process_item, i)\n\n    await asyncio.sleep(1)\n    print(\"All tasks completed\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Ejecuci\u00f3n: <pre><code>uv run python background_simple.py\n</code></pre></p>"},{"location":"examples/simple/#configuration-archivo-json","title":"Configuration - Archivo JSON","text":"<p>config.json: <pre><code>{\n  \"app_name\": \"MyApp\",\n  \"port\": 8080,\n  \"debug\": true\n}\n</code></pre></p> <p>app.py: <pre><code>from R5.ioc import config, inject\n\n@config(file='config.json')\nclass AppConfig:\n    app_name: str = \"DefaultApp\"\n    port: int = 3000\n    debug: bool = False\n\n@inject\nasync def main(config: AppConfig):\n    print(f\"App: {config.app_name}\")\n    print(f\"Port: {config.port}\")\n    print(f\"Debug: {config.debug}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre></p> <p>Ejecuci\u00f3n: <pre><code>uv run python app.py\n</code></pre></p>"},{"location":"examples/simple/#todo-list-api","title":"Todo List API","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom R5.http import Http\nfrom R5.ioc import inject\n\n@dataclass\nclass Todo:\n    id: Optional[int]\n    title: str\n    completed: bool = False\n    userId: int = 1\n\n@inject\nasync def todo_crud(http: Http):\n    base_url = \"https://jsonplaceholder.typicode.com\"\n\n    # CREATE\n    print(\"Creating todo...\")\n    new_todo = Todo(id=None, title=\"Learn R5\", completed=False)\n    create_result = await http.post(\n        f\"{base_url}/todos\",\n        json={\"title\": new_todo.title, \"completed\": new_todo.completed, \"userId\": 1}\n    )\n    created = create_result.to(Todo)\n    print(f\"\u2705 Created: {created.title} (ID: {created.id})\")\n\n    # READ\n    print(\"\\nReading todo...\")\n    read_result = await http.get(f\"{base_url}/todos/1\")\n    todo = read_result.to(Todo)\n    print(f\"\u2705 Read: {todo.title}\")\n\n    # UPDATE\n    print(\"\\nUpdating todo...\")\n    update_result = await http.put(\n        f\"{base_url}/todos/1\",\n        json={\"title\": \"Master R5\", \"completed\": True, \"userId\": 1}\n    )\n    updated = update_result.to(Todo)\n    print(f\"\u2705 Updated: {updated.title} (Completed: {updated.completed})\")\n\n    # DELETE\n    print(\"\\nDeleting todo...\")\n    delete_result = await http.delete(f\"{base_url}/todos/1\")\n    print(f\"\u2705 Deleted (Status: {delete_result.status})\")\n\nif __name__ == \"__main__\":\n    asyncio.run(todo_crud())\n</code></pre>"},{"location":"examples/simple/#email-service","title":"Email Service","text":"<pre><code>import asyncio\nfrom R5.ioc import singleton, inject\nfrom R5.background import Background\n\n@singleton\nclass EmailService:\n    def send(self, to: str, subject: str, body: str):\n        print(f\"\ud83d\udce7 Sending email to {to}\")\n        print(f\"   Subject: {subject}\")\n        print(f\"   Body: {body}\")\n\n@inject\nasync def send_emails(bg: Background, email: EmailService):\n    users = [\n        (\"user1@example.com\", \"John\"),\n        (\"user2@example.com\", \"Jane\"),\n        (\"user3@example.com\", \"Bob\")\n    ]\n\n    for email_addr, name in users:\n        await bg.add(\n            email.send,\n            email_addr,\n            \"Welcome!\",\n            f\"Hi {name}, welcome to our platform!\"\n        )\n\n    await asyncio.sleep(1)\n    print(\"\\n\u2705 All emails sent\")\n\nif __name__ == \"__main__\":\n    asyncio.run(send_emails())\n</code></pre>"},{"location":"examples/simple/#logger-service","title":"Logger Service","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom R5.ioc import singleton, inject\n\n@singleton\nclass Logger:\n    def info(self, message: str):\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        print(f\"[INFO] [{timestamp}] {message}\")\n\n    def error(self, message: str):\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        print(f\"[ERROR] [{timestamp}] {message}\")\n\n@singleton\nclass UserService:\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n    def create_user(self, username: str):\n        self.logger.info(f\"Creating user: {username}\")\n        # Create user logic\n        self.logger.info(f\"User created: {username}\")\n\n@inject\nasync def main(user_service: UserService):\n    user_service.create_user(\"john_doe\")\n    user_service.create_user(\"jane_doe\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/simple/#api-client-con-retry","title":"API Client con Retry","text":"<pre><code>import asyncio\nfrom R5.http import Http\nfrom R5.ioc import inject\n\n@inject\nasync def fetch_with_retry(http: Http):\n    result = await http.retry(\n        attempts=3,\n        delay=1.0,\n        when_status=(500, 502, 503)\n    ).get(\"https://jsonplaceholder.typicode.com/posts/1\")\n\n    if result.status == 200:\n        data = result.to(dict)\n        print(f\"\u2705 Title: {data['title']}\")\n    else:\n        print(f\"\u274c Failed with status: {result.status}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(fetch_with_retry())\n</code></pre>"},{"location":"examples/simple/#cache-service","title":"Cache Service","text":"<pre><code>import asyncio\nfrom typing import Any, Optional\nfrom R5.ioc import singleton, inject\n\n@singleton\nclass CacheService:\n    def __init__(self):\n        self._cache: dict[str, Any] = {}\n\n    def get(self, key: str) -&gt; Optional[Any]:\n        return self._cache.get(key)\n\n    def set(self, key: str, value: Any):\n        self._cache[key] = value\n        print(f\"Cached: {key}\")\n\n    def clear(self):\n        self._cache.clear()\n        print(\"Cache cleared\")\n\n@inject\nasync def use_cache(cache: CacheService):\n    # Set values\n    cache.set(\"user:1\", {\"name\": \"John\", \"email\": \"john@example.com\"})\n    cache.set(\"user:2\", {\"name\": \"Jane\", \"email\": \"jane@example.com\"})\n\n    # Get values\n    user1 = cache.get(\"user:1\")\n    print(f\"Retrieved: {user1}\")\n\n    # Clear cache\n    cache.clear()\n\nif __name__ == \"__main__\":\n    asyncio.run(use_cache())\n</code></pre>"},{"location":"examples/simple/#parallel-http-requests","title":"Parallel HTTP Requests","text":"<pre><code>import asyncio\nfrom R5.http import Http\nfrom R5.ioc import inject\n\n@inject\nasync def fetch_multiple(http: Http):\n    urls = [\n        \"https://jsonplaceholder.typicode.com/users/1\",\n        \"https://jsonplaceholder.typicode.com/users/2\",\n        \"https://jsonplaceholder.typicode.com/users/3\"\n    ]\n\n    results = await asyncio.gather(*[\n        http.get(url) for url in urls\n    ])\n\n    for i, result in enumerate(results, 1):\n        if result.status == 200:\n            user = result.to(dict)\n            print(f\"User {i}: {user['name']}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(fetch_multiple())\n</code></pre>"},{"location":"examples/simple/#environment-variables","title":"Environment Variables","text":"<p>.env: <pre><code>DATABASE_URL=postgresql://localhost/mydb\nAPI_KEY=secret-key-123\nDEBUG=true\nPORT=8080\n</code></pre></p> <p>app.py: <pre><code>import asyncio\nfrom R5.ioc import config, inject\n\n@config(file='.env')\nclass AppConfig:\n    database_url: str\n    api_key: str\n    debug: bool\n    port: int\n\n@inject\nasync def main(config: AppConfig):\n    print(f\"Database: {config.database_url}\")\n    print(f\"API Key: {config.api_key[:10]}...\")\n    print(f\"Debug: {config.debug}\")\n    print(f\"Port: {config.port}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"examples/simple/#factory-pattern","title":"Factory Pattern","text":"<pre><code>import asyncio\nfrom uuid import uuid4\nfrom R5.ioc import factory, inject, Container\n\n@factory\nclass RequestContext:\n    def __init__(self):\n        self.id = uuid4()\n        self.timestamp = asyncio.get_event_loop().time()\n\n    def __repr__(self):\n        return f\"Request({self.id})\"\n\n@inject\nasync def main():\n    ctx1 = Container.resolve(RequestContext)\n    ctx2 = Container.resolve(RequestContext)\n\n    print(f\"Context 1: {ctx1}\")\n    print(f\"Context 2: {ctx2}\")\n    print(f\"Different instances: {ctx1 is not ctx2}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/simple/#ejecucion-de-todos-los-ejemplos","title":"Ejecuci\u00f3n de Todos los Ejemplos","text":"<p>Crea un archivo <code>run_examples.sh</code>:</p> <pre><code>#!/bin/bash\n\necho \"Running R5 Examples...\"\necho \"=====================\"\n\necho \"\\n1. Hello World\"\nuv run python hello.py\n\necho \"\\n2. Fetch User\"\nuv run python fetch_user.py\n\necho \"\\n3. Background Tasks\"\nuv run python background_simple.py\n\necho \"\\n4. Configuration\"\nuv run python app.py\n\necho \"\\n5. Todo CRUD\"\nuv run python todo_crud.py\n\necho \"\\n6. Email Service\"\nuv run python email_service.py\n\necho \"\\n7. Logger\"\nuv run python logger_example.py\n\necho \"\\n8. Retry\"\nuv run python retry_example.py\n\necho \"\\n9. Cache\"\nuv run python cache_example.py\n\necho \"\\n10. Parallel Requests\"\nuv run python parallel_requests.py\n\necho \"\\nAll examples completed!\"\n</code></pre> <p>Ejecuta: <pre><code>chmod +x run_examples.sh\n./run_examples.sh\n</code></pre></p>"},{"location":"getting-started/core-concepts/","title":"Conceptos Fundamentales","text":"<p>Entiende los conceptos clave que hacen funcionar R5.</p>"},{"location":"getting-started/core-concepts/#arquitectura-del-framework","title":"Arquitectura del Framework","text":"<p>R5 est\u00e1 construido sobre tres pilares fundamentales:</p> <pre><code>graph TB\n    A[R5 Framework] --&gt; B[IoC Container]\n    A --&gt; C[HTTP Client]\n    A --&gt; D[Background Tasks]\n\n    B --&gt; B1[Dependency Injection]\n    B --&gt; B2[Configuration Management]\n    B --&gt; B3[Lifecycle Management]\n\n    C --&gt; C1[Connection Pooling]\n    C --&gt; C2[Result Pattern]\n    C --&gt; C3[Retry Logic]\n\n    D --&gt; D1[Concurrent Execution]\n    D --&gt; D2[IoC Integration]\n    D --&gt; D3[Error Handling]</code></pre>"},{"location":"getting-started/core-concepts/#1-ioc-container-inversion-of-control","title":"1. IoC Container (Inversion of Control)","text":""},{"location":"getting-started/core-concepts/#que-es-ioc","title":"\u00bfQu\u00e9 es IoC?","text":"<p>Inversi\u00f3n de Control (IoC) es un patr\u00f3n donde el framework controla el flujo de la aplicaci\u00f3n y la creaci\u00f3n de objetos, en lugar de que tu c\u00f3digo lo haga manualmente.</p>"},{"location":"getting-started/core-concepts/#componentes-del-ioc","title":"Componentes del IoC","text":""},{"location":"getting-started/core-concepts/#container","title":"Container","text":"<p>El contenedor central que registra y resuelve dependencias:</p> <pre><code>from R5.ioc import Container\n\ncontainer = Container.get_container()\nprovider = Container.get_provider(MyService)\ninstance = Container.resolve(MyService)\n</code></pre>"},{"location":"getting-started/core-concepts/#scopes-alcances","title":"Scopes (Alcances)","text":"<p>R5 soporta tres scopes:</p> <p>Singleton - Una \u00fanica instancia compartida:</p> <pre><code>from R5.ioc import singleton\n\n@singleton\nclass DatabaseConnection:\n    def __init__(self):\n        self.conn = connect_to_db()\n</code></pre> <p>Factory - Nueva instancia en cada resoluci\u00f3n:</p> <pre><code>from R5.ioc import factory\n\n@factory\nclass Request:\n    def __init__(self):\n        self.id = generate_uuid()\n</code></pre> <p>Resource - Instancia con lifecycle (context manager):</p> <pre><code>from R5.ioc import resource\n\n@resource\nclass FileHandler:\n    async def __aenter__(self):\n        self.file = open(\"data.txt\")\n        return self\n\n    async def __aexit__(self, *args):\n        self.file.close()\n</code></pre>"},{"location":"getting-started/core-concepts/#dependency-injection","title":"Dependency Injection","text":"<p>Inyecci\u00f3n autom\u00e1tica basada en type hints:</p> <pre><code>from R5.ioc import inject, singleton\n\n@singleton\nclass EmailService:\n    def send(self, to: str, message: str):\n        print(f\"Sending to {to}: {message}\")\n\n@singleton\nclass UserService:\n    def __init__(self, email: EmailService):\n        self._email = email\n\n    def notify_user(self, user_email: str):\n        self._email.send(user_email, \"Welcome!\")\n\n@inject\ndef process(user_svc: UserService):\n    user_svc.notify_user(\"user@example.com\")\n\nprocess()\n</code></pre>"},{"location":"getting-started/core-concepts/#configuration-management","title":"Configuration Management","text":"<p>Carga configuraci\u00f3n desde m\u00faltiples formatos:</p> <pre><code>from R5.ioc import config\n\n@config(file='config.json')\nclass AppConfig:\n    database_url: str = \"sqlite:///db.sqlite\"\n    api_key: str = \"\"\n    debug: bool = False\n    workers: int = 4\n</code></pre> <p>Formatos soportados:</p> <ul> <li><code>.env</code> - Variables de entorno</li> <li><code>.json</code> - JSON</li> <li><code>.yml</code>/<code>.yaml</code> - YAML</li> <li><code>.properties</code> - Java properties</li> </ul>"},{"location":"getting-started/core-concepts/#2-http-client","title":"2. HTTP Client","text":""},{"location":"getting-started/core-concepts/#connection-pooling","title":"Connection Pooling","text":"<p>R5 usa <code>httpx.AsyncClient</code> con pooling autom\u00e1tico:</p> <pre><code>from R5.http import Http\nfrom R5.ioc import inject\n\n@inject\nasync def fetch_data(http: Http):\n    # Reutiliza conexiones del pool\n    result1 = await http.get(\"/users/1\")\n    result2 = await http.get(\"/users/2\")\n    result3 = await http.get(\"/users/3\")\n</code></pre>"},{"location":"getting-started/core-concepts/#result-pattern","title":"Result Pattern","text":"<p>Manejo de errores sin excepciones:</p> <pre><code>result = await http.get(\"/users/999\")\n\nif result.status == 404:\n    print(\"Usuario no encontrado\")\nelif result.status == 200:\n    user = result.to(UserDTO)\n    print(f\"Usuario: {user.name}\")\n\nresult.on_status(404, lambda req, res: handle_not_found())\nresult.on_exception(lambda e: log_error(e))\n</code></pre>"},{"location":"getting-started/core-concepts/#configuracion","title":"Configuraci\u00f3n","text":"<p>Configura timeouts, retry, proxies:</p> <pre><code>from R5.http.http import HttpConfig\nfrom R5.ioc import config\n\n@config\nclass MyHttpConfig(HttpConfig):\n    max_connections: int = 100\n    connect_timeout: float = 5.0\n    max_retries: int = 3\n    retry_backoff_factor: float = 0.5\n</code></pre>"},{"location":"getting-started/core-concepts/#3-background-tasks","title":"3. Background Tasks","text":""},{"location":"getting-started/core-concepts/#ejecucion-concurrente","title":"Ejecuci\u00f3n Concurrente","text":"<p>Ejecuta tareas en paralelo con anyio:</p> <pre><code>from R5.background import Background\nfrom R5.ioc import inject\n\n@inject\nasync def process_batch(bg: Background):\n    for i in range(100):\n        await bg.add(process_item, i)\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"getting-started/core-concepts/#integracion-con-ioc","title":"Integraci\u00f3n con IoC","text":"<p>Las tareas pueden recibir dependencias inyectadas:</p> <pre><code>@singleton\nclass Logger:\n    def log(self, msg: str):\n        print(f\"[LOG] {msg}\")\n\ndef background_task(logger: Logger, item_id: int):\n    logger.log(f\"Processing item {item_id}\")\n\n@inject\nasync def main(bg: Background):\n    await bg.add(background_task, item_id=42)\n</code></pre>"},{"location":"getting-started/core-concepts/#lifecycle-management","title":"Lifecycle Management","text":"<p>Background usa context manager para cleanup autom\u00e1tico:</p> <pre><code>@inject\nasync def with_cleanup(bg: Background):\n    await bg.add(task1)\n    await bg.add(task2)\n\n    await asyncio.sleep(0.5)\n\n# Al salir, Background espera a que terminen las tareas\n</code></pre>"},{"location":"getting-started/core-concepts/#flujo-de-ejecucion","title":"Flujo de Ejecuci\u00f3n","text":"<pre><code>sequenceDiagram\n    participant App\n    participant Container\n    participant Provider\n    participant Instance\n\n    App-&gt;&gt;Container: @inject decorator\n    Container-&gt;&gt;Container: Analyze function signature\n    Container-&gt;&gt;Container: Identify dependencies\n    Container-&gt;&gt;Provider: Resolve each dependency\n    Provider-&gt;&gt;Instance: Create/Return instance\n    Instance-&gt;&gt;App: Inject into function\n    App-&gt;&gt;Instance: Execute with dependencies</code></pre>"},{"location":"getting-started/core-concepts/#type-safety","title":"Type Safety","text":"<p>R5 aprovecha el sistema de tipos de Python:</p> <pre><code>from typing import Optional\n\n@singleton\nclass CacheService:\n    pass\n\n@inject\ndef handler(\n    cache: CacheService,              # Required\n    optional_cache: Optional[CacheService]  # Optional\n):\n    if optional_cache:\n        print(\"Cache available\")\n</code></pre>"},{"location":"getting-started/core-concepts/#principios-de-diseno","title":"Principios de Dise\u00f1o","text":""},{"location":"getting-started/core-concepts/#1-simplicidad","title":"1. Simplicidad","text":"<pre><code>@singleton\nclass MyService:\n    pass\n\n@inject\ndef use_service(svc: MyService):\n    pass\n</code></pre> <p>Sin configuraci\u00f3n XML, sin archivos complejos. Solo decoradores.</p>"},{"location":"getting-started/core-concepts/#2-type-safe","title":"2. Type-Safe","text":"<p>El container usa type hints para resoluci\u00f3n:</p> <pre><code>@inject\ndef handler(\n    service_a: ServiceA,  # Tipo correcto\n    service_b: ServiceB   # Tipo correcto\n):\n    pass\n</code></pre>"},{"location":"getting-started/core-concepts/#3-modularidad","title":"3. Modularidad","text":"<p>Usa solo lo que necesitas:</p> <pre><code># Solo IoC\nfrom R5.ioc import singleton, inject\n\n# Solo HTTP\nfrom R5.http import Http\n\n# Solo Background\nfrom R5.background import Background\n</code></pre>"},{"location":"getting-started/core-concepts/#4-explicit-over-implicit","title":"4. Explicit over Implicit","text":"<pre><code>@inject\nasync def explicit_deps(\n    http: Http,\n    bg: Background,\n    config: AppConfig\n):\n    pass\n</code></pre> <p>Las dependencias son expl\u00edcitas en la firma de la funci\u00f3n.</p>"},{"location":"getting-started/core-concepts/#patrones-comunes","title":"Patrones Comunes","text":""},{"location":"getting-started/core-concepts/#service-layer","title":"Service Layer","text":"<pre><code>@singleton\nclass UserRepository:\n    async def find(self, user_id: int):\n        pass\n\n@singleton\nclass UserService:\n    def __init__(self, repo: UserRepository):\n        self._repo = repo\n\n    async def get_user(self, user_id: int):\n        return await self._repo.find(user_id)\n</code></pre>"},{"location":"getting-started/core-concepts/#factory-pattern","title":"Factory Pattern","text":"<pre><code>@factory\nclass RequestContext:\n    def __init__(self):\n        self.request_id = uuid4()\n        self.timestamp = datetime.now()\n</code></pre>"},{"location":"getting-started/core-concepts/#resource-pattern","title":"Resource Pattern","text":"<pre><code>@resource\nclass DatabaseSession:\n    async def __aenter__(self):\n        self.session = create_session()\n        return self\n\n    async def __aexit__(self, *args):\n        await self.session.close()\n</code></pre>"},{"location":"getting-started/core-concepts/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Profundiza en IoC Container</li> <li>Aprende sobre HTTP Client</li> <li>Explora Background Tasks</li> <li>Revisa Ejemplos pr\u00e1cticos</li> </ul>"},{"location":"getting-started/installation/","title":"Instalaci\u00f3n","text":"<p>Esta gu\u00eda te muestra c\u00f3mo instalar R5 en tu proyecto.</p>"},{"location":"getting-started/installation/#requisitos","title":"Requisitos","text":"<ul> <li>Python 3.14 o superior</li> <li><code>pip</code> o <code>uv</code> como gestor de paquetes</li> </ul>"},{"location":"getting-started/installation/#instalacion-con-pip","title":"Instalaci\u00f3n con pip","text":"<pre><code>pip install r5\n</code></pre>"},{"location":"getting-started/installation/#instalacion-con-uv-recomendado","title":"Instalaci\u00f3n con uv (Recomendado)","text":"<p>uv es un gestor de paquetes ultra r\u00e1pido para Python.</p> <pre><code># Instalar uv si no lo tienes\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Agregar R5 a tu proyecto\nuv add r5\n</code></pre>"},{"location":"getting-started/installation/#instalacion-desde-el-codigo-fuente","title":"Instalaci\u00f3n desde el c\u00f3digo fuente","text":"<pre><code>git clone https://github.com/grupor5/R5.git\ncd R5\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#dependencias","title":"Dependencias","text":"<p>R5 instala autom\u00e1ticamente las siguientes dependencias:</p> <ul> <li>anyio (&gt;=4.12.0) - Para tareas concurrentes</li> <li>dependency-injector (&gt;=4.48.3) - Motor de IoC</li> <li>httpx (&gt;=0.28.1) - Cliente HTTP as\u00edncrono</li> <li>pydantic (&gt;=2.12.5) - Validaci\u00f3n de datos</li> <li>pydantic-settings (&gt;=2.12.0) - Gesti\u00f3n de configuraci\u00f3n</li> <li>pyyaml (&gt;=6.0.3) - Soporte para archivos YAML</li> </ul>"},{"location":"getting-started/installation/#verificar-la-instalacion","title":"Verificar la instalaci\u00f3n","text":"<p>Verifica que R5 se instal\u00f3 correctamente:</p> <pre><code>import R5\nfrom R5.ioc import singleton, inject\nfrom R5.http import Http\nfrom R5.background import Background\n\nprint(\"\u2705 R5 instalado correctamente\")\n</code></pre>"},{"location":"getting-started/installation/#dependencias-opcionales","title":"Dependencias opcionales","text":""},{"location":"getting-started/installation/#para-desarrollo","title":"Para desarrollo","text":"<pre><code>uv add --dev pytest pytest-asyncio pytest-cov\n</code></pre>"},{"location":"getting-started/installation/#para-documentacion","title":"Para documentaci\u00f3n","text":"<pre><code>uv add --group docs mkdocs mkdocs-material mkdocstrings[python]\n</code></pre>"},{"location":"getting-started/installation/#actualizar-r5","title":"Actualizar R5","text":""},{"location":"getting-started/installation/#con-pip","title":"Con pip","text":"<pre><code>pip install --upgrade r5\n</code></pre>"},{"location":"getting-started/installation/#con-uv","title":"Con uv","text":"<pre><code>uv add --upgrade r5\n</code></pre>"},{"location":"getting-started/installation/#desinstalacion","title":"Desinstalaci\u00f3n","text":""},{"location":"getting-started/installation/#con-pip_1","title":"Con pip","text":"<pre><code>pip uninstall r5\n</code></pre>"},{"location":"getting-started/installation/#con-uv_1","title":"Con uv","text":"<pre><code>uv remove r5\n</code></pre>"},{"location":"getting-started/installation/#proximos-pasos","title":"Pr\u00f3ximos pasos","text":"<p>Una vez instalado R5, contin\u00faa con:</p> <ul> <li>Quick Start - Tu primera aplicaci\u00f3n con R5</li> <li>Core Concepts - Conceptos fundamentales del framework</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Aprende los fundamentos de R5 en 5 minutos.</p>"},{"location":"getting-started/quickstart/#tu-primera-aplicacion","title":"Tu primera aplicaci\u00f3n","text":"<p>Crea un archivo <code>app.py</code>:</p> <pre><code>import asyncio\nfrom R5.ioc import singleton, inject\n\n@singleton\nclass GreetingService:\n    def greet(self, name: str) -&gt; str:\n        return f\"Hello, {name}!\"\n\n@inject\nasync def main(service: GreetingService):\n    message = service.greet(\"World\")\n    print(message)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Ejecuta:</p> <pre><code>uv run python app.py\n# Output: Hello, World!\n</code></pre>"},{"location":"getting-started/quickstart/#ejemplo-con-http","title":"Ejemplo con HTTP","text":"<p>Crea <code>http_app.py</code>:</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom R5.http import Http\nfrom R5.ioc import inject\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n    username: str\n\n@inject\nasync def fetch_user(http: Http):\n    result = await http.get(\"https://jsonplaceholder.typicode.com/users/1\")\n    user = result.to(User)\n\n    if user:\n        print(f\"User: {user.name} ({user.email})\")\n\nif __name__ == \"__main__\":\n    asyncio.run(fetch_user())\n</code></pre> <p>Ejecuta:</p> <pre><code>uv run python http_app.py\n</code></pre>"},{"location":"getting-started/quickstart/#ejemplo-con-background-tasks","title":"Ejemplo con Background Tasks","text":"<p>Crea <code>background_app.py</code>:</p> <pre><code>import asyncio\nfrom R5.background import Background\nfrom R5.ioc import singleton, inject\n\n@singleton\nclass NotificationService:\n    def notify(self, message: str):\n        print(f\"\ud83d\udce7 Notification: {message}\")\n\ndef send_email(to: str):\n    print(f\"\u2709\ufe0f  Sending email to {to}\")\n\n@inject\nasync def main(bg: Background, notifier: NotificationService):\n    await bg.add(send_email, \"user@example.com\")\n    await bg.add(send_email, \"admin@example.com\")\n    await bg.add(lambda: notifier.notify(\"Tasks completed\"))\n\n    await asyncio.sleep(0.5)\n    print(\"All tasks queued!\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Ejecuta:</p> <pre><code>uv run python background_app.py\n</code></pre>"},{"location":"getting-started/quickstart/#ejemplo-completo","title":"Ejemplo Completo","text":"<p>Combina todos los m\u00f3dulos en <code>complete_app.py</code>:</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom R5.ioc import singleton, inject, config\nfrom R5.http import Http\nfrom R5.background import Background\n\n@config(file='.env')\nclass AppConfig:\n    api_url: str = \"https://jsonplaceholder.typicode.com\"\n\n@singleton\nclass LogService:\n    def log(self, message: str):\n        print(f\"[LOG] {message}\")\n\n@dataclass\nclass Post:\n    id: int\n    title: str\n    userId: int\n\n@inject\nasync def main(\n    config: AppConfig,\n    http: Http,\n    bg: Background,\n    log: LogService\n):\n    log.log(\"Application started\")\n\n    result = await http.get(f\"{config.api_url}/posts/1\")\n    post = result.to(Post)\n\n    if post:\n        log.log(f\"Fetched post: {post.title}\")\n\n        await bg.add(\n            lambda: log.log(f\"Processing post #{post.id}\")\n        )\n\n        await asyncio.sleep(0.3)\n\n    log.log(\"Application finished\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Crea <code>.env</code>:</p> <pre><code>API_URL=https://jsonplaceholder.typicode.com\n</code></pre> <p>Ejecuta:</p> <pre><code>uv run python complete_app.py\n</code></pre>"},{"location":"getting-started/quickstart/#estructura-de-proyecto-recomendada","title":"Estructura de proyecto recomendada","text":"<pre><code>my_project/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2502   \u2514\u2500\u2500 email_service.py\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u2514\u2500\u2500 main.py\n\u251c\u2500\u2500 tests/\n\u2502   \u2514\u2500\u2500 test_services.py\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .env.example\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"getting-started/quickstart/#appconfigpy","title":"<code>app/config.py</code>","text":"<pre><code>from R5.ioc import config\n\n@config(file='.env')\nclass AppConfig:\n    database_url: str = \"sqlite:///app.db\"\n    api_key: str = \"\"\n    debug: bool = False\n</code></pre>"},{"location":"getting-started/quickstart/#appservicesuser_servicepy","title":"<code>app/services/user_service.py</code>","text":"<pre><code>from R5.ioc import singleton\nfrom R5.http import Http\n\n@singleton\nclass UserService:\n    def __init__(self, http: Http):\n        self._http = http\n\n    async def get_user(self, user_id: int):\n        result = await self._http.get(f\"/users/{user_id}\")\n        return result.to(dict)\n</code></pre>"},{"location":"getting-started/quickstart/#appmainpy","title":"<code>app/main.py</code>","text":"<pre><code>import asyncio\nfrom R5.ioc import inject\nfrom app.services.user_service import UserService\nfrom app.config import AppConfig\n\n@inject\nasync def main(config: AppConfig, user_service: UserService):\n    if config.debug:\n        print(\"Debug mode enabled\")\n\n    user = await user_service.get_user(1)\n    print(f\"User: {user}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#siguientes-pasos","title":"Siguientes pasos","text":"<p>Ahora que has visto los ejemplos b\u00e1sicos:</p> <ul> <li>Lee Core Concepts para entender la arquitectura</li> <li>Explora las Gu\u00edas de IoC para dependency injection avanzada</li> <li>Revisa las Gu\u00edas de HTTP para cliente HTTP</li> <li>Consulta Ejemplos avanzados para casos reales</li> </ul>"},{"location":"guides/background/basic-usage/","title":"Background Tasks - Uso B\u00e1sico","text":"<p>Gu\u00eda pr\u00e1ctica para ejecutar tareas en background con R5.</p>"},{"location":"guides/background/basic-usage/#setup-inicial","title":"Setup Inicial","text":"<pre><code>from R5.background import Background\nfrom R5.ioc import inject\nimport asyncio\n\n@inject\nasync def my_service(bg: Background):\n    await bg.add(my_task, \"arg1\", \"arg2\")\n    await asyncio.sleep(1)  # Esperar a que terminen\n</code></pre> <p>Background se inyecta autom\u00e1ticamente, no necesitas crear instancias manualmente.</p>"},{"location":"guides/background/basic-usage/#tareas-sincronas","title":"Tareas S\u00edncronas","text":""},{"location":"guides/background/basic-usage/#funcion-simple","title":"Funci\u00f3n Simple","text":"<pre><code>def send_email(to: str):\n    print(f\"Sending email to {to}\")\n    time.sleep(0.1)\n    print(\"Email sent\")\n\n@inject\nasync def queue_email(bg: Background):\n    await bg.add(send_email, \"user@example.com\")\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/basic-usage/#con-multiples-argumentos","title":"Con M\u00faltiples Argumentos","text":"<pre><code>def process_order(order_id: int, user_id: int, amount: float):\n    print(f\"Processing order {order_id} for user {user_id}: ${amount}\")\n    time.sleep(0.2)\n    print(f\"Order {order_id} processed\")\n\n@inject\nasync def queue_orders(bg: Background):\n    await bg.add(process_order, 1, 100, 99.99)\n    await bg.add(process_order, 2, 101, 149.99)\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/basic-usage/#con-keyword-arguments","title":"Con Keyword Arguments","text":"<pre><code>def create_user(username: str, email: str, age: int = 18):\n    print(f\"Creating user: {username} ({email}), age {age}\")\n\n@inject\nasync def queue_user_creation(bg: Background):\n    await bg.add(create_user, \"john\", \"john@example.com\", age=25)\n    await bg.add(create_user, username=\"jane\", email=\"jane@example.com\")\n\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/basic-usage/#tareas-asincronas","title":"Tareas As\u00edncronas","text":""},{"location":"guides/background/basic-usage/#async-function","title":"Async Function","text":"<pre><code>async def async_task(item_id: int):\n    await asyncio.sleep(0.1)\n    print(f\"Processed item {item_id}\")\n\n@inject\nasync def queue_async_tasks(bg: Background):\n    await bg.add(async_task, 1)\n    await bg.add(async_task, 2)\n    await bg.add(async_task, 3)\n\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/basic-usage/#async-con-http","title":"Async con HTTP","text":"<pre><code>from R5.http import Http\n\nasync def fetch_and_process(http: Http, url: str):\n    result = await http.get(url)\n    data = result.to(dict)\n    print(f\"Fetched: {data}\")\n\n@inject\nasync def queue_fetches(bg: Background):\n    await bg.add(fetch_and_process, \"https://api.example.com/data/1\")\n    await bg.add(fetch_and_process, \"https://api.example.com/data/2\")\n\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"guides/background/basic-usage/#async-con-await","title":"Async con Await","text":"<pre><code>async def download_file(url: str, filename: str):\n    print(f\"Downloading {url}...\")\n    await asyncio.sleep(0.5)  # Simula descarga\n    print(f\"Saved to {filename}\")\n\n@inject\nasync def queue_downloads(bg: Background):\n    await bg.add(download_file, \"https://example.com/file1.pdf\", \"file1.pdf\")\n    await bg.add(download_file, \"https://example.com/file2.pdf\", \"file2.pdf\")\n\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"guides/background/basic-usage/#lambdas","title":"Lambdas","text":""},{"location":"guides/background/basic-usage/#lambda-simple","title":"Lambda Simple","text":"<pre><code>@inject\nasync def with_lambda(bg: Background):\n    await bg.add(lambda: print(\"Hello from lambda\"))\n    await bg.add(lambda x: print(f\"Lambda with arg: {x}\"), 42)\n\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/basic-usage/#lambda-capturando-variables","title":"Lambda Capturando Variables","text":"<pre><code>@inject\nasync def with_captured_lambda(bg: Background):\n    user_id = 123\n    message = \"Welcome!\"\n\n    await bg.add(\n        lambda: print(f\"Sending {message} to user {user_id}\")\n    )\n\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/basic-usage/#bucles","title":"Bucles","text":""},{"location":"guides/background/basic-usage/#for-loop","title":"For Loop","text":"<pre><code>@inject\nasync def queue_many(bg: Background):\n    for i in range(10):\n        await bg.add(process_item, i)\n\n    print(\"10 tasks queued\")\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/basic-usage/#list-comprehension","title":"List Comprehension","text":"<pre><code>@inject\nasync def queue_from_list(bg: Background):\n    items = [1, 2, 3, 4, 5]\n\n    for item in items:\n        await bg.add(process_item, item)\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/basic-usage/#batch-processing","title":"Batch Processing","text":"<pre><code>@inject\nasync def batch_process(bg: Background):\n    batch = range(100)\n\n    for item_id in batch:\n        await bg.add(process_item, item_id)\n\n    print(f\"Queued {len(batch)} items\")\n    await asyncio.sleep(5)\n</code></pre>"},{"location":"guides/background/basic-usage/#diferentes-tipos-de-tareas","title":"Diferentes Tipos de Tareas","text":""},{"location":"guides/background/basic-usage/#mezclando-sync-y-async","title":"Mezclando Sync y Async","text":"<pre><code>def sync_task(data: str):\n    print(f\"Sync: {data}\")\n\nasync def async_task(data: str):\n    print(f\"Async: {data}\")\n\n@inject\nasync def mixed_tasks(bg: Background):\n    await bg.add(sync_task, \"task1\")   # Thread pool\n    await bg.add(async_task, \"task2\")  # Event loop\n    await bg.add(sync_task, \"task3\")   # Thread pool\n    await bg.add(async_task, \"task4\")  # Event loop\n\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/basic-usage/#tareas-con-duraciones-diferentes","title":"Tareas con Duraciones Diferentes","text":"<pre><code>def quick_task():\n    time.sleep(0.1)\n    print(\"Quick task done\")\n\ndef slow_task():\n    time.sleep(1.0)\n    print(\"Slow task done\")\n\n@inject\nasync def mixed_duration(bg: Background):\n    await bg.add(quick_task)\n    await bg.add(slow_task)\n    await bg.add(quick_task)\n\n    await asyncio.sleep(2)\n    # quick_task termina primero, slow_task despu\u00e9s\n</code></pre>"},{"location":"guides/background/basic-usage/#esperar-tareas","title":"Esperar Tareas","text":""},{"location":"guides/background/basic-usage/#sleep-explicito","title":"Sleep Expl\u00edcito","text":"<pre><code>@inject\nasync def wait_for_tasks(bg: Background):\n    await bg.add(task1)\n    await bg.add(task2)\n\n    # Esperar a que terminen\n    await asyncio.sleep(2)\n\n    print(\"All tasks completed\")\n</code></pre>"},{"location":"guides/background/basic-usage/#esperar-tiempo-estimado","title":"Esperar Tiempo Estimado","text":"<pre><code>@inject\nasync def wait_estimated(bg: Background):\n    task_count = 100\n    task_duration = 0.1\n\n    for i in range(task_count):\n        await bg.add(process_item, i)\n\n    # Esperar tiempo estimado\n    await asyncio.sleep(task_duration * 2)\n</code></pre>"},{"location":"guides/background/basic-usage/#manejo-de-errores","title":"Manejo de Errores","text":""},{"location":"guides/background/basic-usage/#tarea-que-falla","title":"Tarea que Falla","text":"<pre><code>def failing_task():\n    raise Exception(\"This task fails\")\n\ndef successful_task():\n    print(\"This task succeeds\")\n\n@inject\nasync def with_failing_task(bg: Background):\n    await bg.add(failing_task)\n    await bg.add(successful_task)\n\n    await asyncio.sleep(0.5)\n    # successful_task se ejecuta aunque failing_task falle\n</code></pre>"},{"location":"guides/background/basic-usage/#multiples-fallos","title":"M\u00faltiples Fallos","text":"<pre><code>@inject\nasync def multiple_failures(bg: Background):\n    for i in range(5):\n        if i % 2 == 0:\n            await bg.add(lambda: print(f\"Task {i} success\"))\n        else:\n            await bg.add(lambda: 1/0)  # Falla\n\n    await asyncio.sleep(1)\n    # Tareas exitosas se ejecutan normalmente\n</code></pre>"},{"location":"guides/background/basic-usage/#ejemplos-practicos","title":"Ejemplos Pr\u00e1cticos","text":""},{"location":"guides/background/basic-usage/#envio-de-emails","title":"Env\u00edo de Emails","text":"<pre><code>def send_email(to: str, subject: str, body: str):\n    print(f\"Sending email to {to}\")\n    time.sleep(0.2)\n    print(f\"Email sent: {subject}\")\n\n@inject\nasync def send_welcome_emails(bg: Background):\n    users = [\n        (\"user1@example.com\", \"John\"),\n        (\"user2@example.com\", \"Jane\"),\n        (\"user3@example.com\", \"Bob\")\n    ]\n\n    for email, name in users:\n        await bg.add(\n            send_email,\n            email,\n            \"Welcome!\",\n            f\"Hi {name}, welcome to our platform!\"\n        )\n\n    print(\"All emails queued\")\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/basic-usage/#procesamiento-de-pagos","title":"Procesamiento de Pagos","text":"<pre><code>async def process_payment(payment_id: int, amount: float):\n    print(f\"Processing payment {payment_id}: ${amount}\")\n    await asyncio.sleep(0.5)\n    print(f\"Payment {payment_id} completed\")\n\n@inject\nasync def process_pending_payments(bg: Background):\n    payments = [\n        (1, 99.99),\n        (2, 149.99),\n        (3, 49.99),\n        (4, 199.99)\n    ]\n\n    for payment_id, amount in payments:\n        await bg.add(process_payment, payment_id, amount)\n\n    await asyncio.sleep(3)\n</code></pre>"},{"location":"guides/background/basic-usage/#actualizacion-de-cache","title":"Actualizaci\u00f3n de Cach\u00e9","text":"<pre><code>def update_cache(key: str, value: str):\n    print(f\"Updating cache: {key} = {value}\")\n    time.sleep(0.1)\n    print(f\"Cache updated: {key}\")\n\n@inject\nasync def refresh_cache(bg: Background):\n    cache_items = {\n        \"user:123\": \"John Doe\",\n        \"user:456\": \"Jane Smith\",\n        \"config:app\": \"production\",\n        \"stats:today\": \"1234\"\n    }\n\n    for key, value in cache_items.items():\n        await bg.add(update_cache, key, value)\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/basic-usage/#notificaciones-push","title":"Notificaciones Push","text":"<pre><code>async def send_push_notification(user_id: int, message: str):\n    print(f\"Sending push to user {user_id}: {message}\")\n    await asyncio.sleep(0.2)\n    print(f\"Push sent to user {user_id}\")\n\n@inject\nasync def notify_users(bg: Background):\n    notifications = [\n        (100, \"New message\"),\n        (101, \"Friend request\"),\n        (102, \"Post liked\"),\n        (103, \"Comment on your post\")\n    ]\n\n    for user_id, message in notifications:\n        await bg.add(send_push_notification, user_id, message)\n\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"guides/background/basic-usage/#generacion-de-reportes","title":"Generaci\u00f3n de Reportes","text":"<pre><code>def generate_report(report_type: str, user_id: int):\n    print(f\"Generating {report_type} report for user {user_id}\")\n    time.sleep(1.0)  # Simulaci\u00f3n de proceso pesado\n    print(f\"Report {report_type} generated for user {user_id}\")\n\n@inject\nasync def queue_reports(bg: Background):\n    reports = [\n        (\"sales\", 1),\n        (\"inventory\", 2),\n        (\"analytics\", 3)\n    ]\n\n    for report_type, user_id in reports:\n        await bg.add(generate_report, report_type, user_id)\n\n    print(\"Reports queued\")\n    await asyncio.sleep(5)\n</code></pre>"},{"location":"guides/background/basic-usage/#web-scraping","title":"Web Scraping","text":"<pre><code>from R5.http import Http\n\nasync def scrape_page(http: Http, url: str):\n    print(f\"Scraping {url}\")\n    result = await http.get(url)\n    print(f\"Scraped {url}: {result.status}\")\n\n@inject\nasync def scrape_multiple_pages(bg: Background):\n    urls = [\n        \"https://example.com/page1\",\n        \"https://example.com/page2\",\n        \"https://example.com/page3\"\n    ]\n\n    for url in urls:\n        await bg.add(scrape_page, url)\n\n    await asyncio.sleep(3)\n</code></pre>"},{"location":"guides/background/basic-usage/#patrones-avanzados","title":"Patrones Avanzados","text":""},{"location":"guides/background/basic-usage/#task-priority-manual","title":"Task Priority (Manual)","text":"<pre><code>@inject\nasync def prioritized_tasks(bg: Background):\n    # Alta prioridad primero\n    await bg.add(critical_task)\n    await bg.add(critical_task)\n\n    # Media prioridad\n    await bg.add(normal_task)\n    await bg.add(normal_task)\n\n    # Baja prioridad\n    await bg.add(low_priority_task)\n\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"guides/background/basic-usage/#conditional-queueing","title":"Conditional Queueing","text":"<pre><code>@inject\nasync def conditional_queue(bg: Background):\n    items = range(10)\n\n    for item in items:\n        if item % 2 == 0:\n            await bg.add(even_task, item)\n        else:\n            await bg.add(odd_task, item)\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/basic-usage/#retry-logic-in-task","title":"Retry Logic in Task","text":"<pre><code>def task_with_retry(item_id: int, max_retries: int = 3):\n    for attempt in range(max_retries):\n        try:\n            process_item(item_id)\n            break\n        except Exception as e:\n            if attempt == max_retries - 1:\n                print(f\"Failed after {max_retries} attempts: {e}\")\n            else:\n                time.sleep(2 ** attempt)\n\n@inject\nasync def queue_with_retry(bg: Background):\n    await bg.add(task_with_retry, 1)\n    await asyncio.sleep(5)\n</code></pre>"},{"location":"guides/background/basic-usage/#limitaciones","title":"Limitaciones","text":""},{"location":"guides/background/basic-usage/#no-retorna-valores","title":"No Retorna Valores","text":"<pre><code># \u274c No funciona\nresult = await bg.add(compute_value)\n\n# \u2705 Usa callback o side effects\ndef compute_and_store(results: list):\n    value = compute_value()\n    results.append(value)\n\nresults = []\nawait bg.add(compute_and_store, results)\nawait asyncio.sleep(1)\nprint(results[0])\n</code></pre>"},{"location":"guides/background/basic-usage/#no-garantiza-orden","title":"No Garantiza Orden","text":"<pre><code>@inject\nasync def unordered(bg: Background):\n    await bg.add(task, 1)\n    await bg.add(task, 2)\n    await bg.add(task, 3)\n\n    # Pueden ejecutarse en cualquier orden\n    # Si necesitas orden, usa await directamente\n</code></pre>"},{"location":"guides/background/basic-usage/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Overview - Visi\u00f3n general de Background</li> <li>IoC Integration - Integraci\u00f3n con IoC</li> <li>API Reference - Documentaci\u00f3n completa</li> </ul>"},{"location":"guides/background/ioc-integration/","title":"Background Tasks - Integraci\u00f3n con IoC","text":"<p>Las tareas en Background pueden recibir dependencias inyectadas autom\u00e1ticamente.</p>"},{"location":"guides/background/ioc-integration/#inyeccion-automatica","title":"Inyecci\u00f3n Autom\u00e1tica","text":"<p>Background detecta y resuelve dependencias autom\u00e1ticamente:</p> <pre><code>from R5.ioc import singleton, inject\nfrom R5.background import Background\n\n@singleton\nclass EmailService:\n    def send(self, to: str, subject: str):\n        print(f\"Sending email to {to}: {subject}\")\n\ndef send_welcome_email(email_service: EmailService, user_email: str):\n    # EmailService se inyecta autom\u00e1ticamente\n    email_service.send(user_email, \"Welcome!\")\n\n@inject\nasync def queue_emails(bg: Background):\n    await bg.add(send_welcome_email, user_email=\"user@example.com\")\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/ioc-integration/#tareas-con-multiples-dependencias","title":"Tareas con M\u00faltiples Dependencias","text":"<pre><code>@singleton\nclass Logger:\n    def log(self, msg: str):\n        print(f\"[LOG] {msg}\")\n\n@singleton\nclass Database:\n    def save(self, data: str):\n        print(f\"Saving to DB: {data}\")\n\ndef process_order(\n    logger: Logger,\n    db: Database,\n    order_id: int\n):\n    logger.log(f\"Processing order {order_id}\")\n    db.save(f\"order_{order_id}\")\n    logger.log(f\"Order {order_id} processed\")\n\n@inject\nasync def queue_order_processing(bg: Background):\n    # Logger y Database se inyectan autom\u00e1ticamente\n    await bg.add(process_order, order_id=123)\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/ioc-integration/#async-tasks-con-ioc","title":"Async Tasks con IoC","text":"<pre><code>@singleton\nclass HttpClient:\n    async def fetch(self, url: str):\n        print(f\"Fetching {url}\")\n        return {\"data\": \"example\"}\n\nasync def fetch_and_log(\n    client: HttpClient,\n    logger: Logger,\n    url: str\n):\n    logger.log(f\"Fetching {url}\")\n    data = await client.fetch(url)\n    logger.log(f\"Fetched: {data}\")\n\n@inject\nasync def queue_fetches(bg: Background):\n    await bg.add(fetch_and_log, url=\"https://api.example.com/data\")\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"guides/background/ioc-integration/#mezclando-dependencias-y-parametros","title":"Mezclando Dependencias y Par\u00e1metros","text":"<pre><code>@singleton\nclass ConfigService:\n    def get(self, key: str) -&gt; str:\n        return f\"config_{key}\"\n\ndef process_with_config(\n    config: ConfigService,  # Inyectado\n    item_id: int,           # Par\u00e1metro manual\n    priority: str = \"normal\"  # Par\u00e1metro con default\n):\n    api_key = config.get(\"api_key\")\n    print(f\"Processing item {item_id} with priority {priority}\")\n    print(f\"Using API key: {api_key}\")\n\n@inject\nasync def queue_processing(bg: Background):\n    # Solo pasamos los par\u00e1metros no inyectables\n    await bg.add(process_with_config, item_id=42, priority=\"high\")\n    await bg.add(process_with_config, item_id=43)  # Usa default priority\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/ioc-integration/#service-layer-pattern","title":"Service Layer Pattern","text":"<pre><code>@singleton\nclass UserRepository:\n    def find(self, user_id: int):\n        return {\"id\": user_id, \"name\": \"John\"}\n\n@singleton\nclass EmailService:\n    def send(self, to: str, message: str):\n        print(f\"Email to {to}: {message}\")\n\n@singleton\nclass UserService:\n    def __init__(self, repo: UserRepository, email: EmailService):\n        self.repo = repo\n        self.email = email\n\n    def notify_user(self, user_id: int, message: str):\n        user = self.repo.find(user_id)\n        self.email.send(user[\"email\"], message)\n\ndef background_notification(\n    user_service: UserService,  # Inyectado con sus dependencias\n    user_id: int,\n    message: str\n):\n    user_service.notify_user(user_id, message)\n\n@inject\nasync def queue_notifications(bg: Background):\n    await bg.add(background_notification, user_id=1, message=\"Hello!\")\n    await bg.add(background_notification, user_id=2, message=\"Welcome!\")\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/ioc-integration/#scopes-en-background","title":"Scopes en Background","text":""},{"location":"guides/background/ioc-integration/#singleton","title":"Singleton","text":"<p>Tareas comparten la misma instancia:</p> <pre><code>@singleton\nclass Counter:\n    def __init__(self):\n        self.count = 0\n\n    def increment(self):\n        self.count += 1\n        print(f\"Count: {self.count}\")\n\ndef increment_counter(counter: Counter):\n    counter.increment()\n\n@inject\nasync def test_singleton(bg: Background):\n    for i in range(5):\n        await bg.add(increment_counter)\n\n    await asyncio.sleep(1)\n    # Output: Count: 1, Count: 2, Count: 3, Count: 4, Count: 5\n    # Todas las tareas usan la misma instancia\n</code></pre>"},{"location":"guides/background/ioc-integration/#factory","title":"Factory","text":"<p>Cada tarea recibe una nueva instancia:</p> <pre><code>@factory\nclass RequestContext:\n    def __init__(self):\n        self.id = uuid4()\n        print(f\"Created context {self.id}\")\n\ndef process_with_context(ctx: RequestContext, item_id: int):\n    print(f\"Processing {item_id} with context {ctx.id}\")\n\n@inject\nasync def test_factory(bg: Background):\n    for i in range(3):\n        await bg.add(process_with_context, item_id=i)\n\n    await asyncio.sleep(1)\n    # Cada tarea recibe un nuevo RequestContext\n</code></pre>"},{"location":"guides/background/ioc-integration/#configuration-en-background","title":"Configuration en Background","text":"<pre><code>@config(file='.env')\nclass AppConfig:\n    api_key: str = \"\"\n    max_retries: int = 3\n\ndef api_call_with_config(\n    config: AppConfig,\n    endpoint: str\n):\n    print(f\"Calling {endpoint} with key {config.api_key}\")\n    print(f\"Max retries: {config.max_retries}\")\n\n@inject\nasync def queue_api_calls(bg: Background):\n    await bg.add(api_call_with_config, endpoint=\"/users\")\n    await bg.add(api_call_with_config, endpoint=\"/posts\")\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/ioc-integration/#http-client-en-background","title":"Http Client en Background","text":"<pre><code>from R5.http import Http\n\nasync def fetch_and_process(\n    http: Http,  # Inyectado\n    logger: Logger,  # Inyectado\n    url: str  # Par\u00e1metro\n):\n    logger.log(f\"Fetching {url}\")\n    result = await http.get(url)\n\n    if result.status == 200:\n        data = result.to(dict)\n        logger.log(f\"Success: {data}\")\n    else:\n        logger.log(f\"Failed: {result.status}\")\n\n@inject\nasync def queue_http_tasks(bg: Background):\n    urls = [\n        \"https://api.example.com/users/1\",\n        \"https://api.example.com/users/2\",\n        \"https://api.example.com/users/3\"\n    ]\n\n    for url in urls:\n        await bg.add(fetch_and_process, url=url)\n\n    await asyncio.sleep(3)\n</code></pre>"},{"location":"guides/background/ioc-integration/#nested-background-en-background","title":"Nested Background en Background","text":"<pre><code>@inject\nasync def nested_task(bg: Background, item_id: int):\n    # Una tarea puede encolar m\u00e1s tareas\n    await bg.add(lambda: print(f\"Sub-task for item {item_id}\"))\n\n@inject\nasync def parent_task(bg: Background):\n    for i in range(3):\n        await bg.add(nested_task, item_id=i)\n\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"guides/background/ioc-integration/#cache-de-dependencias","title":"Cach\u00e9 de Dependencias","text":"<p>Background cachea las dependencias resueltas para mejor rendimiento:</p> <pre><code>@singleton\nclass HeavyService:\n    def __init__(self):\n        print(\"Initializing HeavyService (expensive)\")\n        time.sleep(1)\n\n    def process(self, item: int):\n        print(f\"Processing {item}\")\n\ndef task_with_heavy_service(service: HeavyService, item: int):\n    service.process(item)\n\n@inject\nasync def test_cache(bg: Background):\n    # HeavyService se crea solo una vez\n    for i in range(10):\n        await bg.add(task_with_heavy_service, item=i)\n\n    await asyncio.sleep(3)\n    # Output: \"Initializing HeavyService\" solo una vez\n</code></pre>"},{"location":"guides/background/ioc-integration/#ejemplo-completo-worker-queue","title":"Ejemplo Completo: Worker Queue","text":"<pre><code>@config(file='.env')\nclass WorkerConfig:\n    worker_count: int = 4\n    retry_attempts: int = 3\n\n@singleton\nclass JobRepository:\n    def get_pending_jobs(self):\n        return [\n            {\"id\": 1, \"type\": \"email\", \"data\": \"user1@example.com\"},\n            {\"id\": 2, \"type\": \"sms\", \"data\": \"+1234567890\"},\n            {\"id\": 3, \"type\": \"push\", \"data\": \"device_token_123\"}\n        ]\n\n    def mark_completed(self, job_id: int):\n        print(f\"Job {job_id} marked as completed\")\n\n@singleton\nclass NotificationService:\n    def send_email(self, email: str):\n        print(f\"Sending email to {email}\")\n\n    def send_sms(self, phone: str):\n        print(f\"Sending SMS to {phone}\")\n\n    def send_push(self, token: str):\n        print(f\"Sending push to {token}\")\n\ndef process_job(\n    repo: JobRepository,\n    notifications: NotificationService,\n    logger: Logger,\n    job: dict\n):\n    logger.log(f\"Processing job {job['id']}\")\n\n    try:\n        if job[\"type\"] == \"email\":\n            notifications.send_email(job[\"data\"])\n        elif job[\"type\"] == \"sms\":\n            notifications.send_sms(job[\"data\"])\n        elif job[\"type\"] == \"push\":\n            notifications.send_push(job[\"data\"])\n\n        repo.mark_completed(job[\"id\"])\n        logger.log(f\"Job {job['id']} completed\")\n    except Exception as e:\n        logger.log(f\"Job {job['id']} failed: {e}\")\n\n@inject\nasync def worker_queue(\n    bg: Background,\n    repo: JobRepository,\n    logger: Logger\n):\n    logger.log(\"Starting worker queue\")\n\n    jobs = repo.get_pending_jobs()\n\n    for job in jobs:\n        await bg.add(process_job, job=job)\n\n    logger.log(f\"Queued {len(jobs)} jobs\")\n    await asyncio.sleep(2)\n    logger.log(\"Worker queue finished\")\n\nif __name__ == \"__main__\":\n    asyncio.run(worker_queue())\n</code></pre>"},{"location":"guides/background/ioc-integration/#testing-con-ioc","title":"Testing con IoC","text":"<pre><code>def test_background_with_mocks():\n    Container.reset()\n\n    # Mock services\n    @singleton\n    class MockLogger:\n        def __init__(self):\n            self.logs = []\n\n        def log(self, msg: str):\n            self.logs.append(msg)\n\n    def task_with_logger(logger: MockLogger, message: str):\n        logger.log(message)\n\n    async def test():\n        bg = Container.resolve(Background)\n        logger = Container.resolve(MockLogger)\n\n        async with bg:\n            await bg.add(task_with_logger, message=\"test1\")\n            await bg.add(task_with_logger, message=\"test2\")\n            await asyncio.sleep(0.5)\n\n        assert \"test1\" in logger.logs\n        assert \"test2\" in logger.logs\n\n    asyncio.run(test())\n</code></pre>"},{"location":"guides/background/ioc-integration/#patrones-avanzados","title":"Patrones Avanzados","text":""},{"location":"guides/background/ioc-integration/#event-driven-architecture","title":"Event-Driven Architecture","text":"<pre><code>@singleton\nclass EventBus:\n    def __init__(self):\n        self.handlers = {}\n\n    def subscribe(self, event_type: str, handler):\n        if event_type not in self.handlers:\n            self.handlers[event_type] = []\n        self.handlers[event_type].append(handler)\n\n    async def publish(self, bg: Background, event_type: str, data: dict):\n        if event_type in self.handlers:\n            for handler in self.handlers[event_type]:\n                await bg.add(handler, data=data)\n\ndef on_user_registered(logger: Logger, data: dict):\n    logger.log(f\"User registered: {data['email']}\")\n\ndef on_user_registered_send_email(email_service: EmailService, data: dict):\n    email_service.send(data[\"email\"], \"Welcome!\")\n\n@inject\nasync def setup_events(event_bus: EventBus):\n    event_bus.subscribe(\"user.registered\", on_user_registered)\n    event_bus.subscribe(\"user.registered\", on_user_registered_send_email)\n\n@inject\nasync def trigger_event(bg: Background, event_bus: EventBus):\n    await event_bus.publish(\n        bg,\n        \"user.registered\",\n        {\"email\": \"user@example.com\"}\n    )\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/ioc-integration/#command-pattern","title":"Command Pattern","text":"<pre><code>@singleton\nclass CommandExecutor:\n    async def execute(self, bg: Background, command):\n        await bg.add(command.execute)\n\nclass SendEmailCommand:\n    def __init__(self, to: str, subject: str):\n        self.to = to\n        self.subject = subject\n\n    def execute(self, email_service: EmailService):\n        email_service.send(self.to, self.subject)\n\n@inject\nasync def execute_commands(bg: Background, executor: CommandExecutor):\n    cmd1 = SendEmailCommand(\"user1@example.com\", \"Hello\")\n    cmd2 = SendEmailCommand(\"user2@example.com\", \"Welcome\")\n\n    await executor.execute(bg, cmd1)\n    await executor.execute(bg, cmd2)\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/ioc-integration/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Overview - Visi\u00f3n general de Background</li> <li>Basic Usage - Uso b\u00e1sico</li> <li>API Reference - Documentaci\u00f3n completa</li> </ul>"},{"location":"guides/background/overview/","title":"Background Tasks - Overview","text":"<p>El m\u00f3dulo Background de R5 permite ejecutar tareas en paralelo de forma simple y eficiente usando anyio.</p>"},{"location":"guides/background/overview/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>\u2705 Ejecuci\u00f3n Concurrente - Tareas en paralelo con anyio</li> <li>\u2705 Inyecci\u00f3n IoC - Tareas pueden recibir dependencias</li> <li>\u2705 Sync y Async - Soporta ambos tipos de funciones</li> <li>\u2705 Thread Pool - Tareas sync ejecutan en thread pool</li> <li>\u2705 Error Handling - Errores no detienen otras tareas</li> <li>\u2705 Lifecycle Management - Cleanup autom\u00e1tico</li> <li>\u2705 Resource Pattern - Context manager integrado</li> </ul>"},{"location":"guides/background/overview/#arquitectura","title":"Arquitectura","text":"<pre><code>graph TB\n    A[Background] --&gt; B[TaskGroup]\n    A --&gt; C[Thread Pool]\n    A --&gt; D[IoC Integration]\n\n    B --&gt; E[Async Tasks]\n    C --&gt; F[Sync Tasks]\n    D --&gt; G[Dependency Injection]\n\n    E --&gt; H[Concurrent Execution]\n    F --&gt; H\n    G --&gt; H</code></pre>"},{"location":"guides/background/overview/#componentes","title":"Componentes","text":""},{"location":"guides/background/overview/#background","title":"Background","text":"<p>Clase principal que gestiona tareas:</p> <pre><code>from R5.background import Background\nfrom R5.ioc import inject\n\n@inject\nasync def my_service(bg: Background):\n    await bg.add(task1)\n    await bg.add(task2)\n    await asyncio.sleep(1)  # Esperar tareas\n</code></pre>"},{"location":"guides/background/overview/#taskgroup","title":"TaskGroup","text":"<p>anyio TaskGroup para ejecuci\u00f3n concurrente (interno):</p> <pre><code># Manejado autom\u00e1ticamente por Background\ntask_group = create_task_group()\ntask_group.start_soon(task)\n</code></pre>"},{"location":"guides/background/overview/#thread-pool","title":"Thread Pool","text":"<p>Pool de threads para tareas s\u00edncronas:</p> <pre><code># Configuraci\u00f3n del pool\n@resource\nclass Background:\n    def __init__(self, max_workers: int = 40):\n        self._max_workers = max_workers\n</code></pre>"},{"location":"guides/background/overview/#flujo-de-ejecucion","title":"Flujo de Ejecuci\u00f3n","text":"<pre><code>sequenceDiagram\n    participant App\n    participant Background\n    participant TaskGroup\n    participant Worker\n\n    App-&gt;&gt;Background: await bg.add(task)\n    Background-&gt;&gt;Background: Check if sync/async\n    Background-&gt;&gt;Background: Inject dependencies\n\n    alt Async Task\n        Background-&gt;&gt;TaskGroup: start_soon(async_task)\n        TaskGroup-&gt;&gt;Worker: Execute async\n    else Sync Task\n        Background-&gt;&gt;TaskGroup: start_soon(to_thread)\n        TaskGroup-&gt;&gt;Worker: Execute in thread\n    end\n\n    Worker-&gt;&gt;Worker: Run task\n    Worker--&gt;&gt;App: Task completes in background</code></pre>"},{"location":"guides/background/overview/#uso-basico","title":"Uso B\u00e1sico","text":""},{"location":"guides/background/overview/#tarea-simple","title":"Tarea Simple","text":"<pre><code>import asyncio\nfrom R5.background import Background\nfrom R5.ioc import inject\n\ndef process_data(data: str):\n    print(f\"Processing: {data}\")\n\n@inject\nasync def main(bg: Background):\n    await bg.add(process_data, \"item1\")\n    await bg.add(process_data, \"item2\")\n\n    await asyncio.sleep(0.5)\n    print(\"All tasks queued\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"guides/background/overview/#tarea-async","title":"Tarea Async","text":"<pre><code>async def async_task(item_id: int):\n    await asyncio.sleep(0.1)\n    print(f\"Processed item {item_id}\")\n\n@inject\nasync def main(bg: Background):\n    await bg.add(async_task, 1)\n    await bg.add(async_task, 2)\n\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/overview/#multiples-tareas","title":"M\u00faltiples Tareas","text":"<pre><code>@inject\nasync def queue_many_tasks(bg: Background):\n    for i in range(100):\n        await bg.add(process_item, i)\n\n    await asyncio.sleep(2)\n    print(\"All 100 tasks completed\")\n</code></pre>"},{"location":"guides/background/overview/#inyeccion-ioc-en-tareas","title":"Inyecci\u00f3n IoC en Tareas","text":"<p>Las tareas pueden recibir dependencias inyectadas:</p> <pre><code>@singleton\nclass Logger:\n    def log(self, msg: str):\n        print(f\"[LOG] {msg}\")\n\ndef background_task(logger: Logger, item_id: int):\n    logger.log(f\"Processing item {item_id}\")\n\n@inject\nasync def main(bg: Background):\n    # Logger se inyecta autom\u00e1ticamente\n    await bg.add(background_task, item_id=42)\n\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/overview/#tareas-sync-vs-async","title":"Tareas Sync vs Async","text":""},{"location":"guides/background/overview/#sync-task","title":"Sync Task","text":"<pre><code>def sync_task(data: str):\n    # Ejecuta en thread pool\n    time.sleep(0.1)\n    print(f\"Sync: {data}\")\n\n@inject\nasync def with_sync(bg: Background):\n    await bg.add(sync_task, \"data1\")\n</code></pre>"},{"location":"guides/background/overview/#async-task","title":"Async Task","text":"<pre><code>async def async_task(data: str):\n    # Ejecuta en event loop\n    await asyncio.sleep(0.1)\n    print(f\"Async: {data}\")\n\n@inject\nasync def with_async(bg: Background):\n    await bg.add(async_task, \"data1\")\n</code></pre>"},{"location":"guides/background/overview/#deteccion-automatica","title":"Detecci\u00f3n Autom\u00e1tica","text":"<p>Background detecta autom\u00e1ticamente si la tarea es sync o async:</p> <pre><code>@inject\nasync def mixed_tasks(bg: Background):\n    await bg.add(sync_task, \"sync\")    # Thread pool\n    await bg.add(async_task, \"async\")  # Event loop\n</code></pre>"},{"location":"guides/background/overview/#error-handling","title":"Error Handling","text":"<p>Los errores en tareas no detienen otras tareas:</p> <pre><code>def failing_task():\n    raise Exception(\"Task failed\")\n\ndef successful_task():\n    print(\"This still runs\")\n\n@inject\nasync def with_errors(bg: Background):\n    await bg.add(failing_task)      # Falla\n    await bg.add(successful_task)   # Se ejecuta igual\n\n    await asyncio.sleep(0.5)\n    # Ambas tareas se ejecutaron\n</code></pre> <p>Los errores se loguean autom\u00e1ticamente:</p> <pre><code>WARNING - Error in background sync task failing_task: Task failed\n</code></pre>"},{"location":"guides/background/overview/#lifecycle-management","title":"Lifecycle Management","text":"<p>Background usa context manager para cleanup:</p> <pre><code>@inject\nasync def with_lifecycle(bg: Background):\n    await bg.add(task1)\n    await bg.add(task2)\n\n    await asyncio.sleep(1)\n    # Al salir de la funci\u00f3n, Background espera a que terminen las tareas\n</code></pre> <p>Manual lifecycle:</p> <pre><code>async def manual_lifecycle():\n    bg = Container.resolve(Background)\n\n    async with bg:\n        await bg.add(task1)\n        await bg.add(task2)\n        await asyncio.sleep(1)\n    # Cleanup autom\u00e1tico\n</code></pre>"},{"location":"guides/background/overview/#configuracion","title":"Configuraci\u00f3n","text":""},{"location":"guides/background/overview/#max-workers","title":"Max Workers","text":"<pre><code>@resource\nclass Background:\n    def __init__(self, max_workers: int = 40):\n        # Configura el thread pool\n        pass\n</code></pre> <p>Para cambiar:</p> <pre><code>Container.reset()\n\n@resource\nclass CustomBackground(Background):\n    def __init__(self):\n        super().__init__(max_workers=100)\n\nContainer.registry_provider(CustomBackground, Scope.RESOURCE)\nContainer.alias_provider(Background, CustomBackground)\n</code></pre>"},{"location":"guides/background/overview/#patrones-comunes","title":"Patrones Comunes","text":""},{"location":"guides/background/overview/#task-queue","title":"Task Queue","text":"<pre><code>@inject\nasync def task_queue(bg: Background):\n    tasks = [\n        (\"send_email\", \"user1@example.com\"),\n        (\"send_email\", \"user2@example.com\"),\n        (\"process_payment\", 123),\n        (\"update_cache\", \"cache_key\")\n    ]\n\n    for task_name, arg in tasks:\n        if task_name == \"send_email\":\n            await bg.add(send_email, arg)\n        elif task_name == \"process_payment\":\n            await bg.add(process_payment, arg)\n        elif task_name == \"update_cache\":\n            await bg.add(update_cache, arg)\n\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"guides/background/overview/#batch-processing","title":"Batch Processing","text":"<pre><code>@inject\nasync def batch_process(bg: Background):\n    items = range(1000)\n\n    for item in items:\n        await bg.add(process_item, item)\n\n    print(\"All items queued\")\n    await asyncio.sleep(5)\n    print(\"Processing completed\")\n</code></pre>"},{"location":"guides/background/overview/#fire-and-forget","title":"Fire and Forget","text":"<pre><code>@inject\nasync def fire_and_forget(bg: Background):\n    # Queue task y contin\u00faa inmediatamente\n    await bg.add(long_running_task)\n\n    # No espera a que termine\n    return \"Task queued\"\n</code></pre>"},{"location":"guides/background/overview/#ventajas","title":"Ventajas","text":""},{"location":"guides/background/overview/#vs-threading-manual","title":"vs Threading Manual","text":"<pre><code># Threading manual\nimport threading\n\ndef manual_threading():\n    threads = []\n    for i in range(10):\n        t = threading.Thread(target=task, args=(i,))\n        t.start()\n        threads.append(t)\n\n    for t in threads:\n        t.join()\n\n# R5 Background\n@inject\nasync def with_background(bg: Background):\n    for i in range(10):\n        await bg.add(task, i)\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/overview/#vs-asynciocreate_task","title":"vs asyncio.create_task","text":"<pre><code># asyncio.create_task\nasync def with_create_task():\n    tasks = []\n    for i in range(10):\n        task = asyncio.create_task(async_task(i))\n        tasks.append(task)\n\n    await asyncio.gather(*tasks)\n\n# R5 Background\n@inject\nasync def with_background(bg: Background):\n    for i in range(10):\n        await bg.add(async_task, i)\n\n    await asyncio.sleep(1)\n</code></pre> <p>Beneficios de Background: - \u2705 Inyecci\u00f3n IoC autom\u00e1tica - \u2705 Maneja sync y async - \u2705 Error handling integrado - \u2705 Thread pool autom\u00e1tico - \u2705 Lifecycle management - \u2705 M\u00e1s simple</p>"},{"location":"guides/background/overview/#limitaciones","title":"Limitaciones","text":""},{"location":"guides/background/overview/#no-retorna-valores","title":"No retorna valores","text":"<p>Background no retorna valores de las tareas:</p> <pre><code># \u274c No funciona\nresult = await bg.add(compute_value)\n\n# \u2705 Usar callback\ndef compute_and_save(logger: Logger):\n    result = compute_value()\n    logger.log(f\"Result: {result}\")\n\nawait bg.add(compute_and_save)\n</code></pre>"},{"location":"guides/background/overview/#no-garantiza-orden","title":"No garantiza orden","text":"<p>Las tareas se ejecutan concurrentemente, sin orden garantizado:</p> <pre><code>@inject\nasync def unordered(bg: Background):\n    await bg.add(task, 1)\n    await bg.add(task, 2)\n    await bg.add(task, 3)\n\n    # Pueden ejecutarse en cualquier orden\n</code></pre>"},{"location":"guides/background/overview/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Basic Usage - Uso b\u00e1sico de Background</li> <li>IoC Integration - Integraci\u00f3n con IoC</li> <li>API Reference - Documentaci\u00f3n completa</li> </ul>"},{"location":"guides/http/advanced/","title":"HTTP Client - Caracter\u00edsticas Avanzadas","text":"<p>Funcionalidades avanzadas del cliente HTTP para casos de uso complejos.</p>"},{"location":"guides/http/advanced/#retry-automatico","title":"Retry Autom\u00e1tico","text":""},{"location":"guides/http/advanced/#retry-basico","title":"Retry B\u00e1sico","text":"<pre><code>@inject\nasync def fetch_with_retry(http: Http):\n    result = await http.retry(\n        attempts=3,\n        delay=1.0,\n        backoff=2.0\n    ).get(\"https://api.example.com/data\")\n\n    return result\n</code></pre> <p>Comportamiento: - Intento 1: inmediato - Intento 2: espera 1.0s - Intento 3: espera 2.0s (1.0 * 2.0) - Intento 4: espera 4.0s (2.0 * 2.0)</p>"},{"location":"guides/http/advanced/#retry-en-status-codes-especificos","title":"Retry en Status Codes Espec\u00edficos","text":"<pre><code>@inject\nasync def retry_on_status(http: Http):\n    result = await http.retry(\n        attempts=5,\n        delay=0.5,\n        when_status=(429, 500, 502, 503, 504)\n    ).get(\"https://api.example.com/data\")\n\n    # Solo reintenta si el status est\u00e1 en la tupla\n    return result\n</code></pre> <p>Casos de uso: - <code>429</code> - Rate limiting - <code>500</code> - Internal server error - <code>502</code> - Bad gateway - <code>503</code> - Service unavailable - <code>504</code> - Gateway timeout</p>"},{"location":"guides/http/advanced/#retry-en-excepciones","title":"Retry en Excepciones","text":"<pre><code>import httpx\n\n@inject\nasync def retry_on_exception(http: Http):\n    result = await http.retry(\n        attempts=3,\n        delay=1.0,\n        when_exception=(\n            httpx.TimeoutException,\n            httpx.NetworkError,\n            httpx.ConnectError\n        )\n    ).get(\"https://api.example.com/data\")\n\n    return result\n</code></pre>"},{"location":"guides/http/advanced/#retry-con-backoff-exponencial","title":"Retry con Backoff Exponencial","text":"<pre><code>@inject\nasync def exponential_backoff(http: Http):\n    result = await http.retry(\n        attempts=5,\n        delay=1.0,\n        backoff=2.0  # Duplica el delay en cada intento\n    ).get(\"https://api.example.com/data\")\n\n    # Delays: 1.0s, 2.0s, 4.0s, 8.0s, 16.0s\n    return result\n</code></pre>"},{"location":"guides/http/advanced/#retry-combinado","title":"Retry Combinado","text":"<pre><code>@inject\nasync def combined_retry(http: Http):\n    result = await http.retry(\n        attempts=5,\n        delay=0.5,\n        backoff=1.5,\n        when_status=(429, 503),\n        when_exception=(httpx.TimeoutException,)\n    ).get(\"https://api.example.com/data\")\n\n    # Reintenta en status 429/503 O TimeoutException\n    return result\n</code></pre>"},{"location":"guides/http/advanced/#handlers-globales","title":"Handlers Globales","text":""},{"location":"guides/http/advanced/#before-handler-global","title":"Before Handler Global","text":"<p>Se ejecuta antes de TODAS las requests:</p> <pre><code>@inject\nasync def setup_logging(http: Http):\n    def log_request(request):\n        print(f\"\u2192 {request.method} {request.url}\")\n        print(f\"  Headers: {dict(request.headers)}\")\n\n    http.on_before(log_request)\n\n    # Todas las requests logean autom\u00e1ticamente\n    await http.get(\"https://api.example.com/users/1\")\n    await http.post(\"https://api.example.com/users\", json={})\n</code></pre>"},{"location":"guides/http/advanced/#after-handler-global","title":"After Handler Global","text":"<p>Se ejecuta despu\u00e9s de TODAS las requests exitosas:</p> <pre><code>@inject\nasync def setup_response_logging(http: Http):\n    def log_response(request, response):\n        print(f\"\u2190 {response.status_code}\")\n        print(f\"  Time: {response.elapsed.total_seconds()}s\")\n\n    http.on_after(log_response)\n\n    await http.get(\"https://api.example.com/users/1\")\n</code></pre>"},{"location":"guides/http/advanced/#multiples-handlers","title":"M\u00faltiples Handlers","text":"<pre><code>@inject\nasync def multiple_handlers(http: Http):\n    # Handler 1: Logging\n    http.on_before(lambda req: print(f\"\u2192 {req.url}\"))\n\n    # Handler 2: M\u00e9tricas\n    http.on_before(lambda req: metrics.record_request(req))\n\n    # Handler 3: Autenticaci\u00f3n\n    def add_auth(request):\n        request.headers[\"Authorization\"] = f\"Bearer {get_token()}\"\n\n    http.on_before(add_auth)\n\n    # Todos los handlers se ejecutan en orden\n    await http.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"guides/http/advanced/#handlers-con-estado","title":"Handlers con Estado","text":"<pre><code>@inject\nasync def stateful_handlers(http: Http):\n    request_count = {\"count\": 0}\n\n    def count_requests(request):\n        request_count[\"count\"] += 1\n        print(f\"Request #{request_count['count']}\")\n\n    http.on_before(count_requests)\n\n    await http.get(\"https://api.example.com/1\")  # Request #1\n    await http.get(\"https://api.example.com/2\")  # Request #2\n    await http.get(\"https://api.example.com/3\")  # Request #3\n</code></pre>"},{"location":"guides/http/advanced/#configuracion-avanzada","title":"Configuraci\u00f3n Avanzada","text":""},{"location":"guides/http/advanced/#httpconfig-personalizada","title":"HttpConfig Personalizada","text":"<pre><code>from R5.ioc import config\nfrom R5.http.http import HttpConfig\n\n@config(file='.env')\nclass ProductionHttpConfig(HttpConfig):\n    # Connection Pool\n    max_connections: int = 200\n    max_keepalive_connections: int = 50\n    keepalive_expiry: float = 10.0\n\n    # Timeouts\n    connect_timeout: float = 10.0\n    read_timeout: float = 60.0\n    write_timeout: float = 60.0\n    pool_timeout: float = 10.0\n\n    # Retry\n    max_retries: int = 5\n    retry_backoff_factor: float = 1.5\n    retry_statuses: list[int] = [429, 500, 502, 503, 504]\n\n    # Headers\n    default_headers: dict[str, str] = {\n        \"User-Agent\": \"MyApp/1.0\",\n        \"Accept\": \"application/json\"\n    }\n\n    # Redirects\n    follow_redirects: bool = True\n</code></pre>"},{"location":"guides/http/advanced/#proxy-configuration","title":"Proxy Configuration","text":"<pre><code>@config(file='.env')\nclass ProxyHttpConfig(HttpConfig):\n    proxies: list[str] = [\n        \"http://proxy1:8080\",\n        \"http://proxy2:8080\",\n        \"http://proxy3:8080\"\n    ]\n    proxy_rotation: bool = True\n</code></pre> <p>El cliente rotar\u00e1 autom\u00e1ticamente entre los proxies en cada request.</p>"},{"location":"guides/http/advanced/#custom-user-agent","title":"Custom User-Agent","text":"<pre><code>@config\nclass CustomHttpConfig(HttpConfig):\n    user_agent: str = \"MyBot/2.0 (+https://mybot.com)\"\n</code></pre>"},{"location":"guides/http/advanced/#proxy-rotation","title":"Proxy Rotation","text":""},{"location":"guides/http/advanced/#configuracion","title":"Configuraci\u00f3n","text":"<pre><code>@config(file='.env')\nclass ProxyConfig(HttpConfig):\n    proxies: list[str] = [\n        \"http://proxy1.example.com:8080\",\n        \"http://proxy2.example.com:8080\",\n        \"http://proxy3.example.com:8080\"\n    ]\n    proxy_rotation: bool = True\n</code></pre> <p>Archivo .env: <pre><code>PROXIES=http://proxy1:8080,http://proxy2:8080,http://proxy3:8080\nPROXY_ROTATION=true\n</code></pre></p>"},{"location":"guides/http/advanced/#uso","title":"Uso","text":"<pre><code>@inject\nasync def with_proxy_rotation(http: Http):\n    # Request 1 usa proxy1\n    result1 = await http.get(\"https://api.example.com/data\")\n\n    # Request 2 usa proxy2\n    result2 = await http.get(\"https://api.example.com/data\")\n\n    # Request 3 usa proxy3\n    result3 = await http.get(\"https://api.example.com/data\")\n\n    # Request 4 vuelve a proxy1 (round-robin)\n    result4 = await http.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"guides/http/advanced/#metricas-y-monitoring","title":"M\u00e9tricas y Monitoring","text":""},{"location":"guides/http/advanced/#tracking-de-requests","title":"Tracking de Requests","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Dict\nimport time\n\n@dataclass\nclass RequestMetrics:\n    total_requests: int = 0\n    successful_requests: int = 0\n    failed_requests: int = 0\n    total_time: float = 0.0\n\n    def avg_time(self) -&gt; float:\n        if self.total_requests == 0:\n            return 0.0\n        return self.total_time / self.total_requests\n\n@inject\nasync def track_metrics(http: Http):\n    metrics = RequestMetrics()\n\n    def before_handler(request):\n        request._start_time = time.time()\n\n    def after_handler(request, response):\n        elapsed = time.time() - request._start_time\n        metrics.total_requests += 1\n        metrics.total_time += elapsed\n\n        if 200 &lt;= response.status_code &lt; 300:\n            metrics.successful_requests += 1\n        else:\n            metrics.failed_requests += 1\n\n        print(f\"Request took {elapsed:.3f}s\")\n\n    http.on_before(before_handler)\n    http.on_after(after_handler)\n\n    # Hacer requests\n    for i in range(10):\n        await http.get(f\"https://api.example.com/items/{i}\")\n\n    print(f\"Total: {metrics.total_requests}\")\n    print(f\"Success: {metrics.successful_requests}\")\n    print(f\"Failed: {metrics.failed_requests}\")\n    print(f\"Avg Time: {metrics.avg_time():.3f}s\")\n</code></pre>"},{"location":"guides/http/advanced/#logging-detallado","title":"Logging Detallado","text":"<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\n@inject\nasync def detailed_logging(http: Http):\n    def log_before(request):\n        logger.info(f\"\u2192 {request.method} {request.url}\")\n        logger.debug(f\"  Headers: {dict(request.headers)}\")\n\n    def log_after(request, response):\n        logger.info(f\"\u2190 {response.status_code}\")\n        logger.debug(f\"  Response headers: {dict(response.headers)}\")\n        logger.debug(f\"  Content length: {len(response.content)}\")\n\n    http.on_before(log_before)\n    http.on_after(log_after)\n\n    await http.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"guides/http/advanced/#rate-limiting","title":"Rate Limiting","text":""},{"location":"guides/http/advanced/#manual-rate-limiting","title":"Manual Rate Limiting","text":"<pre><code>import asyncio\nfrom asyncio import Semaphore\n\n@inject\nasync def rate_limited_requests(http: Http):\n    # M\u00e1ximo 5 requests concurrentes\n    semaphore = Semaphore(5)\n\n    async def limited_get(url: str):\n        async with semaphore:\n            result = await http.get(url)\n            await asyncio.sleep(0.2)  # 200ms entre requests\n            return result\n\n    tasks = [\n        limited_get(f\"https://api.example.com/items/{i}\")\n        for i in range(100)\n    ]\n\n    results = await asyncio.gather(*tasks)\n    return results\n</code></pre>"},{"location":"guides/http/advanced/#token-bucket-rate-limiter","title":"Token Bucket Rate Limiter","text":"<pre><code>import time\nfrom asyncio import Lock\n\nclass TokenBucket:\n    def __init__(self, rate: float, capacity: int):\n        self.rate = rate\n        self.capacity = capacity\n        self.tokens = capacity\n        self.last_update = time.time()\n        self.lock = Lock()\n\n    async def acquire(self):\n        async with self.lock:\n            now = time.time()\n            elapsed = now - self.last_update\n            self.tokens = min(\n                self.capacity,\n                self.tokens + elapsed * self.rate\n            )\n            self.last_update = now\n\n            if self.tokens &lt; 1:\n                wait_time = (1 - self.tokens) / self.rate\n                await asyncio.sleep(wait_time)\n                self.tokens = 0\n            else:\n                self.tokens -= 1\n\n@inject\nasync def with_token_bucket(http: Http):\n    # 10 requests por segundo, burst de 20\n    limiter = TokenBucket(rate=10, capacity=20)\n\n    for i in range(100):\n        await limiter.acquire()\n        result = await http.get(f\"https://api.example.com/items/{i}\")\n</code></pre>"},{"location":"guides/http/advanced/#circuit-breaker","title":"Circuit Breaker","text":""},{"location":"guides/http/advanced/#implementacion-basica","title":"Implementaci\u00f3n B\u00e1sica","text":"<pre><code>from enum import Enum\nimport time\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"\n    OPEN = \"open\"\n    HALF_OPEN = \"half_open\"\n\nclass CircuitBreaker:\n    def __init__(self, failure_threshold: int = 5, timeout: float = 60.0):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n        self.last_failure_time = None\n\n    def record_success(self):\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n\n    def record_failure(self):\n        self.failures += 1\n        self.last_failure_time = time.time()\n\n        if self.failures &gt;= self.failure_threshold:\n            self.state = CircuitState.OPEN\n\n    def can_attempt(self) -&gt; bool:\n        if self.state == CircuitState.CLOSED:\n            return True\n\n        if self.state == CircuitState.OPEN:\n            if time.time() - self.last_failure_time &gt;= self.timeout:\n                self.state = CircuitState.HALF_OPEN\n                return True\n            return False\n\n        return True  # HALF_OPEN\n\n@inject\nasync def with_circuit_breaker(http: Http):\n    breaker = CircuitBreaker(failure_threshold=3, timeout=30.0)\n\n    async def protected_request(url: str):\n        if not breaker.can_attempt():\n            print(\"Circuit breaker OPEN, skipping request\")\n            return None\n\n        result = await http.get(url)\n\n        if result.status == 200:\n            breaker.record_success()\n        else:\n            breaker.record_failure()\n\n        return result\n\n    for i in range(10):\n        result = await protected_request(\"https://api.example.com/data\")\n        await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/http/advanced/#autenticacion-avanzada","title":"Autenticaci\u00f3n Avanzada","text":""},{"location":"guides/http/advanced/#oauth-20","title":"OAuth 2.0","text":"<pre><code>@singleton\nclass OAuth2Manager:\n    def __init__(self):\n        self.access_token = None\n        self.refresh_token = None\n        self.expires_at = 0\n\n    async def get_access_token(self, http: Http) -&gt; str:\n        if time.time() &lt; self.expires_at:\n            return self.access_token\n\n        # Refresh token\n        result = await http.post(\n            \"https://auth.example.com/oauth/token\",\n            json={\n                \"grant_type\": \"refresh_token\",\n                \"refresh_token\": self.refresh_token,\n                \"client_id\": \"your-client-id\"\n            }\n        )\n\n        data = result.to(dict)\n        self.access_token = data[\"access_token\"]\n        self.expires_at = time.time() + data[\"expires_in\"]\n\n        return self.access_token\n\n@inject\nasync def authenticated_requests(http: Http, oauth: OAuth2Manager):\n    token = await oauth.get_access_token(http)\n\n    result = await http.get(\n        \"https://api.example.com/protected\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n\n    return result\n</code></pre>"},{"location":"guides/http/advanced/#jwt-auto-refresh","title":"JWT Auto-Refresh","text":"<pre><code>import jwt\nfrom datetime import datetime\n\n@singleton\nclass JWTManager:\n    def __init__(self):\n        self.token = None\n\n    def is_expired(self) -&gt; bool:\n        if not self.token:\n            return True\n\n        try:\n            payload = jwt.decode(self.token, options={\"verify_signature\": False})\n            exp = datetime.fromtimestamp(payload['exp'])\n            return datetime.now() &gt;= exp\n        except:\n            return True\n\n    async def refresh_if_needed(self, http: Http):\n        if self.is_expired():\n            result = await http.post(\n                \"https://auth.example.com/refresh\",\n                json={\"refresh_token\": self.refresh_token}\n            )\n            self.token = result.to(dict)[\"access_token\"]\n</code></pre>"},{"location":"guides/http/advanced/#caching","title":"Caching","text":""},{"location":"guides/http/advanced/#response-cache","title":"Response Cache","text":"<pre><code>from typing import Optional\nimport hashlib\nimport json\n\n@singleton\nclass ResponseCache:\n    def __init__(self):\n        self._cache: Dict[str, tuple[float, Any]] = {}\n        self.ttl = 300  # 5 minutos\n\n    def _make_key(self, url: str, params: dict) -&gt; str:\n        data = f\"{url}:{json.dumps(params, sort_keys=True)}\"\n        return hashlib.md5(data.encode()).hexdigest()\n\n    def get(self, url: str, params: dict) -&gt; Optional[Any]:\n        key = self._make_key(url, params)\n        if key in self._cache:\n            timestamp, value = self._cache[key]\n            if time.time() - timestamp &lt; self.ttl:\n                return value\n        return None\n\n    def set(self, url: str, params: dict, value: Any):\n        key = self._make_key(url, params)\n        self._cache[key] = (time.time(), value)\n\n@inject\nasync def cached_requests(http: Http, cache: ResponseCache):\n    url = \"https://api.example.com/data\"\n    params = {\"page\": 1}\n\n    # Check cache\n    cached = cache.get(url, params)\n    if cached:\n        print(\"Cache hit!\")\n        return cached\n\n    # Fetch from API\n    result = await http.get(url, params=params)\n    data = result.to(dict)\n\n    # Store in cache\n    cache.set(url, params, data)\n\n    return data\n</code></pre>"},{"location":"guides/http/advanced/#websocket-support","title":"WebSocket Support","text":"<p>Para WebSockets, usa httpx directamente o una librer\u00eda dedicada:</p> <pre><code>@inject\nasync def websocket_example(http: Http):\n    # http no soporta WebSockets directamente\n    # Usa websockets library\n    import websockets\n\n    async with websockets.connect(\"wss://example.com/ws\") as ws:\n        await ws.send(\"Hello\")\n        response = await ws.recv()\n        return response\n</code></pre>"},{"location":"guides/http/advanced/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Result Pattern - Manejo avanzado de Result</li> <li>Basic Usage - Uso b\u00e1sico del cliente</li> <li>API Reference - Documentaci\u00f3n completa</li> </ul>"},{"location":"guides/http/basic-usage/","title":"HTTP Client - Uso B\u00e1sico","text":"<p>Gu\u00eda pr\u00e1ctica para usar el cliente HTTP de R5.</p>"},{"location":"guides/http/basic-usage/#setup-inicial","title":"Setup Inicial","text":"<pre><code>from R5.http import Http\nfrom R5.ioc import inject\n\n@inject\nasync def my_function(http: Http):\n    # http ya est\u00e1 disponible con connection pooling\n    result = await http.get(\"https://api.example.com/data\")\n    return result\n</code></pre> <p>El cliente HTTP se inyecta autom\u00e1ticamente. No necesitas crear instancias manualmente.</p>"},{"location":"guides/http/basic-usage/#get-requests","title":"GET Requests","text":""},{"location":"guides/http/basic-usage/#simple-get","title":"Simple GET","text":"<pre><code>@inject\nasync def fetch_user(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    print(f\"Status: {result.status}\")\n    print(f\"Response: {result.response.text}\")\n</code></pre>"},{"location":"guides/http/basic-usage/#get-con-query-parameters","title":"GET con Query Parameters","text":"<pre><code>@inject\nasync def search_users(http: Http):\n    result = await http.get(\n        \"https://api.example.com/users\",\n        params={\n            \"page\": 1,\n            \"limit\": 10,\n            \"search\": \"john\",\n            \"sort\": \"name:asc\"\n        }\n    )\n    # GET /users?page=1&amp;limit=10&amp;search=john&amp;sort=name:asc\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#get-con-headers","title":"GET con Headers","text":"<pre><code>@inject\nasync def fetch_protected_resource(http: Http):\n    result = await http.get(\n        \"https://api.example.com/protected\",\n        headers={\n            \"Authorization\": \"Bearer eyJhbGc...\",\n            \"X-API-Key\": \"secret-key\",\n            \"Accept\": \"application/json\"\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#get-con-timeout","title":"GET con Timeout","text":"<pre><code>@inject\nasync def fetch_with_timeout(http: Http):\n    result = await http.get(\n        \"https://api.example.com/slow-endpoint\",\n        timeout=5.0  # 5 segundos\n    )\n\n    if result.exception:\n        print(\"Request timed out\")\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#post-requests","title":"POST Requests","text":""},{"location":"guides/http/basic-usage/#post-con-json","title":"POST con JSON","text":"<pre><code>@inject\nasync def create_user(http: Http):\n    result = await http.post(\n        \"https://api.example.com/users\",\n        json={\n            \"name\": \"John Doe\",\n            \"email\": \"john@example.com\",\n            \"age\": 30\n        }\n    )\n\n    if result.status == 201:\n        print(\"User created successfully\")\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#post-con-form-data","title":"POST con Form Data","text":"<pre><code>@inject\nasync def submit_form(http: Http):\n    result = await http.post(\n        \"https://api.example.com/form\",\n        data={\n            \"username\": \"johndoe\",\n            \"password\": \"secret123\",\n            \"remember\": \"true\"\n        }\n    )\n    # Content-Type: application/x-www-form-urlencoded\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#post-con-headers","title":"POST con Headers","text":"<pre><code>@inject\nasync def create_with_auth(http: Http):\n    result = await http.post(\n        \"https://api.example.com/users\",\n        json={\"name\": \"John\"},\n        headers={\n            \"Authorization\": \"Bearer token123\",\n            \"Content-Type\": \"application/json\"\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#post-con-bytes","title":"POST con Bytes","text":"<pre><code>@inject\nasync def upload_file(http: Http):\n    with open(\"image.jpg\", \"rb\") as f:\n        content = f.read()\n\n    result = await http.post(\n        \"https://api.example.com/upload\",\n        content=content,\n        headers={\"Content-Type\": \"image/jpeg\"}\n    )\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#put-requests","title":"PUT Requests","text":""},{"location":"guides/http/basic-usage/#actualizar-recurso","title":"Actualizar Recurso","text":"<pre><code>@inject\nasync def update_user(http: Http):\n    result = await http.put(\n        \"https://api.example.com/users/1\",\n        json={\n            \"name\": \"Jane Doe\",\n            \"email\": \"jane@example.com\",\n            \"age\": 31\n        }\n    )\n\n    if result.status == 200:\n        print(\"User updated\")\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#patch-requests","title":"PATCH Requests","text":""},{"location":"guides/http/basic-usage/#actualizacion-parcial","title":"Actualizaci\u00f3n Parcial","text":"<pre><code>@inject\nasync def update_email(http: Http):\n    result = await http.patch(\n        \"https://api.example.com/users/1\",\n        json={\n            \"email\": \"newemail@example.com\"\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#delete-requests","title":"DELETE Requests","text":""},{"location":"guides/http/basic-usage/#eliminar-recurso","title":"Eliminar Recurso","text":"<pre><code>@inject\nasync def delete_user(http: Http):\n    result = await http.delete(\n        \"https://api.example.com/users/1\"\n    )\n\n    if result.status == 204:\n        print(\"User deleted\")\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#delete-con-headers","title":"DELETE con Headers","text":"<pre><code>@inject\nasync def delete_with_auth(http: Http):\n    result = await http.delete(\n        \"https://api.example.com/users/1\",\n        headers={\n            \"Authorization\": \"Bearer token123\"\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#mapeo-a-dtos","title":"Mapeo a DTOs","text":""},{"location":"guides/http/basic-usage/#con-dataclasses","title":"Con Dataclasses","text":"<pre><code>from dataclasses import dataclass\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n    username: str\n\n@inject\nasync def get_user(http: Http):\n    result = await http.get(\"https://jsonplaceholder.typicode.com/users/1\")\n\n    # Mapea autom\u00e1ticamente JSON a User\n    user = result.to(User)\n\n    if user:\n        print(f\"Name: {user.name}\")\n        print(f\"Email: {user.email}\")\n\n    return user\n</code></pre>"},{"location":"guides/http/basic-usage/#con-pydantic","title":"Con Pydantic","text":"<pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n    username: str\n\n@inject\nasync def get_user(http: Http):\n    result = await http.get(\"https://jsonplaceholder.typicode.com/users/1\")\n\n    # Pydantic con validaci\u00f3n autom\u00e1tica\n    user = result.to(User)\n\n    return user\n</code></pre>"},{"location":"guides/http/basic-usage/#con-dict","title":"Con Dict","text":"<pre><code>@inject\nasync def get_user_dict(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    # Mapea a dict\n    user_dict = result.to(dict)\n\n    print(user_dict[\"name\"])\n    return user_dict\n</code></pre>"},{"location":"guides/http/basic-usage/#con-list","title":"Con List","text":"<pre><code>@inject\nasync def get_users_list(http: Http):\n    result = await http.get(\"https://api.example.com/users\")\n\n    # Mapea a lista\n    users = result.to(list)\n\n    for user in users:\n        print(user[\"name\"])\n\n    return users\n</code></pre>"},{"location":"guides/http/basic-usage/#manejo-de-respuestas","title":"Manejo de Respuestas","text":""},{"location":"guides/http/basic-usage/#verificar-status-code","title":"Verificar Status Code","text":"<pre><code>@inject\nasync def check_status(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    if result.status == 200:\n        print(\"Success\")\n    elif result.status == 404:\n        print(\"Not found\")\n    elif result.status &gt;= 500:\n        print(\"Server error\")\n</code></pre>"},{"location":"guides/http/basic-usage/#acceder-a-response","title":"Acceder a Response","text":"<pre><code>@inject\nasync def access_response(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    # Objeto httpx.Response completo\n    print(result.response.status_code)\n    print(result.response.headers)\n    print(result.response.text)\n    print(result.response.json())\n    print(result.response.content)\n</code></pre>"},{"location":"guides/http/basic-usage/#verificar-excepciones","title":"Verificar Excepciones","text":"<pre><code>@inject\nasync def check_exception(http: Http):\n    result = await http.get(\"https://invalid-url.com\")\n\n    if result.exception:\n        print(f\"Error occurred: {result.exception}\")\n        print(f\"Status: {result.status}\")  # 0 si no hubo response\n</code></pre>"},{"location":"guides/http/basic-usage/#handlers-para-una-request","title":"Handlers para una Request","text":""},{"location":"guides/http/basic-usage/#on_status","title":"on_status","text":"<pre><code>@inject\nasync def with_status_handlers(http: Http):\n    result = await http.get(\n        \"https://api.example.com/users/1\",\n        on_status={\n            200: lambda: print(\"\u2705 Success\"),\n            404: lambda: print(\"\u274c Not found\"),\n            500: lambda: print(\"\u26a0\ufe0f  Server error\")\n        }\n    )\n</code></pre>"},{"location":"guides/http/basic-usage/#on_exception","title":"on_exception","text":"<pre><code>@inject\nasync def with_exception_handler(http: Http):\n    result = await http.get(\n        \"https://api.example.com/users/1\",\n        on_exception=lambda e: print(f\"Error: {e}\")\n    )\n</code></pre>"},{"location":"guides/http/basic-usage/#on_before-y-on_after","title":"on_before y on_after","text":"<pre><code>@inject\nasync def with_before_after(http: Http):\n    result = await http.get(\n        \"https://api.example.com/users/1\",\n        on_before=lambda req: print(f\"\u2192 {req.method} {req.url}\"),\n        on_after=lambda req, res: print(f\"\u2190 {res.status_code}\")\n    )\n</code></pre>"},{"location":"guides/http/basic-usage/#requests-concurrentes","title":"Requests Concurrentes","text":""},{"location":"guides/http/basic-usage/#asynciogather","title":"asyncio.gather","text":"<pre><code>import asyncio\n\n@inject\nasync def fetch_multiple_users(http: Http):\n    results = await asyncio.gather(\n        http.get(\"https://api.example.com/users/1\"),\n        http.get(\"https://api.example.com/users/2\"),\n        http.get(\"https://api.example.com/users/3\")\n    )\n\n    users = [r.to(User) for r in results if r.status == 200]\n    return users\n</code></pre>"},{"location":"guides/http/basic-usage/#asynciocreate_task","title":"asyncio.create_task","text":"<pre><code>@inject\nasync def concurrent_requests(http: Http):\n    task1 = asyncio.create_task(http.get(\"https://api.example.com/users/1\"))\n    task2 = asyncio.create_task(http.get(\"https://api.example.com/posts/1\"))\n\n    user_result = await task1\n    post_result = await task2\n\n    return (user_result, post_result)\n</code></pre>"},{"location":"guides/http/basic-usage/#configuracion-por-request","title":"Configuraci\u00f3n por Request","text":""},{"location":"guides/http/basic-usage/#follow-redirects","title":"Follow Redirects","text":"<pre><code>@inject\nasync def no_redirects(http: Http):\n    result = await http.get(\n        \"https://api.example.com/redirect\",\n        follow_redirects=False\n    )\n\n    print(result.status)  # Puede ser 301, 302, etc.\n</code></pre>"},{"location":"guides/http/basic-usage/#timeout-personalizado","title":"Timeout Personalizado","text":"<pre><code>@inject\nasync def custom_timeout(http: Http):\n    # Timeout corto para requests r\u00e1pidas\n    result = await http.get(\n        \"https://api.example.com/ping\",\n        timeout=1.0\n    )\n\n    # Timeout largo para operaciones pesadas\n    result = await http.post(\n        \"https://api.example.com/process\",\n        json={\"data\": \"...\"},\n        timeout=60.0\n    )\n</code></pre>"},{"location":"guides/http/basic-usage/#ejemplos-practicos","title":"Ejemplos Pr\u00e1cticos","text":""},{"location":"guides/http/basic-usage/#api-rest-completa","title":"API REST Completa","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass Todo:\n    id: Optional[int]\n    title: str\n    completed: bool = False\n\n@inject\nasync def crud_operations(http: Http):\n    # CREATE\n    create_result = await http.post(\n        \"https://jsonplaceholder.typicode.com/todos\",\n        json={\"title\": \"New Todo\", \"completed\": False}\n    )\n    todo = create_result.to(Todo)\n    print(f\"Created: {todo.title}\")\n\n    # READ\n    read_result = await http.get(\n        \"https://jsonplaceholder.typicode.com/todos/1\"\n    )\n    todo = read_result.to(Todo)\n    print(f\"Read: {todo.title}\")\n\n    # UPDATE\n    update_result = await http.put(\n        \"https://jsonplaceholder.typicode.com/todos/1\",\n        json={\"title\": \"Updated Todo\", \"completed\": True}\n    )\n    todo = update_result.to(Todo)\n    print(f\"Updated: {todo.title}\")\n\n    # DELETE\n    delete_result = await http.delete(\n        \"https://jsonplaceholder.typicode.com/todos/1\"\n    )\n    print(f\"Deleted: {delete_result.status}\")\n</code></pre>"},{"location":"guides/http/basic-usage/#autenticacion-y-headers","title":"Autenticaci\u00f3n y Headers","text":"<pre><code>@inject\nasync def authenticated_requests(http: Http):\n    # Login\n    login_result = await http.post(\n        \"https://api.example.com/auth/login\",\n        json={\"username\": \"user\", \"password\": \"pass\"}\n    )\n\n    token = login_result.to(dict).get(\"token\")\n\n    # Usar token en requests\n    profile_result = await http.get(\n        \"https://api.example.com/profile\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n\n    profile = profile_result.to(dict)\n    return profile\n</code></pre>"},{"location":"guides/http/basic-usage/#paginacion","title":"Paginaci\u00f3n","text":"<pre><code>@inject\nasync def fetch_all_pages(http: Http):\n    all_users = []\n    page = 1\n\n    while True:\n        result = await http.get(\n            \"https://api.example.com/users\",\n            params={\"page\": page, \"limit\": 10}\n        )\n\n        if result.status != 200:\n            break\n\n        users = result.to(list)\n        if not users:\n            break\n\n        all_users.extend(users)\n        page += 1\n\n    return all_users\n</code></pre>"},{"location":"guides/http/basic-usage/#rate-limiting-manual","title":"Rate Limiting Manual","text":"<pre><code>import asyncio\n\n@inject\nasync def rate_limited_requests(http: Http):\n    results = []\n\n    for i in range(10):\n        result = await http.get(f\"https://api.example.com/users/{i}\")\n        results.append(result)\n\n        # Esperar 100ms entre requests\n        await asyncio.sleep(0.1)\n\n    return results\n</code></pre>"},{"location":"guides/http/basic-usage/#errores-comunes","title":"Errores Comunes","text":""},{"location":"guides/http/basic-usage/#timeout","title":"Timeout","text":"<pre><code>@inject\nasync def handle_timeout(http: Http):\n    result = await http.get(\n        \"https://slow-api.example.com/data\",\n        timeout=5.0\n    )\n\n    if result.exception:\n        print(\"Request timed out or failed\")\n        return None\n\n    return result.to(dict)\n</code></pre>"},{"location":"guides/http/basic-usage/#json-parse-error","title":"JSON Parse Error","text":"<pre><code>@inject\nasync def handle_json_error(http: Http):\n    result = await http.get(\"https://api.example.com/data\")\n\n    # .to() retorna None si falla el parsing\n    data = result.to(dict)\n\n    if data is None:\n        print(\"Failed to parse JSON\")\n        return {}\n\n    return data\n</code></pre>"},{"location":"guides/http/basic-usage/#network-error","title":"Network Error","text":"<pre><code>@inject\nasync def handle_network_error(http: Http):\n    result = await http.get(\"https://unreachable-api.example.com\")\n\n    if result.exception:\n        print(f\"Network error: {result.exception}\")\n        return None\n\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Advanced Features - Retry, handlers globales, proxy rotation</li> <li>Result Pattern - Manejo avanzado de respuestas</li> <li>API Reference - Documentaci\u00f3n completa de la API</li> </ul>"},{"location":"guides/http/overview/","title":"HTTP Client - Overview","text":"<p>El cliente HTTP de R5 proporciona una interfaz moderna para realizar peticiones HTTP con connection pooling, retry autom\u00e1tico y manejo robusto de errores.</p>"},{"location":"guides/http/overview/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>\u2705 Connection Pooling - Reutiliza conexiones para mejor rendimiento</li> <li>\u2705 Async/Await - Totalmente as\u00edncrono con httpx</li> <li>\u2705 Result Pattern - Manejo de errores sin excepciones</li> <li>\u2705 Retry Autom\u00e1tico - Configuraci\u00f3n flexible de reintentos</li> <li>\u2705 Handlers - Hooks para logging, m\u00e9tricas, etc.</li> <li>\u2705 Type-Safe - Mapeo autom\u00e1tico a DTOs</li> <li>\u2705 Proxy Rotation - Soporte para m\u00faltiples proxies</li> <li>\u2705 Inyecci\u00f3n IoC - Integrado con el container</li> </ul>"},{"location":"guides/http/overview/#arquitectura","title":"Arquitectura","text":"<pre><code>graph TB\n    A[Http Client] --&gt; B[httpx.AsyncClient]\n    A --&gt; C[Connection Pool]\n    A --&gt; D[Result Pattern]\n\n    B --&gt; E[Request]\n    E --&gt; F[Before Handlers]\n    F --&gt; G[Send]\n    G --&gt; H[After Handlers]\n    H --&gt; I[Result]\n\n    I --&gt; J[.to(DTO)]\n    I --&gt; K[.on_status()]\n    I --&gt; L[.on_exception()]</code></pre>"},{"location":"guides/http/overview/#componentes-principales","title":"Componentes Principales","text":""},{"location":"guides/http/overview/#http-client","title":"Http Client","text":"<p>El cliente principal que gestiona todas las requests:</p> <pre><code>from R5.http import Http\nfrom R5.ioc import inject\n\n@inject\nasync def fetch_data(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n    return result\n</code></pre>"},{"location":"guides/http/overview/#result","title":"Result","text":"<p>Wrapper que encapsula la respuesta HTTP:</p> <pre><code>result = await http.get(\"/users/1\")\n\n# Acceso a propiedades\nprint(result.status)       # 200\nprint(result.response)     # httpx.Response\nprint(result.exception)    # None si exitosa\n</code></pre>"},{"location":"guides/http/overview/#httpconfig","title":"HttpConfig","text":"<p>Configuraci\u00f3n del cliente HTTP:</p> <pre><code>from R5.ioc import config\nfrom R5.http.http import HttpConfig\n\n@config(file='.env')\nclass MyHttpConfig(HttpConfig):\n    max_connections: int = 100\n    connect_timeout: float = 5.0\n    max_retries: int = 3\n</code></pre>"},{"location":"guides/http/overview/#flujo-de-una-request","title":"Flujo de una Request","text":"<pre><code>sequenceDiagram\n    participant App\n    participant Http\n    participant Pool\n    participant Server\n\n    App-&gt;&gt;Http: await http.get(\"/users/1\")\n    Http-&gt;&gt;Http: Execute before handlers\n    Http-&gt;&gt;Pool: Get connection\n    Pool-&gt;&gt;Server: HTTP GET /users/1\n    Server-&gt;&gt;Pool: 200 OK + data\n    Pool-&gt;&gt;Http: Response\n    Http-&gt;&gt;Http: Execute after handlers\n    Http-&gt;&gt;App: Result\n    App-&gt;&gt;Result: .to(UserDTO)\n    Result-&gt;&gt;App: UserDTO instance</code></pre>"},{"location":"guides/http/overview/#ejemplo-completo","title":"Ejemplo Completo","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom R5.http import Http\nfrom R5.ioc import inject, config\nfrom R5.http.http import HttpConfig\n\n@config(file='.env')\nclass AppHttpConfig(HttpConfig):\n    max_connections: int = 50\n    connect_timeout: float = 10.0\n    max_retries: int = 3\n    retry_statuses: list[int] = [429, 500, 502, 503]\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n    username: str\n\n@inject\nasync def main(http: Http):\n    # Simple GET\n    result = await http.get(\"https://jsonplaceholder.typicode.com/users/1\")\n\n    # Mapear a DTO\n    user = result.to(User)\n\n    if user:\n        print(f\"User: {user.name} ({user.email})\")\n\n    # Con handlers\n    result = await http.get(\n        \"https://jsonplaceholder.typicode.com/users/999\",\n        on_status={\n            404: lambda: print(\"User not found\"),\n            200: lambda: print(\"User found\")\n        }\n    )\n\n    # Con retry\n    result = await http.retry(\n        attempts=3,\n        delay=1.0\n    ).get(\"https://jsonplaceholder.typicode.com/posts/1\")\n\n    print(f\"Status: {result.status}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"guides/http/overview/#connection-pooling","title":"Connection Pooling","text":"<p>R5 usa <code>httpx.AsyncClient</code> internamente con connection pooling:</p> <pre><code>@inject\nasync def concurrent_requests(http: Http):\n    # Todas estas requests reutilizan conexiones del pool\n    results = await asyncio.gather(\n        http.get(\"https://api.example.com/users/1\"),\n        http.get(\"https://api.example.com/users/2\"),\n        http.get(\"https://api.example.com/users/3\"),\n        http.get(\"https://api.example.com/users/4\"),\n        http.get(\"https://api.example.com/users/5\")\n    )\n\n    return results\n</code></pre> <p>Beneficios: - Reutiliza conexiones TCP - Reduce latencia - Menor overhead de SSL/TLS - Mejor rendimiento</p>"},{"location":"guides/http/overview/#result-pattern","title":"Result Pattern","text":"<p>En lugar de lanzar excepciones, R5 retorna un <code>Result</code>:</p> <pre><code>result = await http.get(\"/users/1\")\n\n# Verificar \u00e9xito\nif result.status == 200:\n    user = result.to(User)\n\n# Verificar error\nif result.status == 404:\n    print(\"Not found\")\n\n# Verificar excepci\u00f3n\nif result.exception:\n    print(f\"Error: {result.exception}\")\n\n# Encadenar handlers\nresult.on_status(404, lambda req, res: handle_not_found())\n      .on_status(200, lambda req, res: handle_success())\n      .on_exception(lambda e: log_error(e))\n</code></pre> <p>Beneficios: - No necesitas try/except - Flujo m\u00e1s claro - F\u00e1cil composici\u00f3n - Type-safe</p>"},{"location":"guides/http/overview/#metodos-http","title":"M\u00e9todos HTTP","text":"<p>R5 soporta todos los m\u00e9todos HTTP est\u00e1ndar:</p> <pre><code>@inject\nasync def http_methods(http: Http):\n    # GET\n    result = await http.get(\"/users/1\")\n\n    # POST\n    result = await http.post(\"/users\", json={\"name\": \"John\"})\n\n    # PUT\n    result = await http.put(\"/users/1\", json={\"name\": \"Jane\"})\n\n    # PATCH\n    result = await http.patch(\"/users/1\", json={\"email\": \"new@example.com\"})\n\n    # DELETE\n    result = await http.delete(\"/users/1\")\n</code></pre>"},{"location":"guides/http/overview/#configuracion-basica","title":"Configuraci\u00f3n B\u00e1sica","text":""},{"location":"guides/http/overview/#timeouts","title":"Timeouts","text":"<pre><code>result = await http.get(\"/users/1\", timeout=10.0)\n</code></pre>"},{"location":"guides/http/overview/#headers-personalizados","title":"Headers Personalizados","text":"<pre><code>result = await http.get(\n    \"/users/1\",\n    headers={\n        \"Authorization\": \"Bearer token123\",\n        \"X-Custom-Header\": \"value\"\n    }\n)\n</code></pre>"},{"location":"guides/http/overview/#query-parameters","title":"Query Parameters","text":"<pre><code>result = await http.get(\n    \"/users\",\n    params={\n        \"page\": 1,\n        \"limit\": 10,\n        \"sort\": \"name\"\n    }\n)\n# GET /users?page=1&amp;limit=10&amp;sort=name\n</code></pre>"},{"location":"guides/http/overview/#post-con-json","title":"POST con JSON","text":"<pre><code>result = await http.post(\n    \"/users\",\n    json={\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\"\n    }\n)\n</code></pre>"},{"location":"guides/http/overview/#post-con-form-data","title":"POST con Form Data","text":"<pre><code>result = await http.post(\n    \"/upload\",\n    data={\n        \"field1\": \"value1\",\n        \"field2\": \"value2\"\n    }\n)\n</code></pre>"},{"location":"guides/http/overview/#handlers-hooks","title":"Handlers (Hooks)","text":""},{"location":"guides/http/overview/#before-handler","title":"Before Handler","text":"<p>Se ejecuta antes de cada request:</p> <pre><code>def log_request(request):\n    print(f\"\u2192 {request.method} {request.url}\")\n\nhttp.on_before(log_request)\n\n# Ahora todas las requests logean\nawait http.get(\"/users/1\")  # \u2192 GET https://api.example.com/users/1\n</code></pre>"},{"location":"guides/http/overview/#after-handler","title":"After Handler","text":"<p>Se ejecuta despu\u00e9s de cada request exitosa:</p> <pre><code>def log_response(request, response):\n    print(f\"\u2190 {response.status_code}\")\n\nhttp.on_after(log_response)\n\nawait http.get(\"/users/1\")  # \u2190 200\n</code></pre>"},{"location":"guides/http/overview/#handlers-locales","title":"Handlers Locales","text":"<p>Para una sola request:</p> <pre><code>result = await http.get(\n    \"/users/1\",\n    on_before=lambda req: print(f\"Fetching {req.url}\"),\n    on_after=lambda req, res: print(f\"Got {res.status_code}\")\n)\n</code></pre>"},{"location":"guides/http/overview/#retry-automatico","title":"Retry Autom\u00e1tico","text":"<pre><code># Retry en status codes espec\u00edficos\nresult = await http.retry(\n    attempts=3,\n    delay=1.0,\n    backoff=2.0,\n    when_status=(429, 500, 502, 503)\n).get(\"/api/data\")\n\n# Retry en excepciones\nresult = await http.retry(\n    attempts=5,\n    delay=0.5,\n    when_exception=(httpx.TimeoutException, httpx.NetworkError)\n).get(\"/api/data\")\n</code></pre>"},{"location":"guides/http/overview/#lifecycle-management","title":"Lifecycle Management","text":"<p>El cliente HTTP es un <code>@resource</code>, se limpia autom\u00e1ticamente:</p> <pre><code>@inject\nasync def my_service(http: Http):\n    # Usa http normalmente\n    result = await http.get(\"/data\")\n\n    # Al salir de la funci\u00f3n, el cliente se cierra autom\u00e1ticamente\n    # (si no hay m\u00e1s referencias)\n</code></pre> <p>Manual cleanup:</p> <pre><code>http = Container.resolve(Http)\n# Usar http...\nawait http.close()\n</code></pre>"},{"location":"guides/http/overview/#comparacion-con-otras-librerias","title":"Comparaci\u00f3n con Otras Librer\u00edas","text":""},{"location":"guides/http/overview/#r5-vs-requests","title":"R5 vs requests","text":"<pre><code># requests (sync, blocking)\nimport requests\nresponse = requests.get(\"https://api.example.com/users/1\")\nuser = response.json()\n\n# R5 (async, connection pooling)\n@inject\nasync def fetch_user(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n    user = result.to(UserDTO)\n</code></pre>"},{"location":"guides/http/overview/#r5-vs-httpx-directo","title":"R5 vs httpx directo","text":"<pre><code># httpx (manual pooling)\nasync with httpx.AsyncClient() as client:\n    response = await client.get(\"https://api.example.com/users/1\")\n    user = response.json()\n\n# R5 (pooling autom\u00e1tico + IoC)\n@inject\nasync def fetch_user(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n    user = result.to(UserDTO)\n</code></pre>"},{"location":"guides/http/overview/#r5-vs-aiohttp","title":"R5 vs aiohttp","text":"<pre><code># aiohttp\nasync with aiohttp.ClientSession() as session:\n    async with session.get(\"https://api.example.com/users/1\") as response:\n        user = await response.json()\n\n# R5\n@inject\nasync def fetch_user(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n    user = result.to(UserDTO)\n</code></pre>"},{"location":"guides/http/overview/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Basic Usage - Uso b\u00e1sico del cliente HTTP</li> <li>Advanced Features - Retry, handlers, proxy rotation</li> <li>Result Pattern - Manejo de respuestas y errores</li> <li>API Reference - Documentaci\u00f3n completa de la API</li> </ul>"},{"location":"guides/http/result/","title":"Result Pattern","text":"<p>El <code>Result</code> es un wrapper que encapsula respuestas HTTP, permitiendo manejo de errores sin excepciones.</p>"},{"location":"guides/http/result/#concepto","title":"Concepto","text":"<p>En lugar de lanzar excepciones, R5 retorna un objeto <code>Result</code> que contiene:</p> <ul> <li><code>response</code> - La respuesta HTTP (si existe)</li> <li><code>request</code> - La request original (si existe)</li> <li><code>status</code> - C\u00f3digo de estado HTTP (0 si hubo excepci\u00f3n)</li> <li><code>exception</code> - Excepci\u00f3n capturada (None si fue exitosa)</li> </ul>"},{"location":"guides/http/result/#creacion-de-result","title":"Creaci\u00f3n de Result","text":""},{"location":"guides/http/result/#desde-response","title":"Desde Response","text":"<pre><code>from R5.http import Result\nimport httpx\n\nresponse = httpx.Response(200, json={\"id\": 1, \"name\": \"John\"})\nresult = Result.from_response(response)\n\nprint(result.status)      # 200\nprint(result.exception)   # None\nprint(result.response)    # httpx.Response\n</code></pre>"},{"location":"guides/http/result/#desde-exception","title":"Desde Exception","text":"<pre><code>error = Exception(\"Network error\")\nresult = Result.from_exception(error)\n\nprint(result.status)      # 0\nprint(result.exception)   # Exception(\"Network error\")\nprint(result.response)    # None\n</code></pre>"},{"location":"guides/http/result/#verificacion-de-estado","title":"Verificaci\u00f3n de Estado","text":""},{"location":"guides/http/result/#por-status-code","title":"Por Status Code","text":"<pre><code>@inject\nasync def check_status(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    if result.status == 200:\n        print(\"Success\")\n    elif result.status == 404:\n        print(\"Not found\")\n    elif result.status &gt;= 500:\n        print(\"Server error\")\n</code></pre>"},{"location":"guides/http/result/#por-rango","title":"Por Rango","text":"<pre><code>@inject\nasync def check_range(http: Http):\n    result = await http.get(\"https://api.example.com/data\")\n\n    if 200 &lt;= result.status &lt; 300:\n        print(\"Success 2xx\")\n    elif 400 &lt;= result.status &lt; 500:\n        print(\"Client error 4xx\")\n    elif 500 &lt;= result.status &lt; 600:\n        print(\"Server error 5xx\")\n</code></pre>"},{"location":"guides/http/result/#por-excepcion","title":"Por Excepci\u00f3n","text":"<pre><code>@inject\nasync def check_exception(http: Http):\n    result = await http.get(\"https://invalid-url.com\")\n\n    if result.exception:\n        print(f\"Request failed: {result.exception}\")\n        return None\n\n    return result.to(dict)\n</code></pre>"},{"location":"guides/http/result/#handlers-encadenados","title":"Handlers Encadenados","text":""},{"location":"guides/http/result/#on_status","title":"on_status","text":"<p>Ejecuta handler si el status coincide:</p> <pre><code>@inject\nasync def with_status_handler(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    result.on_status(404, lambda req, res: print(\"User not found\"))\n          .on_status(200, lambda req, res: print(\"User found\"))\n\n    # Los handlers NO modifican result, solo ejecutan side effects\n</code></pre>"},{"location":"guides/http/result/#on_exception","title":"on_exception","text":"<p>Ejecuta handler si hubo excepci\u00f3n:</p> <pre><code>@inject\nasync def with_exception_handler(http: Http):\n    result = await http.get(\"https://api.example.com/data\")\n\n    result.on_exception(lambda e: print(f\"Error: {e}\"))\n\n    # Contin\u00faa el flujo normal\n    data = result.to(dict)\n</code></pre>"},{"location":"guides/http/result/#chaining","title":"Chaining","text":"<p>Los handlers retornan <code>self</code>, permitiendo chaining:</p> <pre><code>@inject\nasync def chained_handlers(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    user = (result\n        .on_status(404, lambda req, res: print(\"Not found\"))\n        .on_status(500, lambda req, res: print(\"Server error\"))\n        .on_exception(lambda e: log_error(e))\n        .to(User))\n\n    return user\n</code></pre>"},{"location":"guides/http/result/#mapeo-a-tipos","title":"Mapeo a Tipos","text":""},{"location":"guides/http/result/#to-method","title":"to() Method","text":"<p>Convierte la respuesta JSON al tipo especificado:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n\n@inject\nasync def map_to_user(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    # Mapea autom\u00e1ticamente\n    user = result.to(User)\n\n    if user:\n        print(f\"Name: {user.name}\")\n    else:\n        print(\"Mapping failed\")\n</code></pre>"},{"location":"guides/http/result/#tipos-soportados","title":"Tipos Soportados","text":""},{"location":"guides/http/result/#pydantic-basemodel","title":"Pydantic BaseModel","text":"<pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\nresult = await http.get(\"https://api.example.com/users/1\")\nuser = result.to(User)  # Validaci\u00f3n autom\u00e1tica de Pydantic\n</code></pre>"},{"location":"guides/http/result/#dataclass","title":"Dataclass","text":"<pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n\nresult = await http.get(\"https://api.example.com/products/1\")\nproduct = result.to(Product)\n</code></pre>"},{"location":"guides/http/result/#dict","title":"Dict","text":"<pre><code>result = await http.get(\"https://api.example.com/data\")\ndata = result.to(dict)\n\nprint(data[\"field\"])\n</code></pre>"},{"location":"guides/http/result/#list","title":"List","text":"<pre><code>result = await http.get(\"https://api.example.com/users\")\nusers = result.to(list)\n\nfor user in users:\n    print(user[\"name\"])\n</code></pre>"},{"location":"guides/http/result/#typeddict","title":"TypedDict","text":"<pre><code>from typing import TypedDict\n\nclass UserDict(TypedDict):\n    id: int\n    name: str\n    email: str\n\nresult = await http.get(\"https://api.example.com/users/1\")\nuser = result.to(UserDict)\n</code></pre>"},{"location":"guides/http/result/#manejo-de-errores","title":"Manejo de Errores","text":""},{"location":"guides/http/result/#mapping-failure","title":"Mapping Failure","text":"<p>Si <code>.to()</code> falla, retorna <code>None</code>:</p> <pre><code>@inject\nasync def handle_mapping_error(http: Http):\n    result = await http.get(\"https://api.example.com/data\")\n\n    user = result.to(User)\n\n    if user is None:\n        print(\"Failed to map to User\")\n        print(f\"Status: {result.status}\")\n        print(f\"Response: {result.response.text if result.response else 'None'}\")\n        return None\n\n    return user\n</code></pre>"},{"location":"guides/http/result/#json-parse-error","title":"JSON Parse Error","text":"<pre><code>@inject\nasync def handle_json_error(http: Http):\n    # Response no es JSON\n    result = await http.get(\"https://example.com/html-page\")\n\n    data = result.to(dict)  # None porque no puede parsear JSON\n\n    if data is None:\n        print(\"Response is not valid JSON\")\n        if result.response:\n            print(f\"Content: {result.response.text}\")\n</code></pre>"},{"location":"guides/http/result/#type-mismatch","title":"Type Mismatch","text":"<pre><code>@inject\nasync def handle_type_mismatch(http: Http):\n    # API retorna lista pero esperamos dict\n    result = await http.get(\"https://api.example.com/users\")\n\n    user = result.to(User)  # None porque response es lista, no dict\n\n    if user is None:\n        # Intentar como lista\n        users = result.to(list)\n        if users:\n            print(f\"Got {len(users)} users\")\n</code></pre>"},{"location":"guides/http/result/#acceso-a-response","title":"Acceso a Response","text":""},{"location":"guides/http/result/#response-completo","title":"Response completo","text":"<pre><code>@inject\nasync def access_response(http: Http):\n    result = await http.get(\"https://api.example.com/data\")\n\n    if result.response:\n        print(f\"Status: {result.response.status_code}\")\n        print(f\"Headers: {result.response.headers}\")\n        print(f\"Content: {result.response.content}\")\n        print(f\"Text: {result.response.text}\")\n        print(f\"JSON: {result.response.json()}\")\n</code></pre>"},{"location":"guides/http/result/#request-original","title":"Request original","text":"<pre><code>@inject\nasync def access_request(http: Http):\n    result = await http.get(\"https://api.example.com/data\")\n\n    if result.request:\n        print(f\"URL: {result.request.url}\")\n        print(f\"Method: {result.request.method}\")\n        print(f\"Headers: {result.request.headers}\")\n</code></pre>"},{"location":"guides/http/result/#patrones-comunes","title":"Patrones Comunes","text":""},{"location":"guides/http/result/#early-return","title":"Early Return","text":"<pre><code>@inject\nasync def early_return(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    # Return early si hay error\n    if result.status != 200:\n        print(f\"Error: {result.status}\")\n        return None\n\n    user = result.to(User)\n    return user\n</code></pre>"},{"location":"guides/http/result/#fallback-value","title":"Fallback Value","text":"<pre><code>@inject\nasync def with_fallback(http: Http):\n    result = await http.get(\"https://api.example.com/config\")\n\n    config = result.to(dict)\n\n    # Usar fallback si falla\n    if config is None:\n        config = {\"default\": True}\n\n    return config\n</code></pre>"},{"location":"guides/http/result/#retry-on-specific-status","title":"Retry on Specific Status","text":"<pre><code>@inject\nasync def custom_retry(http: Http):\n    max_attempts = 3\n\n    for attempt in range(max_attempts):\n        result = await http.get(\"https://api.example.com/data\")\n\n        if result.status == 200:\n            return result.to(dict)\n\n        if result.status == 429:  # Rate limited\n            await asyncio.sleep(2 ** attempt)\n            continue\n\n        # Otro error, no reintentar\n        break\n\n    return None\n</code></pre>"},{"location":"guides/http/result/#multiple-handlers","title":"Multiple Handlers","text":"<pre><code>@inject\nasync def multiple_handlers(http: Http):\n    errors = []\n\n    result = await http.get(\"https://api.example.com/data\")\n\n    result.on_status(404, lambda req, res: errors.append(\"Not found\"))\n          .on_status(403, lambda req, res: errors.append(\"Forbidden\"))\n          .on_status(401, lambda req, res: errors.append(\"Unauthorized\"))\n          .on_exception(lambda e: errors.append(f\"Exception: {e}\"))\n\n    if errors:\n        print(f\"Errors: {errors}\")\n\n    return result.to(dict)\n</code></pre>"},{"location":"guides/http/result/#logging-helper","title":"Logging Helper","text":"<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\ndef log_result(result: Result, operation: str):\n    \"\"\"Helper para logging de results.\"\"\"\n    if result.exception:\n        logger.error(f\"{operation} failed: {result.exception}\")\n    elif result.status &gt;= 400:\n        logger.warning(f\"{operation} returned {result.status}\")\n    else:\n        logger.info(f\"{operation} succeeded: {result.status}\")\n\n@inject\nasync def with_logging_helper(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n    log_result(result, \"Fetch user\")\n\n    return result.to(User)\n</code></pre>"},{"location":"guides/http/result/#result-validator","title":"Result Validator","text":"<pre><code>def validate_result(result: Result) -&gt; bool:\n    \"\"\"Valida que result sea exitoso y tenga datos.\"\"\"\n    if result.exception:\n        return False\n\n    if result.status &lt; 200 or result.status &gt;= 300:\n        return False\n\n    if not result.response:\n        return False\n\n    try:\n        result.response.json()\n        return True\n    except:\n        return False\n\n@inject\nasync def with_validator(http: Http):\n    result = await http.get(\"https://api.example.com/data\")\n\n    if not validate_result(result):\n        print(\"Invalid result\")\n        return None\n\n    return result.to(dict)\n</code></pre>"},{"location":"guides/http/result/#testing","title":"Testing","text":""},{"location":"guides/http/result/#mock-result","title":"Mock Result","text":"<pre><code>from unittest.mock import Mock\n\ndef test_with_mock_result():\n    # Mock success\n    mock_response = Mock()\n    mock_response.status_code = 200\n    mock_response.json.return_value = {\"id\": 1, \"name\": \"John\"}\n\n    result = Result.from_response(mock_response)\n\n    assert result.status == 200\n    assert result.exception is None\n\n    user = result.to(dict)\n    assert user[\"name\"] == \"John\"\n</code></pre>"},{"location":"guides/http/result/#mock-error","title":"Mock Error","text":"<pre><code>def test_with_mock_error():\n    error = Exception(\"Network error\")\n    result = Result.from_exception(error)\n\n    assert result.status == 0\n    assert result.exception == error\n    assert result.response is None\n</code></pre>"},{"location":"guides/http/result/#test-handlers","title":"Test Handlers","text":"<pre><code>def test_result_handlers():\n    mock_response = Mock()\n    mock_response.status_code = 404\n\n    result = Result.from_response(mock_response)\n\n    called = []\n\n    result.on_status(404, lambda req, res: called.append(\"404\"))\n          .on_status(200, lambda req, res: called.append(\"200\"))\n\n    assert \"404\" in called\n    assert \"200\" not in called\n</code></pre>"},{"location":"guides/http/result/#comparacion-con-excepciones","title":"Comparaci\u00f3n con Excepciones","text":""},{"location":"guides/http/result/#con-excepciones-tradicional","title":"Con Excepciones (tradicional)","text":"<pre><code>try:\n    response = await http.get(\"https://api.example.com/users/1\")\n    user = response.json()\nexcept httpx.TimeoutException:\n    print(\"Timeout\")\nexcept httpx.NetworkError:\n    print(\"Network error\")\nexcept Exception as e:\n    print(f\"Unknown error: {e}\")\n</code></pre>"},{"location":"guides/http/result/#con-result-r5","title":"Con Result (R5)","text":"<pre><code>result = await http.get(\"https://api.example.com/users/1\")\n\nif result.exception:\n    print(f\"Error: {result.exception}\")\nelif result.status == 404:\n    print(\"Not found\")\nelif result.status == 200:\n    user = result.to(User)\n</code></pre> <p>Beneficios de Result: - \u2705 Flujo m\u00e1s claro - \u2705 Sin try/except anidados - \u2705 F\u00e1cil composici\u00f3n - \u2705 Type-safe - \u2705 Chaining de handlers</p>"},{"location":"guides/http/result/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Overview - Visi\u00f3n general del cliente HTTP</li> <li>Basic Usage - Uso b\u00e1sico del cliente</li> <li>Advanced - Caracter\u00edsticas avanzadas</li> <li>API Reference - Documentaci\u00f3n completa</li> </ul>"},{"location":"guides/ioc/configuration/","title":"Configuration","text":"<p>El decorador <code>@config</code> simplifica la gesti\u00f3n de configuraci\u00f3n cargando valores desde archivos y variables de entorno.</p>"},{"location":"guides/ioc/configuration/#uso-basico","title":"Uso B\u00e1sico","text":"<pre><code>from R5.ioc import config\n\n@config(file='.env')\nclass AppConfig:\n    database_url: str = \"sqlite:///app.db\"\n    api_key: str = \"\"\n    debug: bool = False\n    port: int = 8000\n</code></pre> <p>El decorador: 1. Carga el archivo especificado 2. Mapea valores a los campos de la clase 3. Convierte tipos autom\u00e1ticamente 4. Permite override con variables de entorno 5. Registra la clase como Singleton en el container</p>"},{"location":"guides/ioc/configuration/#formatos-soportados","title":"Formatos Soportados","text":"<p>R5 soporta m\u00faltiples formatos de configuraci\u00f3n:</p>"},{"location":"guides/ioc/configuration/#env-variables-de-entorno","title":".env (Variables de Entorno)","text":"<pre><code># .env\nDATABASE_URL=postgresql://localhost/mydb\nAPI_KEY=secret-key-123\nDEBUG=true\nPORT=8080\nMAX_WORKERS=4\n</code></pre> <pre><code>@config(file='.env')\nclass AppConfig:\n    database_url: str\n    api_key: str\n    debug: bool\n    port: int\n    max_workers: int\n</code></pre>"},{"location":"guides/ioc/configuration/#json","title":"JSON","text":"<pre><code>{\n  \"database_url\": \"postgresql://localhost/mydb\",\n  \"api_key\": \"secret-key-123\",\n  \"debug\": true,\n  \"port\": 8080,\n  \"max_workers\": 4\n}\n</code></pre> <pre><code>@config(file='config.json')\nclass AppConfig:\n    database_url: str\n    api_key: str\n    debug: bool\n    port: int\n    max_workers: int\n</code></pre>"},{"location":"guides/ioc/configuration/#yaml","title":"YAML","text":"<pre><code>database_url: postgresql://localhost/mydb\napi_key: secret-key-123\ndebug: true\nport: 8080\nmax_workers: 4\nfeatures:\n  - auth\n  - cache\n  - logging\n</code></pre> <pre><code>@config(file='config.yml')\nclass AppConfig:\n    database_url: str\n    api_key: str\n    debug: bool\n    port: int\n    max_workers: int\n    features: list[str]\n</code></pre>"},{"location":"guides/ioc/configuration/#properties-java-style","title":"Properties (Java-style)","text":"<pre><code># config.properties\ndatabase.url=postgresql://localhost/mydb\napi.key=secret-key-123\ndebug=true\nport=8080\n</code></pre> <pre><code>@config(file='config.properties')\nclass AppConfig:\n    database_url: str  # Coincide con \"database.url\"\n    api_key: str       # Coincide con \"api.key\"\n    debug: bool\n    port: int\n</code></pre>"},{"location":"guides/ioc/configuration/#conversion-de-tipos","title":"Conversi\u00f3n de Tipos","text":"<p>R5 convierte autom\u00e1ticamente strings a los tipos correctos:</p>"},{"location":"guides/ioc/configuration/#tipos-primitivos","title":"Tipos Primitivos","text":"<pre><code>@config(file='.env')\nclass Config:\n    # String\n    app_name: str = \"MyApp\"\n\n    # Integer\n    port: int = 8000\n\n    # Float\n    timeout: float = 30.5\n\n    # Boolean (true, false, 1, 0, yes, no, on, off)\n    debug: bool = False\n</code></pre> <p>Archivo .env: <pre><code>APP_NAME=ProductionApp\nPORT=9000\nTIMEOUT=45.5\nDEBUG=true\n</code></pre></p>"},{"location":"guides/ioc/configuration/#colecciones","title":"Colecciones","text":"<pre><code>@config(file='config.json')\nclass Config:\n    # List\n    allowed_hosts: list[str] = [\"localhost\"]\n\n    # Set\n    features: set[str] = {\"auth\", \"cache\"}\n\n    # Tuple\n    coordinates: tuple[float, float] = (0.0, 0.0)\n\n    # Dict\n    metadata: dict[str, str] = {}\n</code></pre> <p>Archivo JSON: <pre><code>{\n  \"allowed_hosts\": [\"localhost\", \"example.com\", \"app.com\"],\n  \"features\": [\"auth\", \"cache\", \"logging\"],\n  \"coordinates\": [40.7128, 74.0060],\n  \"metadata\": {\n    \"version\": \"1.0\",\n    \"env\": \"production\"\n  }\n}\n</code></pre></p>"},{"location":"guides/ioc/configuration/#listas-desde-env","title":"Listas desde .env","text":"<p>En archivos .env, las listas se separan por comas:</p> <pre><code>ALLOWED_HOSTS=localhost,example.com,app.com\nFEATURES=auth,cache,logging\n</code></pre> <pre><code>@config(file='.env')\nclass Config:\n    allowed_hosts: list[str]  # [\"localhost\", \"example.com\", \"app.com\"]\n    features: list[str]        # [\"auth\", \"cache\", \"logging\"]\n</code></pre>"},{"location":"guides/ioc/configuration/#variables-de-entorno-override","title":"Variables de Entorno Override","text":"<p>Por defecto, las variables de entorno tienen prioridad sobre el archivo:</p> <pre><code>@config(file='config.json', env_override=True)\nclass AppConfig:\n    port: int = 8000\n</code></pre> <p>Prioridad (de mayor a menor): 1. Variables de entorno (ej: <code>PORT=9000</code>) 2. Archivo de configuraci\u00f3n 3. Valores por defecto en la clase</p> <p>Ejemplo: <pre><code># config.json tiene \"port\": 8080\n# Clase tiene default port: int = 8000\n\n# Sin variable de entorno\n# \u2192 port = 8080 (del archivo)\n\nexport PORT=9000\n# Con variable de entorno\n# \u2192 port = 9000 (override)\n</code></pre></p>"},{"location":"guides/ioc/configuration/#deshabilitar-override","title":"Deshabilitar override","text":"<pre><code>@config(file='config.json', env_override=False)\nclass AppConfig:\n    port: int = 8000\n</code></pre> <p>Ahora las variables de entorno se ignoran.</p>"},{"location":"guides/ioc/configuration/#case-sensitivity","title":"Case Sensitivity","text":"<p>Por defecto, las claves son case-insensitive:</p> <pre><code># .env\ndatabase_url=...\nDATABASE_URL=...\nDatabase_Url=...\n# Todas coinciden con database_url\n</code></pre> <p>Para case-sensitive:</p> <pre><code>@config(file='.env', case_sensitive=True)\nclass Config:\n    database_url: str  # Solo coincide exactamente con \"database_url\"\n</code></pre>"},{"location":"guides/ioc/configuration/#archivos-opcionales","title":"Archivos Opcionales","text":"<p>Si el archivo no existe, puedes:</p> <p>Requerir el archivo (default): <pre><code>@config(file='config.json', required=True)\nclass Config:\n    port: int = 8000\n\n# Si config.json no existe \u2192 FileNotFoundError\n</code></pre></p> <p>Hacer opcional: <pre><code>@config(file='config.json', required=False)\nclass Config:\n    port: int = 8000\n\n# Si config.json no existe \u2192 usa valores por defecto\n# Emite warning\n</code></pre></p>"},{"location":"guides/ioc/configuration/#sin-archivo","title":"Sin Archivo","text":"<p>Usa solo valores por defecto:</p> <pre><code>@config\nclass Config:\n    database_url: str = \"sqlite:///app.db\"\n    debug: bool = False\n</code></pre> <p>O con par\u00e9ntesis vac\u00edos:</p> <pre><code>@config()\nclass Config:\n    database_url: str = \"sqlite:///app.db\"\n    debug: bool = False\n</code></pre>"},{"location":"guides/ioc/configuration/#inyeccion-de-configuracion","title":"Inyecci\u00f3n de Configuraci\u00f3n","text":"<p>Una vez decorada, la configuraci\u00f3n se inyecta autom\u00e1ticamente:</p> <pre><code>from R5.ioc import inject\n\n@config(file='.env')\nclass AppConfig:\n    database_url: str\n    api_key: str\n\n@inject\nasync def main(config: AppConfig):\n    print(f\"Database: {config.database_url}\")\n    print(f\"API Key: {config.api_key}\")\n</code></pre>"},{"location":"guides/ioc/configuration/#configuracion-anidada","title":"Configuraci\u00f3n Anidada","text":"<p>Para configuraciones complejas, usa m\u00faltiples clases:</p> <pre><code>@config(file='database.json')\nclass DatabaseConfig:\n    url: str\n    pool_size: int = 10\n\n@config(file='redis.json')\nclass RedisConfig:\n    host: str = \"localhost\"\n    port: int = 6379\n\n@singleton\nclass AppConfig:\n    def __init__(self, db: DatabaseConfig, redis: RedisConfig):\n        self.database = db\n        self.redis = redis\n\n@inject\ndef use_config(config: AppConfig):\n    print(config.database.url)\n    print(config.redis.host)\n</code></pre>"},{"location":"guides/ioc/configuration/#validacion-con-pydantic","title":"Validaci\u00f3n con Pydantic","text":"<p>Combina con Pydantic para validaci\u00f3n:</p> <pre><code>from pydantic import BaseModel, field_validator\n\n@config(file='.env')\nclass AppConfig(BaseModel):\n    database_url: str\n    port: int\n\n    @field_validator('port')\n    def validate_port(cls, v):\n        if v &lt; 1 or v &gt; 65535:\n            raise ValueError('Port must be between 1 and 65535')\n        return v\n\n# Validaci\u00f3n autom\u00e1tica al crear instancia\n</code></pre>"},{"location":"guides/ioc/configuration/#valores-computados","title":"Valores Computados","text":"<p>Agrega propiedades computadas:</p> <pre><code>@config(file='.env')\nclass AppConfig:\n    host: str = \"localhost\"\n    port: int = 8000\n\n    @property\n    def base_url(self) -&gt; str:\n        return f\"http://{self.host}:{self.port}\"\n\n@inject\ndef use_config(config: AppConfig):\n    print(config.base_url)  # \"http://localhost:8000\"\n</code></pre>"},{"location":"guides/ioc/configuration/#rutas-relativas","title":"Rutas Relativas","text":"<p>Las rutas se resuelven relativas al directorio de trabajo:</p> <pre><code># Archivo en ./config/app.json\n@config(file='config/app.json')\nclass AppConfig:\n    pass\n\n# Archivo en ruta absoluta\n@config(file='/etc/myapp/config.json')\nclass AppConfig:\n    pass\n</code></pre>"},{"location":"guides/ioc/configuration/#ejemplos-completos","title":"Ejemplos Completos","text":""},{"location":"guides/ioc/configuration/#configuracion-de-aplicacion-web","title":"Configuraci\u00f3n de Aplicaci\u00f3n Web","text":"<pre><code>@config(file='.env')\nclass AppConfig:\n    # Server\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n    workers: int = 4\n\n    # Database\n    database_url: str = \"postgresql://localhost/myapp\"\n    db_pool_size: int = 10\n\n    # Redis\n    redis_host: str = \"localhost\"\n    redis_port: int = 6379\n\n    # Auth\n    secret_key: str = \"\"\n    jwt_algorithm: str = \"HS256\"\n    access_token_expire_minutes: int = 30\n\n    # Features\n    debug: bool = False\n    enable_cors: bool = True\n    allowed_origins: list[str] = [\"*\"]\n\n    @property\n    def database_url_async(self) -&gt; str:\n        return self.database_url.replace(\"postgresql://\", \"postgresql+asyncpg://\")\n</code></pre>"},{"location":"guides/ioc/configuration/#configuracion-multi-entorno","title":"Configuraci\u00f3n Multi-Entorno","text":"<pre><code>import os\n\nenv = os.getenv(\"ENV\", \"development\")\nconfig_file = f\"config.{env}.json\"\n\n@config(file=config_file)\nclass AppConfig:\n    database_url: str\n    api_key: str\n    debug: bool\n\n# Carga config.development.json, config.production.json, etc.\n</code></pre>"},{"location":"guides/ioc/configuration/#configuracion-con-secretos","title":"Configuraci\u00f3n con Secretos","text":"<pre><code># .env (commitear)\nDATABASE_HOST=localhost\nDATABASE_PORT=5432\nDATABASE_NAME=myapp\n\n# .env.local (no commitear, en .gitignore)\nDATABASE_PASSWORD=super-secret-password\nAPI_KEY=secret-api-key\n</code></pre> <pre><code># Cargar .env primero, luego .env.local\n@config(file='.env')\nclass BaseConfig:\n    database_host: str\n    database_port: int\n    database_name: str\n\n@config(file='.env.local', required=False)\nclass SecretConfig:\n    database_password: str = \"\"\n    api_key: str = \"\"\n\n@singleton\nclass AppConfig:\n    def __init__(self, base: BaseConfig, secrets: SecretConfig):\n        self.db_url = (\n            f\"postgresql://{base.database_host}:{base.database_port}\"\n            f\"/{base.database_name}\"\n        )\n        if secrets.database_password:\n            self.db_url = (\n                f\"postgresql://user:{secrets.database_password}\"\n                f\"@{base.database_host}:{base.database_port}\"\n                f\"/{base.database_name}\"\n            )\n        self.api_key = secrets.api_key\n</code></pre>"},{"location":"guides/ioc/configuration/#cache-de-configuracion","title":"Cach\u00e9 de Configuraci\u00f3n","text":"<p>R5 cachea autom\u00e1ticamente la configuraci\u00f3n cargada del archivo usando <code>@lru_cache</code>:</p> <pre><code># Primera instancia: lee archivo\nconfig1 = Container.resolve(AppConfig)\n\n# Segunda instancia: usa cach\u00e9\nconfig2 = Container.resolve(AppConfig)\n\n# Mismo archivo cacheado (Singleton + LRU cache)\n</code></pre>"},{"location":"guides/ioc/configuration/#warnings","title":"Warnings","text":""},{"location":"guides/ioc/configuration/#campo-sin-valor","title":"Campo sin valor","text":"<p>Si un campo no tiene valor en ninguna fuente:</p> <pre><code>@config(file='.env')\nclass Config:\n    required_field: str  # Sin default\n\n# Si no est\u00e1 en .env ni variables de entorno\n# \u2192 UserWarning + None\n</code></pre>"},{"location":"guides/ioc/configuration/#archivo-no-encontrado","title":"Archivo no encontrado","text":"<pre><code>@config(file='missing.json', required=False)\nclass Config:\n    port: int = 8000\n\n# UserWarning: Configuration file missing.json not found. Using default values.\n</code></pre>"},{"location":"guides/ioc/configuration/#testing","title":"Testing","text":""},{"location":"guides/ioc/configuration/#mock-de-configuracion","title":"Mock de configuraci\u00f3n","text":"<pre><code>def test_with_config():\n    Container.reset()\n\n    @config\n    class TestConfig:\n        database_url: str = \"sqlite:///:memory:\"\n        debug: bool = True\n\n    @inject\n    def handler(config: TestConfig):\n        assert config.debug\n        return config.database_url\n\n    result = handler()\n    assert result == \"sqlite:///:memory:\"\n</code></pre>"},{"location":"guides/ioc/configuration/#configuracion-temporal","title":"Configuraci\u00f3n temporal","text":"<pre><code>import tempfile\nimport json\n\ndef test_with_temp_config():\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.json') as f:\n        config_data = {\"port\": 9999, \"debug\": True}\n        json.dump(config_data, f)\n        f.flush()\n\n        @config(file=f.name)\n        class TempConfig:\n            port: int\n            debug: bool\n\n        config = Container.resolve(TempConfig)\n        assert config.port == 9999\n</code></pre>"},{"location":"guides/ioc/configuration/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Overview - Conceptos del IoC Container</li> <li>Injection - Gu\u00eda de <code>@inject</code></li> <li>Providers - Scopes y decoradores</li> <li>API Reference - Documentaci\u00f3n completa</li> </ul>"},{"location":"guides/ioc/injection/","title":"Dependency Injection","text":"<p>El decorador <code>@inject</code> es la forma principal de usar el contenedor IoC en R5.</p>"},{"location":"guides/ioc/injection/#uso-basico","title":"Uso B\u00e1sico","text":"<pre><code>from R5.ioc import singleton, inject\n\n@singleton\nclass EmailService:\n    def send(self, to: str, message: str):\n        print(f\"Sending to {to}: {message}\")\n\n@inject\ndef send_welcome_email(email_service: EmailService, user_email: str):\n    email_service.send(user_email, \"Welcome!\")\n\nsend_welcome_email(user_email=\"user@example.com\")\n</code></pre>"},{"location":"guides/ioc/injection/#como-funciona","title":"C\u00f3mo Funciona","text":"<p><code>@inject</code> analiza la firma de la funci\u00f3n y:</p> <ol> <li>Identifica par\u00e1metros con type hints</li> <li>Verifica si el tipo est\u00e1 registrado en el container</li> <li>Resuelve autom\u00e1ticamente las dependencias</li> <li>Inyecta las instancias en la llamada a la funci\u00f3n</li> </ol> <pre><code>@inject\ndef handler(\n    service_a: ServiceA,  # \u2705 Inyectado autom\u00e1ticamente\n    service_b: ServiceB,  # \u2705 Inyectado autom\u00e1ticamente\n    user_id: int,         # \u26a0\ufe0f  Par\u00e1metro normal (no registrado)\n    name: str = \"John\"    # \u26a0\ufe0f  Par\u00e1metro con default\n):\n    pass\n\n# Solo pasas los par\u00e1metros no inyectables\nhandler(user_id=123, name=\"Alice\")\n</code></pre>"},{"location":"guides/ioc/injection/#funciones-sincronas","title":"Funciones S\u00edncronas","text":"<pre><code>@singleton\nclass LogService:\n    def log(self, message: str):\n        print(f\"[LOG] {message}\")\n\n@inject\ndef process_sync(log: LogService, data: str):\n    log.log(f\"Processing: {data}\")\n    return data.upper()\n\nresult = process_sync(data=\"hello\")\n</code></pre>"},{"location":"guides/ioc/injection/#funciones-asincronas","title":"Funciones As\u00edncronas","text":"<pre><code>@singleton\nclass DatabaseService:\n    async def query(self, sql: str):\n        return [{\"id\": 1, \"name\": \"John\"}]\n\n@inject\nasync def fetch_users(db: DatabaseService):\n    users = await db.query(\"SELECT * FROM users\")\n    return users\n\nusers = await fetch_users()\n</code></pre>"},{"location":"guides/ioc/injection/#multiples-dependencias","title":"M\u00faltiples Dependencias","text":"<pre><code>@singleton\nclass CacheService:\n    def get(self, key: str):\n        return f\"cached:{key}\"\n\n@singleton\nclass LogService:\n    def log(self, msg: str):\n        print(f\"[LOG] {msg}\")\n\n@singleton\nclass EmailService:\n    def send(self, to: str):\n        print(f\"Email to {to}\")\n\n@inject\ndef complex_handler(\n    cache: CacheService,\n    log: LogService,\n    email: EmailService,\n    user_id: int\n):\n    log.log(f\"Processing user {user_id}\")\n    data = cache.get(f\"user:{user_id}\")\n    email.send(\"admin@example.com\")\n    return data\n\nresult = complex_handler(user_id=42)\n</code></pre>"},{"location":"guides/ioc/injection/#parametros-keyword-only","title":"Par\u00e1metros Keyword-Only","text":"<p>Despu\u00e9s del primer par\u00e1metro inyectable, los par\u00e1metros no inyectables se convierten en keyword-only:</p> <pre><code>@singleton\nclass MyService:\n    pass\n\n@inject\ndef handler(service: MyService, user_id: int, name: str):\n    pass\n\n# \u2705 Correcto\nhandler(user_id=1, name=\"John\")\n\n# \u274c Error: user_id y name deben ser keyword\nhandler(1, \"John\")\n</code></pre> <p>Esto previene errores de orden de argumentos.</p>"},{"location":"guides/ioc/injection/#ejemplo-del-cambio-de-signature","title":"Ejemplo del cambio de signature","text":"<pre><code>import inspect\n\n@singleton\nclass ServiceA:\n    pass\n\n@inject\ndef handler(service: ServiceA, param1: str, param2: int):\n    return (param1, param2)\n\nsig = inspect.signature(handler)\nprint(sig)\n# (service: ServiceA, *, param1: str, param2: int)\n#                      ^\n#                      Nota el asterisco: keyword-only\n</code></pre>"},{"location":"guides/ioc/injection/#dependencias-opcionales","title":"Dependencias Opcionales","text":"<p>Usa <code>Optional</code> para dependencias que pueden no estar registradas:</p> <pre><code>from typing import Optional\nfrom R5.ioc import singleton, inject\n\n@singleton\nclass CacheService:\n    pass\n\n@inject\ndef handler(\n    cache: Optional[CacheService],\n    data: str\n):\n    if cache:\n        cache.set(\"key\", data)\n    return data\n\n# Funciona incluso si CacheService no est\u00e1 registrado\nhandler(data=\"test\")\n</code></pre>"},{"location":"guides/ioc/injection/#inyeccion-en-metodos-de-clase","title":"Inyecci\u00f3n en M\u00e9todos de Clase","text":"<pre><code>@singleton\nclass EmailService:\n    def send(self, to: str):\n        print(f\"Email to {to}\")\n\nclass UserController:\n    @inject\n    def create_user(self, email_service: EmailService, username: str):\n        email_service.send(\"admin@example.com\")\n        return f\"Created user: {username}\"\n\ncontroller = UserController()\nresult = controller.create_user(username=\"john_doe\")\n</code></pre>"},{"location":"guides/ioc/injection/#inyeccion-en-constructores","title":"Inyecci\u00f3n en Constructores","text":"<p>Para inyectar en <code>__init__</code>, usa el decorador en la clase:</p> <pre><code>@singleton\nclass LogService:\n    def log(self, msg: str):\n        print(msg)\n\n@singleton\nclass UserService:\n    def __init__(self, log: LogService):\n        self.log = log\n\n    def create_user(self, name: str):\n        self.log.log(f\"Creating user: {name}\")\n\n# R5 inyecta LogService autom\u00e1ticamente en __init__\nuser_service = Container.resolve(UserService)\nuser_service.create_user(\"John\")\n</code></pre>"},{"location":"guides/ioc/injection/#inyeccion-anidada","title":"Inyecci\u00f3n Anidada","text":"<p>Las dependencias pueden tener sus propias dependencias:</p> <pre><code>@singleton\nclass Logger:\n    def log(self, msg: str):\n        print(msg)\n\n@singleton\nclass Cache:\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n@singleton\nclass UserRepository:\n    def __init__(self, cache: Cache, logger: Logger):\n        self.cache = cache\n        self.logger = logger\n\n@inject\ndef get_user(repo: UserRepository, user_id: int):\n    return repo.find(user_id)\n\n# R5 resuelve toda la cadena: UserRepository -&gt; Cache -&gt; Logger\nuser = get_user(user_id=1)\n</code></pre>"},{"location":"guides/ioc/injection/#scope-mixing","title":"Scope Mixing","text":"<p>Puedes mezclar diferentes scopes:</p> <pre><code>@singleton\nclass ConfigService:\n    pass\n\n@factory\nclass RequestContext:\n    def __init__(self):\n        self.id = uuid4()\n\n@inject\ndef handle_request(\n    config: ConfigService,      # Singleton\n    context: RequestContext,    # Factory (nueva instancia)\n    data: str\n):\n    print(f\"Request {context.id}\")\n    return data\n\n# Cada llamada recibe el mismo config pero nuevo context\nhandle_request(data=\"test1\")\nhandle_request(data=\"test2\")\n</code></pre>"},{"location":"guides/ioc/injection/#resource-injection","title":"Resource Injection","text":"<p>Cuando inyectas un <code>@resource</code>, R5 gestiona autom\u00e1ticamente el lifecycle:</p> <pre><code>@resource\nclass DatabaseSession:\n    async def __aenter__(self):\n        print(\"Opening DB session\")\n        self.session = create_session()\n        return self\n\n    async def __aexit__(self, *args):\n        print(\"Closing DB session\")\n        await self.session.close()\n\n@inject\nasync def query_users(db: DatabaseSession):\n    # db ya est\u00e1 en estado __aenter__\n    users = await db.session.query(\"SELECT * FROM users\")\n    return users\n    # Al salir, se llama __aexit__ autom\u00e1ticamente\n\nusers = await query_users()\n</code></pre>"},{"location":"guides/ioc/injection/#errores-comunes","title":"Errores Comunes","text":""},{"location":"guides/ioc/injection/#1-tipo-no-registrado","title":"1. Tipo no registrado","text":"<pre><code>class UnregisteredService:\n    pass\n\n@inject\ndef handler(service: UnregisteredService):\n    pass\n\n# \u274c ProviderNotFoundError\nhandler()\n</code></pre> <p>Soluci\u00f3n: Registra el servicio con <code>@singleton</code>, <code>@factory</code> o <code>@resource</code>.</p>"},{"location":"guides/ioc/injection/#2-dependencia-circular","title":"2. Dependencia circular","text":"<pre><code>@singleton\nclass ServiceA:\n    def __init__(self, service_b: 'ServiceB'):\n        pass\n\n@singleton\nclass ServiceB:\n    def __init__(self, service_a: ServiceA):\n        pass\n\n# \u274c CircularDependencyError\nContainer.resolve(ServiceA)\n</code></pre> <p>Soluci\u00f3n: Refactoriza para eliminar el ciclo o usa lazy loading.</p>"},{"location":"guides/ioc/injection/#3-type-hint-faltante","title":"3. Type hint faltante","text":"<pre><code>@singleton\nclass MyService:\n    pass\n\n@inject\ndef handler(service):  # \u274c Sin type hint\n    pass\n</code></pre> <p>Soluci\u00f3n: Agrega type hints:</p> <pre><code>@inject\ndef handler(service: MyService):  # \u2705\n    pass\n</code></pre>"},{"location":"guides/ioc/injection/#4-mezclar-posicional-y-keyword","title":"4. Mezclar posicional y keyword","text":"<pre><code>@singleton\nclass MyService:\n    pass\n\n@inject\ndef handler(service: MyService, user_id: int):\n    pass\n\n# \u274c Error: user_id debe ser keyword-only\nhandler(123)\n\n# \u2705 Correcto\nhandler(user_id=123)\n</code></pre>"},{"location":"guides/ioc/injection/#patterns-avanzados","title":"Patterns Avanzados","text":""},{"location":"guides/ioc/injection/#conditional-injection","title":"Conditional Injection","text":"<pre><code>from typing import Optional\n\n@inject\ndef handler(cache: Optional[CacheService], data: str):\n    if cache:\n        return cache.get(data)\n    return fetch_from_db(data)\n</code></pre>"},{"location":"guides/ioc/injection/#multiple-implementations","title":"Multiple Implementations","text":"<pre><code>@singleton\nclass PostgresRepository:\n    pass\n\n@singleton\nclass MongoRepository:\n    pass\n\n# Registrar alias seg\u00fan configuraci\u00f3n\nif config.database == \"postgres\":\n    Container.alias_provider(IRepository, PostgresRepository)\nelse:\n    Container.alias_provider(IRepository, MongoRepository)\n\n@inject\ndef get_data(repo: IRepository):\n    return repo.find_all()\n</code></pre>"},{"location":"guides/ioc/injection/#partial-injection","title":"Partial Injection","text":"<pre><code>@singleton\nclass EmailService:\n    pass\n\n@inject\ndef send_email(\n    email_service: EmailService,\n    to: str,\n    subject: str,\n    body: str\n):\n    email_service.send(to, subject, body)\n\n# Crear funci\u00f3n parcial\nfrom functools import partial\nsend_welcome = partial(\n    send_email,\n    subject=\"Welcome!\",\n    body=\"Thanks for joining\"\n)\n\n# Usar\nsend_welcome(to=\"user@example.com\")\n</code></pre>"},{"location":"guides/ioc/injection/#testing","title":"Testing","text":""},{"location":"guides/ioc/injection/#mock-dependencies","title":"Mock Dependencies","text":"<pre><code>import pytest\nfrom R5.ioc import Container, Scope\n\n@singleton\nclass EmailService:\n    def send(self, to: str):\n        # Real implementation\n        pass\n\ndef test_handler():\n    Container.reset()\n\n    # Mock service\n    class MockEmailService:\n        def send(self, to: str):\n            print(f\"Mock: sending to {to}\")\n\n    Container.registry_provider(MockEmailService, Scope.SINGLETON)\n    Container.alias_provider(EmailService, MockEmailService)\n\n    @inject\n    def handler(email: EmailService):\n        email.send(\"test@example.com\")\n\n    handler()  # Usa MockEmailService\n</code></pre>"},{"location":"guides/ioc/injection/#fixture-con-dependencias","title":"Fixture con dependencias","text":"<pre><code>@pytest.fixture\ndef clean_container():\n    snapshot = Container.snapshot()\n    yield\n    Container.restore(snapshot)\n\ndef test_with_clean_container(clean_container):\n    @singleton\n    class TestService:\n        pass\n\n    # Test logic...\n</code></pre>"},{"location":"guides/ioc/injection/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Providers - Decoradores de scope</li> <li>Configuration - Sistema de configuraci\u00f3n</li> <li>API Reference - Documentaci\u00f3n completa de la API</li> </ul>"},{"location":"guides/ioc/overview/","title":"IoC Container - Overview","text":"<p>El contenedor de Inversi\u00f3n de Control (IoC) es el coraz\u00f3n de R5, proporcionando inyecci\u00f3n de dependencias autom\u00e1tica y type-safe.</p>"},{"location":"guides/ioc/overview/#que-es-ioc","title":"\u00bfQu\u00e9 es IoC?","text":"<p>Inversi\u00f3n de Control (IoC) es un patr\u00f3n de dise\u00f1o donde el control del flujo de la aplicaci\u00f3n se invierte: en lugar de que tu c\u00f3digo cree y gestione dependencias manualmente, el framework lo hace por ti.</p>"},{"location":"guides/ioc/overview/#beneficios","title":"Beneficios","text":""},{"location":"guides/ioc/overview/#codigo-mas-limpio","title":"\u2705 C\u00f3digo m\u00e1s limpio","text":"<p>Sin IoC: <pre><code>class UserService:\n    def __init__(self):\n        self.db = DatabaseConnection()\n        self.cache = CacheService()\n        self.logger = Logger()\n\nclass OrderService:\n    def __init__(self):\n        self.user_service = UserService()\n        self.email = EmailService()\n</code></pre></p> <p>Con IoC: <pre><code>@singleton\nclass UserService:\n    def __init__(self, db: DatabaseConnection, cache: CacheService, logger: Logger):\n        self.db = db\n        self.cache = cache\n        self.logger = logger\n\n@singleton\nclass OrderService:\n    def __init__(self, user_service: UserService, email: EmailService):\n        self.user_service = user_service\n        self.email = email\n</code></pre></p>"},{"location":"guides/ioc/overview/#testing-mas-facil","title":"\u2705 Testing m\u00e1s f\u00e1cil","text":"<pre><code>@inject\nasync def process_order(order_service: OrderService):\n    await order_service.create_order(...)\n\n# En tests, puedes reemplazar las dependencias\nContainer.reset()\nContainer.registry_provider(MockOrderService, Scope.SINGLETON)\nContainer.alias_provider(OrderService, MockOrderService)\n</code></pre>"},{"location":"guides/ioc/overview/#type-safe","title":"\u2705 Type-safe","text":"<p>El container usa type hints para resoluci\u00f3n autom\u00e1tica:</p> <pre><code>@inject\ndef handler(\n    service: UserService,  # Resuelto autom\u00e1ticamente\n    cache: CacheService,   # Resuelto autom\u00e1ticamente\n    user_id: int           # Par\u00e1metro manual\n):\n    pass\n\nhandler(user_id=123)  # Solo pasas lo que no es inyectable\n</code></pre>"},{"location":"guides/ioc/overview/#componentes-principales","title":"Componentes Principales","text":""},{"location":"guides/ioc/overview/#1-container","title":"1. Container","text":"<p>El contenedor central que almacena y resuelve dependencias:</p> <pre><code>from R5.ioc import Container, Scope\n\n# Registrar proveedor manualmente\nContainer.registry_provider(MyService, Scope.SINGLETON)\n\n# Verificar si existe\nif Container.in_provider(MyService):\n    print(\"MyService est\u00e1 registrado\")\n\n# Resolver instancia\ninstance = Container.resolve(MyService)\n\n# Obtener provider\nprovider = Container.get_provider(MyService)\n\n# Crear alias\nContainer.alias_provider(IMyService, MyService)\n</code></pre>"},{"location":"guides/ioc/overview/#2-decoradores-de-scope","title":"2. Decoradores de Scope","text":"<p>R5 proporciona decoradores para registrar servicios:</p> <pre><code>from R5.ioc import singleton, factory, resource\n\n@singleton\nclass DatabaseConnection:\n    pass\n\n@factory\nclass Request:\n    pass\n\n@resource\nclass FileHandler:\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self, *args):\n        pass\n</code></pre>"},{"location":"guides/ioc/overview/#3-inyeccion","title":"3. Inyecci\u00f3n","text":"<p>El decorador <code>@inject</code> inyecta dependencias autom\u00e1ticamente:</p> <pre><code>from R5.ioc import inject\n\n@inject\nasync def handler(\n    db: DatabaseConnection,\n    cache: CacheService,\n    user_id: int  # No se inyecta, es par\u00e1metro normal\n):\n    user = await db.find(user_id)\n    cache.set(f\"user:{user_id}\", user)\n\nawait handler(user_id=123)\n</code></pre>"},{"location":"guides/ioc/overview/#4-configuration","title":"4. Configuration","text":"<p>Carga configuraci\u00f3n desde archivos:</p> <pre><code>from R5.ioc import config\n\n@config(file='config.json')\nclass AppConfig:\n    database_url: str = \"sqlite:///db.sqlite\"\n    api_key: str = \"\"\n    debug: bool = False\n</code></pre>"},{"location":"guides/ioc/overview/#scopes-alcances","title":"Scopes (Alcances)","text":""},{"location":"guides/ioc/overview/#singleton","title":"Singleton","text":"<p>Una \u00fanica instancia compartida en toda la aplicaci\u00f3n:</p> <pre><code>@singleton\nclass DatabaseConnection:\n    def __init__(self):\n        print(\"Creating DB connection\")\n        self.conn = create_connection()\n\n# Primera llamada: crea instancia\ndb1 = Container.resolve(DatabaseConnection)  # \"Creating DB connection\"\n\n# Segunda llamada: retorna misma instancia\ndb2 = Container.resolve(DatabaseConnection)  # No print\n\nassert db1 is db2  # True\n</code></pre> <p>Casos de uso: - Conexiones a base de datos - Configuraci\u00f3n - Servicios sin estado - Cach\u00e9 compartida</p>"},{"location":"guides/ioc/overview/#factory","title":"Factory","text":"<p>Nueva instancia en cada resoluci\u00f3n:</p> <pre><code>@factory\nclass Request:\n    def __init__(self):\n        self.id = uuid4()\n        self.timestamp = datetime.now()\n\nreq1 = Container.resolve(Request)\nreq2 = Container.resolve(Request)\n\nassert req1 is not req2  # True\nassert req1.id != req2.id  # True\n</code></pre> <p>Casos de uso: - Objetos con estado mutable - Request contexts - Objetos temporales</p>"},{"location":"guides/ioc/overview/#resource","title":"Resource","text":"<p>Instancia con lifecycle management (context manager):</p> <pre><code>@resource\nclass FileHandler:\n    async def __aenter__(self):\n        print(\"Opening file\")\n        self.file = open(\"data.txt\", \"w\")\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        print(\"Closing file\")\n        self.file.close()\n\n@inject\nasync def write_data(handler: FileHandler):\n    # handler ya est\u00e1 en contexto __aenter__\n    handler.file.write(\"data\")\n    # Al salir de la funci\u00f3n, se llama __aexit__\n</code></pre> <p>Casos de uso: - Archivos - Conexiones de red - Sesiones de base de datos - Recursos que requieren cleanup</p>"},{"location":"guides/ioc/overview/#resolucion-de-dependencias","title":"Resoluci\u00f3n de Dependencias","text":""},{"location":"guides/ioc/overview/#automatica","title":"Autom\u00e1tica","text":"<pre><code>@singleton\nclass ServiceA:\n    pass\n\n@singleton\nclass ServiceB:\n    def __init__(self, service_a: ServiceA):\n        self.service_a = service_a\n\n# ServiceB autom\u00e1ticamente recibe ServiceA\ninstance = Container.resolve(ServiceB)\nassert isinstance(instance.service_a, ServiceA)\n</code></pre>"},{"location":"guides/ioc/overview/#cadena-de-dependencias","title":"Cadena de Dependencias","text":"<pre><code>@singleton\nclass Logger:\n    pass\n\n@singleton\nclass Cache:\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n@singleton\nclass UserService:\n    def __init__(self, cache: Cache, logger: Logger):\n        self.cache = cache\n        self.logger = logger\n\n# Resuelve toda la cadena\nuser_service = Container.resolve(UserService)\n# UserService -&gt; Cache -&gt; Logger\n# UserService -&gt; Logger\n</code></pre>"},{"location":"guides/ioc/overview/#deteccion-de-ciclos","title":"Detecci\u00f3n de Ciclos","text":"<p>R5 detecta dependencias circulares:</p> <pre><code>@singleton\nclass ServiceA:\n    def __init__(self, service_b: 'ServiceB'):\n        pass\n\n@singleton\nclass ServiceB:\n    def __init__(self, service_a: ServiceA):\n        pass\n\n# Lanza CircularDependencyError\nContainer.resolve(ServiceA)\n</code></pre>"},{"location":"guides/ioc/overview/#gestion-del-container","title":"Gesti\u00f3n del Container","text":""},{"location":"guides/ioc/overview/#reset","title":"Reset","text":"<p>Limpia todo el container:</p> <pre><code>Container.reset()\n</code></pre> <p>\u00datil en tests:</p> <pre><code>def test_my_service():\n    Container.reset()\n\n    @singleton\n    class MockService:\n        pass\n\n    # Tests...\n</code></pre>"},{"location":"guides/ioc/overview/#snapshot-restore","title":"Snapshot &amp; Restore","text":"<p>Guarda y restaura el estado del container:</p> <pre><code># Guardar estado actual\nsnapshot = Container.snapshot()\n\n# Hacer cambios\n@singleton\nclass NewService:\n    pass\n\n# Restaurar estado anterior\nContainer.restore(snapshot)\n</code></pre>"},{"location":"guides/ioc/overview/#alias","title":"Alias","text":"<p>Crea alias para implementaciones concretas:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    def find(self, user_id: int):\n        pass\n\n@singleton\nclass PostgresUserRepository(IUserRepository):\n    def find(self, user_id: int):\n        return f\"User from Postgres: {user_id}\"\n\n# Registrar alias\nContainer.alias_provider(IUserRepository, PostgresUserRepository)\n\n# Usar interfaz\n@inject\ndef get_user(repo: IUserRepository, user_id: int):\n    return repo.find(user_id)\n\nresult = get_user(user_id=1)\n</code></pre>"},{"location":"guides/ioc/overview/#debugging","title":"Debugging","text":""},{"location":"guides/ioc/overview/#ver-providers-registrados","title":"Ver providers registrados","text":"<pre><code>container = Container.get_container()\nfor provider_type, provider in container.items():\n    print(f\"{provider_type.__name__}: {provider}\")\n</code></pre>"},{"location":"guides/ioc/overview/#verificar-si-existe","title":"Verificar si existe","text":"<pre><code>if Container.in_provider(MyService):\n    print(\"MyService est\u00e1 registrado\")\nelse:\n    print(\"MyService NO est\u00e1 registrado\")\n</code></pre>"},{"location":"guides/ioc/overview/#manejo-de-errores","title":"Manejo de errores","text":"<pre><code>from R5.ioc.errors import ProviderNotFoundError, CircularDependencyError\n\ntry:\n    instance = Container.resolve(UnknownService)\nexcept ProviderNotFoundError as e:\n    print(f\"Provider not found: {e.provider_type}\")\n    print(f\"Available: {e.available_providers}\")\n\ntry:\n    instance = Container.resolve(CircularService)\nexcept CircularDependencyError as e:\n    print(f\"Circular dependency: {e.dependency_chain}\")\n</code></pre>"},{"location":"guides/ioc/overview/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Dependency Injection - Gu\u00eda completa de <code>@inject</code></li> <li>Providers - Scopes y decoradores</li> <li>Configuration - Sistema de configuraci\u00f3n</li> </ul>"},{"location":"guides/ioc/providers/","title":"Providers y Scopes","text":"<p>Los providers determinan c\u00f3mo y cu\u00e1ndo se crean las instancias de tus servicios.</p>"},{"location":"guides/ioc/providers/#scopes-disponibles","title":"Scopes Disponibles","text":"<p>R5 proporciona tres scopes:</p> Scope Decorator Comportamiento Uso t\u00edpico Singleton <code>@singleton</code> Una instancia compartida Servicios sin estado, configuraci\u00f3n Factory <code>@factory</code> Nueva instancia cada vez Objetos con estado mutable Resource <code>@resource</code> Instancia con lifecycle Conexiones, archivos, recursos"},{"location":"guides/ioc/providers/#singleton","title":"Singleton","text":""},{"location":"guides/ioc/providers/#concepto","title":"Concepto","text":"<p>Una \u00fanica instancia que se comparte en toda la aplicaci\u00f3n.</p> <pre><code>from R5.ioc import singleton, Container\n\n@singleton\nclass ConfigService:\n    def __init__(self):\n        print(\"ConfigService created\")\n        self.settings = load_settings()\n\n# Primera resoluci\u00f3n: crea la instancia\nconfig1 = Container.resolve(ConfigService)  # \"ConfigService created\"\n\n# Siguientes resoluciones: retorna la misma instancia\nconfig2 = Container.resolve(ConfigService)  # No print\nconfig3 = Container.resolve(ConfigService)  # No print\n\nassert config1 is config2 is config3  # True\n</code></pre>"},{"location":"guides/ioc/providers/#cuando-usar-singleton","title":"Cu\u00e1ndo usar Singleton","text":"<p>\u2705 Usar cuando: - El servicio no tiene estado mutable - Quieres compartir una instancia entre toda la app - El servicio es costoso de crear (conexiones, parsers) - Necesitas consistencia (configuraci\u00f3n, cach\u00e9)</p> <p>\u274c No usar cuando: - El objeto tiene estado que cambia entre requests - Necesitas instancias independientes - El objeto debe ser garbage collected</p>"},{"location":"guides/ioc/providers/#ejemplos","title":"Ejemplos","text":"<p>Configuraci\u00f3n: <pre><code>@singleton\nclass AppConfig:\n    def __init__(self):\n        self.database_url = os.getenv(\"DATABASE_URL\")\n        self.api_key = os.getenv(\"API_KEY\")\n</code></pre></p> <p>Logger: <pre><code>@singleton\nclass Logger:\n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n\n    def info(self, message: str):\n        self.logger.info(message)\n</code></pre></p> <p>Cach\u00e9: <pre><code>@singleton\nclass CacheService:\n    def __init__(self):\n        self._cache: dict[str, Any] = {}\n\n    def get(self, key: str) -&gt; Any:\n        return self._cache.get(key)\n\n    def set(self, key: str, value: Any):\n        self._cache[key] = value\n</code></pre></p> <p>Service Layer: <pre><code>@singleton\nclass UserRepository:\n    def find(self, user_id: int):\n        return query_db(f\"SELECT * FROM users WHERE id = {user_id}\")\n\n@singleton\nclass UserService:\n    def __init__(self, repo: UserRepository):\n        self.repo = repo\n\n    def get_user(self, user_id: int):\n        return self.repo.find(user_id)\n</code></pre></p>"},{"location":"guides/ioc/providers/#factory","title":"Factory","text":""},{"location":"guides/ioc/providers/#concepto_1","title":"Concepto","text":"<p>Crea una nueva instancia en cada resoluci\u00f3n.</p> <pre><code>from R5.ioc import factory, Container\nfrom datetime import datetime\nfrom uuid import uuid4\n\n@factory\nclass RequestContext:\n    def __init__(self):\n        self.id = uuid4()\n        self.timestamp = datetime.now()\n\nctx1 = Container.resolve(RequestContext)\nctx2 = Container.resolve(RequestContext)\n\nassert ctx1 is not ctx2  # True\nassert ctx1.id != ctx2.id  # True\n</code></pre>"},{"location":"guides/ioc/providers/#cuando-usar-factory","title":"Cu\u00e1ndo usar Factory","text":"<p>\u2705 Usar cuando: - Cada instancia debe ser independiente - El objeto tiene estado mutable - Necesitas valores \u00fanicos (IDs, timestamps) - El objeto representa una operaci\u00f3n o transacci\u00f3n</p> <p>\u274c No usar cuando: - Quieres compartir estado - La creaci\u00f3n es muy costosa - No hay raz\u00f3n para m\u00faltiples instancias</p>"},{"location":"guides/ioc/providers/#ejemplos_1","title":"Ejemplos","text":"<p>Request Context: <pre><code>@factory\nclass RequestContext:\n    def __init__(self):\n        self.request_id = uuid4()\n        self.user_id: Optional[int] = None\n        self.metadata: dict[str, Any] = {}\n</code></pre></p> <p>Command Objects: <pre><code>@factory\nclass CreateUserCommand:\n    def __init__(self):\n        self.username: str = \"\"\n        self.email: str = \"\"\n        self.timestamp = datetime.now()\n\n    def execute(self):\n        # Create user logic\n        pass\n</code></pre></p> <p>DTOs (Data Transfer Objects): <pre><code>@factory\nclass UserDTO:\n    def __init__(self):\n        self.id: int = 0\n        self.name: str = \"\"\n        self.email: str = \"\"\n</code></pre></p> <p>Builders: <pre><code>@factory\nclass QueryBuilder:\n    def __init__(self):\n        self.query = \"\"\n        self.params: list[Any] = []\n\n    def where(self, condition: str, *params):\n        self.query += f\" WHERE {condition}\"\n        self.params.extend(params)\n        return self\n\n    def build(self):\n        return (self.query, self.params)\n</code></pre></p>"},{"location":"guides/ioc/providers/#resource","title":"Resource","text":""},{"location":"guides/ioc/providers/#concepto_2","title":"Concepto","text":"<p>Instancia con lifecycle management usando async context manager.</p> <pre><code>from R5.ioc import resource\n\n@resource\nclass DatabaseConnection:\n    async def __aenter__(self):\n        print(\"Opening connection\")\n        self.conn = await create_connection()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        print(\"Closing connection\")\n        await self.conn.close()\n\n@inject\nasync def query_users(db: DatabaseConnection):\n    # db ya est\u00e1 en estado __aenter__\n    users = await db.conn.query(\"SELECT * FROM users\")\n    return users\n    # Al salir, se llama __aexit__ autom\u00e1ticamente\n</code></pre>"},{"location":"guides/ioc/providers/#cuando-usar-resource","title":"Cu\u00e1ndo usar Resource","text":"<p>\u2705 Usar cuando: - El objeto necesita inicializaci\u00f3n as\u00edncrona - Requiere cleanup al terminar (close, dispose) - Gestiona recursos del sistema (archivos, conexiones) - Debe garantizar liberaci\u00f3n de recursos</p> <p>\u274c No usar cuando: - No hay recursos que liberar - La inicializaci\u00f3n es s\u00edncrona - No necesitas async context manager</p>"},{"location":"guides/ioc/providers/#ejemplos_2","title":"Ejemplos","text":"<p>Database Session: <pre><code>@resource\nclass DatabaseSession:\n    async def __aenter__(self):\n        self.session = await create_async_session()\n        await self.session.begin()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            await self.session.rollback()\n        else:\n            await self.session.commit()\n        await self.session.close()\n\n@inject\nasync def create_user(db: DatabaseSession, username: str):\n    user = User(username=username)\n    await db.session.add(user)\n    # Commit autom\u00e1tico al salir\n</code></pre></p> <p>File Handler: <pre><code>@resource\nclass FileHandler:\n    def __init__(self, filename: str = \"data.txt\"):\n        self.filename = filename\n        self.file = None\n\n    async def __aenter__(self):\n        self.file = open(self.filename, \"w\")\n        return self\n\n    async def __aexit__(self, *args):\n        if self.file:\n            self.file.close()\n\n@inject\nasync def write_logs(handler: FileHandler):\n    handler.file.write(\"Log entry\\n\")\n</code></pre></p> <p>HTTP Client: <pre><code>@resource\nclass ApiClient:\n    async def __aenter__(self):\n        self.client = httpx.AsyncClient()\n        return self\n\n    async def __aexit__(self, *args):\n        await self.client.aclose()\n\n    async def get(self, url: str):\n        return await self.client.get(url)\n\n@inject\nasync def fetch_data(api: ApiClient):\n    response = await api.get(\"https://api.example.com/data\")\n    return response.json()\n</code></pre></p>"},{"location":"guides/ioc/providers/#decorador-component","title":"Decorador <code>component</code>","text":"<p>Para casos avanzados, usa <code>component</code> directamente:</p> <pre><code>from R5.ioc import component, Scope\n\n@component(scope=Scope.SINGLETON)\nclass MyService:\n    pass\n\n@component(scope=Scope.FACTORY)\nclass MyFactory:\n    pass\n\n@component(scope=Scope.RESOURCE)\nclass MyResource:\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self, *args):\n        pass\n</code></pre>"},{"location":"guides/ioc/providers/#registro-manual","title":"Registro Manual","text":"<p>Para casos donde no puedes usar decoradores:</p> <pre><code>from R5.ioc import Container, Scope\n\nclass ThirdPartyService:\n    pass\n\n# Registrar manualmente\nContainer.registry_provider(ThirdPartyService, Scope.SINGLETON)\n\n# Ahora se puede inyectar\n@inject\ndef handler(service: ThirdPartyService):\n    pass\n</code></pre>"},{"location":"guides/ioc/providers/#scope-con-dependencias","title":"Scope con Dependencias","text":"<p>Los scopes se aplican al servicio, no a sus dependencias:</p> <pre><code>@singleton\nclass Logger:\n    pass\n\n@factory\nclass Request:\n    def __init__(self, logger: Logger):\n        self.logger = logger  # Singleton inyectado\n        self.id = uuid4()\n\n# Cada Request es nueva instancia\nreq1 = Container.resolve(Request)\nreq2 = Container.resolve(Request)\n\n# Pero comparten el mismo Logger\nassert req1.logger is req2.logger  # True\nassert req1 is not req2  # True\n</code></pre>"},{"location":"guides/ioc/providers/#warnings-de-sobreescritura","title":"Warnings de Sobreescritura","text":"<p>Si registras el mismo tipo dos veces, R5 emite un warning:</p> <pre><code>@singleton\nclass MyService:\n    pass\n\n# Segunda vez - Warning!\n@singleton\nclass MyService:  # UserWarning: Provider for type 'MyService' is being overwritten\n    pass\n</code></pre> <p>\u00datil para detectar duplicados accidentales.</p>"},{"location":"guides/ioc/providers/#comparacion-de-scopes","title":"Comparaci\u00f3n de Scopes","text":"<pre><code>from uuid import uuid4\n\n@singleton\nclass SingletonService:\n    def __init__(self):\n        self.id = uuid4()\n\n@factory\nclass FactoryService:\n    def __init__(self):\n        self.id = uuid4()\n\n# Singleton: mismo ID\ns1 = Container.resolve(SingletonService)\ns2 = Container.resolve(SingletonService)\nassert s1.id == s2.id\n\n# Factory: diferentes IDs\nf1 = Container.resolve(FactoryService)\nf2 = Container.resolve(FactoryService)\nassert f1.id != f2.id\n</code></pre>"},{"location":"guides/ioc/providers/#patrones-avanzados","title":"Patrones Avanzados","text":""},{"location":"guides/ioc/providers/#lazy-singleton","title":"Lazy Singleton","text":"<pre><code>@singleton\nclass HeavyService:\n    _instance = None\n\n    def __init__(self):\n        if HeavyService._instance is None:\n            print(\"Initializing heavy service...\")\n            # Operaciones costosas\n            HeavyService._instance = self\n\n# No se crea hasta que se resuelve\nservice = Container.resolve(HeavyService)\n</code></pre>"},{"location":"guides/ioc/providers/#factory-con-configuracion","title":"Factory con Configuraci\u00f3n","text":"<pre><code>@singleton\nclass Config:\n    def __init__(self):\n        self.max_retries = 3\n\n@factory\nclass RetryHandler:\n    def __init__(self, config: Config):\n        self.max_retries = config.max_retries\n        self.attempts = 0\n\n# Cada RetryHandler recibe config singleton\nhandler = Container.resolve(RetryHandler)\n</code></pre>"},{"location":"guides/ioc/providers/#resource-pool","title":"Resource Pool","text":"<pre><code>@resource\nclass ConnectionPool:\n    async def __aenter__(self):\n        self.pool = await create_pool(size=10)\n        return self\n\n    async def __aexit__(self, *args):\n        await self.pool.close()\n\n    async def acquire(self):\n        return await self.pool.acquire()\n</code></pre>"},{"location":"guides/ioc/providers/#testing-con-scopes","title":"Testing con Scopes","text":""},{"location":"guides/ioc/providers/#mock-singleton","title":"Mock Singleton","text":"<pre><code>def test_service():\n    Container.reset()\n\n    @singleton\n    class MockLogger:\n        def log(self, msg):\n            print(f\"MOCK: {msg}\")\n\n    Container.alias_provider(Logger, MockLogger)\n\n    # Tests usan MockLogger\n</code></pre>"},{"location":"guides/ioc/providers/#factory-para-tests","title":"Factory para Tests","text":"<pre><code>@factory\nclass TestContext:\n    def __init__(self):\n        self.user_id = 999\n        self.is_test = True\n\n# Cada test obtiene nuevo contexto\ndef test_feature_1():\n    ctx = Container.resolve(TestContext)\n    assert ctx.is_test\n</code></pre>"},{"location":"guides/ioc/providers/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Configuration - Sistema de configuraci\u00f3n</li> <li>Injection - Gu\u00eda de <code>@inject</code></li> <li>API Reference - Documentaci\u00f3n completa</li> </ul>"}]}