{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"R5 Framework","text":"<p>Framework moderno de Python con Inyecci\u00f3n de Dependencias, Cliente HTTP y Tareas en Background</p> <p> </p>"},{"location":"#que-es-r5","title":"\u00bfQu\u00e9 es R5?","text":"<p>R5 es un framework ligero y modular para Python que proporciona tres componentes fundamentales:</p> <ul> <li>\ud83d\udd0c IoC Container - Inyecci\u00f3n de dependencias autom\u00e1tica y type-safe</li> <li>\ud83c\udf10 HTTP Client - Cliente HTTP as\u00edncrono con pooling, retry y Result pattern</li> <li>\u26a1 Background Tasks - Sistema de ejecuci\u00f3n de tareas concurrentes con anyio</li> </ul>"},{"location":"#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"#inyeccion-de-dependencias-simple","title":"\u2728 Inyecci\u00f3n de Dependencias Simple","text":"<pre><code>from R5.ioc import singleton, inject\n\n@singleton\nclass UserService:\n    def get_user(self, user_id: int):\n        return {\"id\": user_id, \"name\": \"John\"}\n\n@inject\nasync def process_user(service: UserService, user_id: int):\n    return service.get_user(user_id)\n\nuser = await process_user(user_id=1)\n</code></pre>"},{"location":"#cliente-http-poderoso","title":"\ud83d\ude80 Cliente HTTP Poderoso","text":"<pre><code>from R5.http import Http\nfrom R5.ioc import inject\n\n@inject\nasync def fetch_data(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n    user = result.to(UserDTO)\n    return user\n</code></pre>"},{"location":"#background-tasks-integradas","title":"\ud83d\udd04 Background Tasks Integradas","text":"<pre><code>from R5.background import Background\nfrom R5.ioc import inject\n\n@inject\nasync def queue_tasks(bg: Background):\n    await bg.add(send_email, \"user@example.com\")\n    await bg.add(process_payment, payment_id)\n    await bg.add(update_cache, cache_key)\n</code></pre>"},{"location":"#por-que-r5","title":"\u00bfPor qu\u00e9 R5?","text":""},{"location":"#simple-y-directo","title":"\ud83c\udfaf Simple y Directo","text":"<p>Sin configuraci\u00f3n complicada. Usa decoradores simples como <code>@singleton</code>, <code>@inject</code> y empieza a trabajar inmediatamente.</p>"},{"location":"#type-safe","title":"\ud83d\udd12 Type-Safe","text":"<p>Aprovecha el sistema de tipos de Python para inyecci\u00f3n autom\u00e1tica y detecci\u00f3n temprana de errores.</p>"},{"location":"#alto-rendimiento","title":"\u26a1 Alto Rendimiento","text":"<ul> <li>Connection pooling autom\u00e1tico en HTTP client</li> <li>Tareas concurrentes con anyio</li> <li>Recursos gestionados con context managers</li> </ul>"},{"location":"#modular","title":"\ud83e\udde9 Modular","text":"<p>Usa solo lo que necesitas. Cada m\u00f3dulo funciona independientemente:</p> <ul> <li><code>R5.ioc</code> - Container e inyecci\u00f3n</li> <li><code>R5.http</code> - Cliente HTTP</li> <li><code>R5.background</code> - Tareas background</li> </ul>"},{"location":"#patrones-modernos","title":"\ud83c\udfa8 Patrones Modernos","text":"<ul> <li>Result Pattern para manejo de errores</li> <li>Resource Pattern para lifecycle management</li> <li>Builder Pattern para configuraci\u00f3n fluida</li> </ul>"},{"location":"#instalacion-rapida","title":"Instalaci\u00f3n R\u00e1pida","text":"<pre><code># Con pip\npip install r5\n\n# Con uv\nuv add r5\n</code></pre>"},{"location":"#ejemplo-completo","title":"Ejemplo Completo","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom R5.ioc import singleton, inject, config\nfrom R5.http import Http\nfrom R5.background import Background\n\n@config(file='.env')\nclass AppConfig:\n    api_url: str = \"https://api.example.com\"\n    api_key: str = \"\"\n\n@singleton\nclass EmailService:\n    async def send(self, to: str, subject: str):\n        print(f\"Sending email to {to}: {subject}\")\n\n@dataclass\nclass UserDTO:\n    id: int\n    name: str\n    email: str\n\n@inject\nasync def main(\n    config: AppConfig,\n    http: Http,\n    bg: Background,\n    email: EmailService\n):\n    result = await http.get(f\"{config.api_url}/users/1\")\n    user = result.to(UserDTO)\n\n    if user:\n        await bg.add(email.send, user.email, \"Welcome!\")\n        print(f\"User: {user.name}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li> <p> Quick Start</p> <p>Empieza a usar R5 en minutos</p> </li> <li> <p> Gu\u00edas</p> <p>Aprende los conceptos fundamentales</p> </li> <li> <p> API Reference</p> <p>Documentaci\u00f3n completa de la API</p> </li> </ul>"},{"location":"#licencia","title":"Licencia","text":"<p>MIT License - Libre para uso personal y comercial.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Todos los cambios notables en R5 ser\u00e1n documentados aqu\u00ed.</p> <p>El formato est\u00e1 basado en Keep a Changelog, y este proyecto adhiere a Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Documentaci\u00f3n completa con MkDocs y mkdocstrings</li> <li>Ejemplos de uso b\u00e1sicos y avanzados</li> <li>Gu\u00edas para IoC, HTTP y Background</li> <li>Patrones de dise\u00f1o comunes</li> </ul>"},{"location":"changelog/#010-2025-01-25","title":"0.1.0 - 2025-01-25","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>IoC Container con inyecci\u00f3n de dependencias autom\u00e1tica</li> <li>Decoradores <code>@singleton</code>, <code>@factory</code>, <code>@resource</code></li> <li>Decorador <code>@inject</code> para inyecci\u00f3n autom\u00e1tica</li> <li>Decorador <code>@config</code> para configuraci\u00f3n multi-formato</li> <li>Soporte para .env, JSON, YAML, Properties</li> <li>Detecci\u00f3n de dependencias circulares</li> <li> <p>Type-safe dependency resolution</p> </li> <li> <p>Cliente HTTP as\u00edncrono</p> </li> <li>Connection pooling con httpx</li> <li>Result pattern para manejo de errores</li> <li>Retry autom\u00e1tico configurable</li> <li>Handlers (before/after)</li> <li>Proxy rotation</li> <li>Mapeo autom\u00e1tico a DTOs (Pydantic, dataclasses)</li> <li> <p>Configuraci\u00f3n flexible de timeouts</p> </li> <li> <p>Sistema de Background Tasks</p> </li> <li>Ejecuci\u00f3n concurrente con anyio</li> <li>Thread pool para tareas s\u00edncronas</li> <li>Inyecci\u00f3n IoC en tareas</li> <li>Error handling robusto</li> <li>Lifecycle management autom\u00e1tico</li> </ul>"},{"location":"changelog/#technical","title":"Technical","text":"<ul> <li>Python 3.14+ requerido</li> <li>Dependencias principales:</li> <li>anyio &gt;= 4.12.0</li> <li>dependency-injector &gt;= 4.48.3</li> <li>httpx &gt;= 0.28.1</li> <li>pydantic &gt;= 2.12.5</li> <li>pyyaml &gt;= 6.0.3</li> </ul>"},{"location":"changelog/#001-2025-01-01","title":"0.0.1 - 2025-01-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Initial project setup</li> <li>Basic project structure</li> </ul>"},{"location":"changelog/#tipos-de-cambios","title":"Tipos de Cambios","text":"<ul> <li><code>Added</code> - Nuevas funcionalidades</li> <li><code>Changed</code> - Cambios en funcionalidades existentes</li> <li><code>Deprecated</code> - Funcionalidades que ser\u00e1n removidas</li> <li><code>Removed</code> - Funcionalidades removidas</li> <li><code>Fixed</code> - Correcci\u00f3n de bugs</li> <li><code>Security</code> - Correcciones de seguridad</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#setup","title":"Setup","text":"<pre><code>git clone https://github.com/tu-usuario/R5.git\ncd R5\nuv sync\nuv sync --group dev\n</code></pre>"},{"location":"contributing/#workflow","title":"Workflow","text":"<pre><code>git checkout -b feature/nueva-funcionalidad\n\n# Tests\nuv run pytest\nuv run pytest --cov=R5 --cov-report=html\n\n# Type checking y linting\nuv run mypy R5/\nuv run ruff check R5/\nuv run ruff format R5/\n\n# Commit (Conventional Commits)\ngit commit -m \"feat: agregar nueva funcionalidad\"\ngit push origin feature/nueva-funcionalidad\n</code></pre>"},{"location":"contributing/#convenciones","title":"Convenciones","text":"<ul> <li>Style: PEP 8, type hints obligatorios, max 88 chars/l\u00ednea</li> <li>Commits: <code>feat:</code>, <code>fix:</code>, <code>docs:</code>, <code>test:</code>, <code>refactor:</code>, <code>chore:</code></li> <li>Tests: Agregar tests para toda funcionalidad nueva</li> <li>Docs: Actualizar si los cambios afectan la API p\u00fablica</li> </ul>"},{"location":"contributing/#tests","title":"Tests","text":"<pre><code>import pytest\nfrom R5.ioc import Container, singleton, inject\n\ndef test_singleton():\n    Container.reset()\n\n    @singleton\n    class MyService:\n        def __init__(self):\n            self.value = \"test\"\n\n    assert Container.resolve(MyService) is Container.resolve(MyService)\n\n@pytest.fixture\ndef clean_container():\n    snapshot = Container.snapshot()\n    yield\n    Container.restore(snapshot)\n</code></pre>"},{"location":"contributing/#documentacion","title":"Documentaci\u00f3n","text":"<pre><code>uv sync --group docs\nuv run mkdocs serve    # Local\nuv run mkdocs build    # Build\n</code></pre>"},{"location":"contributing/#reportar-issues","title":"Reportar Issues","text":"<p>Bugs: Versi\u00f3n de R5/Python, c\u00f3digo para reproducir, comportamiento esperado vs actual, stack trace.</p> <p>Features: Descripci\u00f3n, casos de uso, ejemplo de API propuesta.</p>"},{"location":"contributing/#licencia","title":"Licencia","text":"<p>Contribuciones se licencian bajo MIT.</p>"},{"location":"api/background/","title":"Background API Reference","text":"<p>Documentaci\u00f3n completa de la API del m\u00f3dulo Background.</p>"},{"location":"api/background/#background","title":"Background","text":""},{"location":"api/background/#R5.background.Background","title":"Background","text":"<pre><code>Background(config: _BackgroundConfig)\n</code></pre> <p>Sistema de ejecuci\u00f3n de tareas en background con anyio.</p> <p>Gestiona el ciclo de vida de tareas concurrentes proporcionando un TaskGroup, un pool de hilos para tareas s\u00edncronas e integraci\u00f3n con inyecci\u00f3n de dependencias.</p> <p>Attributes:</p> Name Type Description <code>_task_group</code> <code>TaskGroup</code> <p>Grupo de tareas para ejecuci\u00f3n concurrente.</p> <code>_limiter</code> <code>CapacityLimiter</code> <p>Limitador de capacidad para controlar concurrencia.</p> Notes <ul> <li>Soporta inyecci\u00f3n de dependencias autom\u00e1tica mediante <code>@R5/ioc</code>.</li> <li>El manejo de errores est\u00e1 dise\u00f1ado para no propagar excepciones al hilo principal.</li> </ul> <p>Examples:</p> <p>Uso con <code>@inject</code> (recomendado):</p> <p>.. code-block:: python     @inject     async def my_service(bg: Background):         await bg.add(send_email, \"user@example.com\")         await bg.add(process_payment, payment_id)</p> <p>Uso con context manager (control expl\u00edcito de lifecycle):</p> <p>.. code-block:: python     async with await Container.resolve(Background) as bg:         await bg.add(task1)         await bg.add(task2)</p> <p>Uso con inicializaci\u00f3n directa (tradicional):</p> <p>Note:     No se recomienda la inicializaci\u00f3n directa fuera de entornos de prueba.     Prefiera el uso de <code>@inject</code> para asegurar la correcta gesti\u00f3n de recursos.</p> <p>.. code-block:: python     bg = Background()     await bg.add(task1)</p> Source code in <code>R5/background/background.py</code> <pre><code>@inject\ndef __init__(self, config: _BackgroundConfig) -&gt; None:\n    self._config = config\n    self._task_group: TaskGroup | None = None\n    self._max_workers = config.background_max_workers\n    self._limiter = CapacityLimiter(config.background_max_workers)\n    self._started = False\n    self._lock = Lock()\n</code></pre>"},{"location":"api/background/#R5.background.Background.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Background\n</code></pre> Source code in <code>R5/background/background.py</code> <pre><code>async def __aenter__(self) -&gt; \"Background\":\n    return self\n</code></pre>"},{"location":"api/background/#R5.background.Background.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb) -&gt; None\n</code></pre> Source code in <code>R5/background/background.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    if self._started and self._task_group:\n        try:\n            await self._task_group.__aexit__(exc_type, exc_val, exc_tb)\n        finally:\n            self._started = False\n            self._task_group = None\n            logger.debug(\"Background shutdown completed\")\n</code></pre>"},{"location":"api/background/#R5.background.Background.add","title":"add  <code>async</code>","text":"<pre><code>add(func: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; None\n</code></pre> Source code in <code>R5/background/background.py</code> <pre><code>async def add(self, func: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; None:\n    if not self._config.background_enable:\n        raise BackgroundDisabledError\n\n    async with self._lock:\n        if not self._started:\n            self._task_group = create_task_group()\n            await self._task_group.__aenter__()\n            self._started = True\n            logger.debug(f\"Background initialized with {self._max_workers} workers\")\n\n        if self._task_group:\n            self._task_group.start_soon(self._safe_task, func, args, kwargs)\n</code></pre>"},{"location":"api/http/","title":"HTTP API Reference","text":"<p>Documentaci\u00f3n completa de la API del m\u00f3dulo HTTP.</p>"},{"location":"api/http/#http-client","title":"Http Client","text":""},{"location":"api/http/#R5.http.http.Http","title":"Http","text":"<pre><code>Http(config: HttpConfig)\n</code></pre> <p>Cliente HTTP as\u00edncrono con pooling, retry y mapeo a DTOs.</p> Uso <p>@inject async def my_service(http: Http):     result = await http.get(\"/users/1\")     user = result.to(UserDTO)</p> <p>Retry:     http.retry(3, delay=1.0, when_status=(503,)).get(url)</p> <p>Proxy (global en config):     # application.yml     http_proxy: \"http://proxy:8080\"</p> <p>Proxy (por request):     http.get(url, proxy=\"http://proxy:8080\")</p> <p>Chaining:     http.retry(3).on_before(handler).get(url)</p> <p>Result:     user = await http.get(\"/users/1\").to(UserDTO)</p> Source code in <code>R5/http/http.py</code> <pre><code>@inject\ndef __init__(self, config: HttpConfig):\n    self._config = config\n    self._logger = get_logger(__name__)\n    self._client: Optional[httpx.AsyncClient] = None\n    self._before_handlers: list[Callable[[httpx.Request], None]] = []\n    self._after_handlers: list[Callable[[httpx.Request, httpx.Response], None]] = []\n    self._retry_attempts: Optional[int] = None\n    self._retry_delay: float = config.http_retry_delay\n    self._retry_backoff: float = config.http_retry_backoff\n    self._retry_when_status: Optional[tuple[int, ...]] = None\n    self._retry_when_exception: Optional[tuple[type[Exception], ...]] = None\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Http\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>async def __aenter__(self) -&gt; \"Http\":\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb) -&gt; None\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    await self.close()\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.get","title":"get  <code>async</code>","text":"<pre><code>get(url: str, **kwargs: Any) -&gt; Result\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>async def get(self, url: str, **kwargs: Any) -&gt; Result:\n    return await self.request(\"GET\", url, **kwargs)\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.post","title":"post  <code>async</code>","text":"<pre><code>post(url: str, **kwargs: Any) -&gt; Result\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>async def post(self, url: str, **kwargs: Any) -&gt; Result:\n    return await self.request(\"POST\", url, **kwargs)\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.put","title":"put  <code>async</code>","text":"<pre><code>put(url: str, **kwargs: Any) -&gt; Result\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>async def put(self, url: str, **kwargs: Any) -&gt; Result:\n    return await self.request(\"PUT\", url, **kwargs)\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.patch","title":"patch  <code>async</code>","text":"<pre><code>patch(url: str, **kwargs: Any) -&gt; Result\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>async def patch(self, url: str, **kwargs: Any) -&gt; Result:\n    return await self.request(\"PATCH\", url, **kwargs)\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(url: str, **kwargs: Any) -&gt; Result\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>async def delete(self, url: str, **kwargs: Any) -&gt; Result:\n    return await self.request(\"DELETE\", url, **kwargs)\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.retry","title":"retry","text":"<pre><code>retry(attempts: int, delay: float = 1.0, backoff: float = 2.0, when_status: Optional[tuple[int, ...]] = None, when_exception: Optional[tuple[type[Exception], ...]] = None) -&gt; Http\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>def retry(\n    self,\n    attempts: int,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    when_status: Optional[tuple[int, ...]] = None,\n    when_exception: Optional[tuple[type[Exception], ...]] = None,\n) -&gt; \"Http\":\n    self._retry_attempts = attempts\n    self._retry_delay = delay\n    self._retry_backoff = backoff\n    self._retry_when_status = when_status\n    self._retry_when_exception = when_exception\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.on_before","title":"on_before","text":"<pre><code>on_before(handler: Callable[[Request], None]) -&gt; Http\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>def on_before(self, handler: Callable[[httpx.Request], None]) -&gt; \"Http\":\n    self._before_handlers.append(handler)\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.on_after","title":"on_after","text":"<pre><code>on_after(handler: Callable[[Request, Response], None]) -&gt; Http\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>def on_after(\n    self, handler: Callable[[httpx.Request, httpx.Response], None]\n) -&gt; \"Http\":\n    self._after_handlers.append(handler)\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.http.Http.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> Source code in <code>R5/http/http.py</code> <pre><code>async def close(self):\n    if self._client:\n        await self._client.aclose()\n        self._client = None\n</code></pre>"},{"location":"api/http/#httpconfig","title":"HttpConfig","text":""},{"location":"api/http/#R5.http.http.HttpConfig","title":"HttpConfig","text":""},{"location":"api/http/#R5.http.http.HttpConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> <p>Validar configuraci\u00f3n al instanciar.</p> Source code in <code>R5/http/http.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validar configuraci\u00f3n al instanciar.\"\"\"\n    if self.http_max_connections &lt;= 0:\n        raise ValueError(\"http_max_connections must be &gt; 0\")\n\n    if self.http_max_keepalive_connections &lt; 0:\n        raise ValueError(\"http_max_keepalive_connections must be &gt;= 0\")\n\n    if self.http_max_keepalive_connections &gt; self.http_max_connections:\n        raise ValueError(\"http_max_keepalive_connections cannot exceed http_max_connections\")\n\n    timeouts = ['http_connect_timeout', 'http_read_timeout', 'http_write_timeout', 'http_pool_timeout']\n    for field in timeouts:\n        if getattr(self, field) &lt;= 0:\n            raise ValueError(f\"{field} must be &gt; 0\")\n\n    if self.http_retry_delay &lt; 0:\n        raise ValueError(\"http_retry_delay must be &gt;= 0\")\n\n    if self.http_retry_backoff &lt; 1:\n        raise ValueError(\"http_retry_backoff must be &gt;= 1\")\n</code></pre>"},{"location":"api/http/#result","title":"Result","text":""},{"location":"api/http/#R5.http.result.Result","title":"Result  <code>dataclass</code>","text":"<pre><code>Result(response: Optional[Response] = None, request: Optional[Request] = None, status: int = 0, exception: Optional[Exception] = None)\n</code></pre> <p>Wrapper para respuestas HTTP con handlers encadenados y mapeo a tipos.</p>"},{"location":"api/http/#R5.http.result.Result.from_response","title":"from_response  <code>staticmethod</code>","text":"<pre><code>from_response(response: Response) -&gt; Result\n</code></pre> Source code in <code>R5/http/result.py</code> <pre><code>@staticmethod\ndef from_response(response: httpx.Response) -&gt; \"Result\":\n    return Result(\n        response=response,\n        request=response.request,\n        status=response.status_code,\n        exception=None,\n    )\n</code></pre>"},{"location":"api/http/#R5.http.result.Result.from_exception","title":"from_exception  <code>staticmethod</code>","text":"<pre><code>from_exception(error: Exception, response: Optional[Response] = None) -&gt; Result\n</code></pre> Source code in <code>R5/http/result.py</code> <pre><code>@staticmethod\ndef from_exception(\n    error: Exception, response: Optional[httpx.Response] = None\n) -&gt; \"Result\":\n    return Result(\n        response=response,\n        request=response.request if response else None,\n        status=response.status_code if response else 0,\n        exception=error,\n    )\n</code></pre>"},{"location":"api/http/#R5.http.result.Result.on_status","title":"on_status","text":"<pre><code>on_status(status_code: int, handler: Callable[[Request, Response], None]) -&gt; Result\n</code></pre> Source code in <code>R5/http/result.py</code> <pre><code>def on_status(\n    self, status_code: int, handler: Callable[[httpx.Request, httpx.Response], None]\n) -&gt; \"Result\":\n    if self.status == status_code and self.response and self.request:\n        handler(self.request, self.response)\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.result.Result.on_exception","title":"on_exception","text":"<pre><code>on_exception(handler: Callable[[Exception], None]) -&gt; Result\n</code></pre> Source code in <code>R5/http/result.py</code> <pre><code>def on_exception(self, handler: Callable[[Exception], None]) -&gt; \"Result\":\n    if self.exception:\n        handler(self.exception)\n    return self\n</code></pre>"},{"location":"api/http/#R5.http.result.Result.to","title":"to","text":"<pre><code>to(target_type: Type[T]) -&gt; Optional[T]\n</code></pre> Source code in <code>R5/http/result.py</code> <pre><code>def to(self, target_type: Type[T]) -&gt; Optional[T]:\n    if self.exception or not self.response:\n        return None\n    try:\n        return self._map_response(self.response, target_type)\n    except Exception as e:\n        _logger.warning(\n            f\"Failed to map response to {target_type.__name__}: {e}\",\n            exc_info=True\n        )\n        return None\n</code></pre>"},{"location":"api/http/#errores","title":"Errores","text":""},{"location":"api/http/#httperror","title":"HttpError","text":""},{"location":"api/http/#R5.http.errors.HttpError","title":"HttpError","text":"<pre><code>HttpError(custom_message: Optional[str] = None)\n</code></pre> <p>               Bases: <code>Exception</code></p> Source code in <code>R5/http/errors.py</code> <pre><code>def __init__(self, custom_message: Optional[str] = None):\n    msg = custom_message if custom_message else self.message\n    super().__init__(msg)\n</code></pre>"},{"location":"api/http/#httpdisabledexception","title":"HttpDisabledException","text":""},{"location":"api/http/#R5.http.errors.HttpDisabledException","title":"HttpDisabledException","text":"<pre><code>HttpDisabledException(custom_message: Optional[str] = None)\n</code></pre> <p>               Bases: <code>HttpError</code></p> Source code in <code>R5/http/errors.py</code> <pre><code>def __init__(self, custom_message: Optional[str] = None):\n    msg = custom_message if custom_message else self.message\n    super().__init__(msg)\n</code></pre>"},{"location":"api/http/#httptimeouterror","title":"HttpTimeoutError","text":""},{"location":"api/http/#R5.http.errors.HttpTimeoutError","title":"HttpTimeoutError","text":"<pre><code>HttpTimeoutError(custom_message: Optional[str] = None)\n</code></pre> <p>               Bases: <code>HttpError</code></p> Source code in <code>R5/http/errors.py</code> <pre><code>def __init__(self, custom_message: Optional[str] = None):\n    msg = custom_message if custom_message else self.message\n    super().__init__(msg)\n</code></pre>"},{"location":"api/http/#httpconnectionerror","title":"HttpConnectionError","text":""},{"location":"api/http/#R5.http.errors.HttpConnectionError","title":"HttpConnectionError","text":"<pre><code>HttpConnectionError(custom_message: Optional[str] = None)\n</code></pre> <p>               Bases: <code>HttpError</code></p> Source code in <code>R5/http/errors.py</code> <pre><code>def __init__(self, custom_message: Optional[str] = None):\n    msg = custom_message if custom_message else self.message\n    super().__init__(msg)\n</code></pre>"},{"location":"api/http/#httpmappingerror","title":"HttpMappingError","text":""},{"location":"api/http/#R5.http.errors.HttpMappingError","title":"HttpMappingError","text":"<pre><code>HttpMappingError(custom_message: Optional[str] = None)\n</code></pre> <p>               Bases: <code>HttpError</code></p> Source code in <code>R5/http/errors.py</code> <pre><code>def __init__(self, custom_message: Optional[str] = None):\n    msg = custom_message if custom_message else self.message\n    super().__init__(msg)\n</code></pre>"},{"location":"api/ioc/","title":"IoC API Reference","text":"<p>Documentaci\u00f3n completa de la API del m\u00f3dulo IoC.</p>"},{"location":"api/ioc/#container","title":"Container","text":""},{"location":"api/ioc/#R5.ioc.container.Container","title":"Container","text":""},{"location":"api/ioc/#R5.ioc.container.Container.get_container","title":"get_container  <code>classmethod</code>","text":"<pre><code>get_container() -&gt; dict[type[Any] | Callable[..., Any], providers.Provider]\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef get_container(cls) -&gt; dict[type[Any] | Callable[..., Any], providers.Provider]:\n    return cls._container_by_type\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.get_provider","title":"get_provider  <code>classmethod</code>","text":"<pre><code>get_provider(provider_type: type) -&gt; providers.Provider\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef get_provider(cls, provider_type: type) -&gt; providers.Provider:\n    if provider_type not in cls._container_by_type:\n        available = [\n            f\"{t.__module__}.{t.__qualname__}\"\n            for t in cls._container_by_type.keys()\n        ]\n        raise ProviderNotFoundError(provider_type, available)\n    return cls._container_by_type[provider_type]\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.in_provider","title":"in_provider  <code>classmethod</code>","text":"<pre><code>in_provider(provider_type: type) -&gt; bool\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef in_provider(cls, provider_type: type) -&gt; bool:\n    return provider_type in cls._container_by_type\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.alias_provider","title":"alias_provider  <code>classmethod</code>","text":"<pre><code>alias_provider(alias: type, target: type) -&gt; None\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef alias_provider(cls, alias: type, target: type) -&gt; None:\n    if target not in cls._container_by_type:\n        available = [\n            f\"{t.__module__}.{t.__qualname__}\"\n            for t in cls._container_by_type.keys()\n        ]\n        raise ProviderNotFoundError(target, available)\n    cls._container_by_type[alias] = cls._container_by_type[target]\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.resolve","title":"resolve  <code>classmethod</code>","text":"<pre><code>resolve(dep_type: Type[T]) -&gt; T\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef resolve(cls, dep_type: Type[T]) -&gt; T:\n    stack = cls._resolution_stack.get()\n    if stack is None:\n        stack = []\n        cls._resolution_stack.set(stack)\n\n    dep_name = f\"{dep_type.__module__}.{dep_type.__qualname__}\"\n\n    if dep_name in stack:\n        stack.append(dep_name)\n        raise CircularDependencyError(stack)\n\n    stack.append(dep_name)\n    try:\n        provider = cls.get_provider(dep_type)\n        return provider()\n    finally:\n        stack.pop()\n        if not stack:\n            cls._resolution_stack.set(None)\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.registry_provider","title":"registry_provider  <code>classmethod</code>","text":"<pre><code>registry_provider(func_or_cls: type[Any] | Callable[..., Any], scope: Scope) -&gt; None\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef registry_provider(\n    cls,\n    func_or_cls: type[Any] | Callable[..., Any],\n    scope: Scope,\n) -&gt; None:\n    provider_scope = {\n        Scope.SINGLETON: providers.Singleton,\n        Scope.FACTORY: providers.Factory,\n        Scope.RESOURCE: providers.Resource,\n    }\n\n    if func_or_cls in cls._container_by_type:\n        warnings.warn(\n            f\"Provider for type '{func_or_cls.__name__}' is being overwritten. \"\n            f\"This might indicate duplicate registrations.\",\n            UserWarning,\n            stacklevel=4,\n        )\n\n    provider_class = provider_scope[scope]\n\n    if isinstance(func_or_cls, type):\n        try:\n            sig = inspect.signature(func_or_cls.__init__)\n            params = [\n                p\n                for p in sig.parameters.values()\n                if p.name not in (\"self\", \"cls\")\n                and p.annotation != inspect.Parameter.empty\n            ]\n\n            if params:\n                type_hints = get_type_hints(func_or_cls.__init__)\n                injectable_params = {}\n                for p in params:\n                    if p.name in type_hints:\n                        dep_type = type_hints[p.name]\n                        if isinstance(dep_type, type) and cls.in_provider(dep_type):\n                            injectable_params[p.name] = dep_type\n\n                if injectable_params:\n\n                    def factory(\n                        injectable_params=injectable_params, target_cls=func_or_cls\n                    ):\n                        kwargs = {\n                            param_name: cls.resolve(dep_type)\n                            for param_name, dep_type in injectable_params.items()\n                        }\n                        return target_cls(**kwargs)\n\n                    provider = provider_class(factory)\n                    cls._container_by_type[func_or_cls] = provider\n                    return\n        except Exception:\n            pass\n\n    provider = provider_class(func_or_cls)\n    cls._container_by_type[func_or_cls] = provider\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.reset","title":"reset  <code>classmethod</code>","text":"<pre><code>reset() -&gt; None\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    cls._container_by_type.clear()\n    cls._resolution_stack.set(None)\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.snapshot","title":"snapshot  <code>classmethod</code>","text":"<pre><code>snapshot() -&gt; dict[type[Any] | Callable[..., Any], providers.Provider]\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef snapshot(cls) -&gt; dict[type[Any] | Callable[..., Any], providers.Provider]:\n    return cls._container_by_type.copy()\n</code></pre>"},{"location":"api/ioc/#R5.ioc.container.Container.restore","title":"restore  <code>classmethod</code>","text":"<pre><code>restore(snapshot: dict[type[Any] | Callable[..., Any], Provider]) -&gt; None\n</code></pre> Source code in <code>R5/ioc/container.py</code> <pre><code>@classmethod\ndef restore(\n    cls, snapshot: dict[type[Any] | Callable[..., Any], providers.Provider]\n) -&gt; None:\n    cls._container_by_type.clear()\n    cls._container_by_type.update(snapshot)\n    cls._resolution_stack.set(None)\n</code></pre>"},{"location":"api/ioc/#scope","title":"Scope","text":""},{"location":"api/ioc/#R5.ioc.container.Scope","title":"Scope","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/ioc/#decoradores","title":"Decoradores","text":""},{"location":"api/ioc/#singleton","title":"singleton","text":""},{"location":"api/ioc/#R5.ioc.providers.singleton","title":"singleton","text":"<pre><code>singleton(func_or_cls: T) -&gt; T\n</code></pre> Source code in <code>R5/ioc/providers.py</code> <pre><code>def singleton(func_or_cls: T) -&gt; T:\n    return component(scope=Scope.SINGLETON)(func_or_cls)\n</code></pre>"},{"location":"api/ioc/#factory","title":"factory","text":""},{"location":"api/ioc/#R5.ioc.providers.factory","title":"factory","text":"<pre><code>factory(func_or_cls: T) -&gt; T\n</code></pre> Source code in <code>R5/ioc/providers.py</code> <pre><code>def factory(func_or_cls: T) -&gt; T:\n    return component(scope=Scope.FACTORY)(func_or_cls)\n</code></pre>"},{"location":"api/ioc/#resource","title":"resource","text":""},{"location":"api/ioc/#R5.ioc.providers.resource","title":"resource","text":"<pre><code>resource(func_or_cls: T) -&gt; T\n</code></pre> Source code in <code>R5/ioc/providers.py</code> <pre><code>def resource(func_or_cls: T) -&gt; T:\n    return component(scope=Scope.RESOURCE)(func_or_cls)\n</code></pre>"},{"location":"api/ioc/#component","title":"component","text":""},{"location":"api/ioc/#R5.ioc.providers.component","title":"component","text":"<pre><code>component(scope: Scope) -&gt; Callable[[T], T]\n</code></pre> Source code in <code>R5/ioc/providers.py</code> <pre><code>def component(scope: Scope) -&gt; Callable[[T], T]:\n    def wrapper(func_or_cls: Any) -&gt; Any:\n        Container.registry_provider(func_or_cls, scope)\n        return func_or_cls\n\n    return wrapper\n</code></pre>"},{"location":"api/ioc/#inject","title":"inject","text":""},{"location":"api/ioc/#R5.ioc.injection.inject","title":"inject","text":"<pre><code>inject(func: F) -&gt; F\n</code></pre> Source code in <code>R5/ioc/injection.py</code> <pre><code>def inject(func: F) -&gt; F:\n    original_func = inspect.unwrap(func)\n    sig = inspect.signature(original_func)\n    deps_to_inject: dict[str, type | None] = {}\n\n    try:\n        type_hints = get_type_hints(original_func)\n    except Exception as e:\n        import warnings\n        warnings.warn(\n            f\"Could not resolve type hints for {func.__name__}: {e}. \"\n            f\"Falling back to raw annotations. Some dependencies may not be injected.\",\n            UserWarning,\n            stacklevel=2\n        )\n        type_hints = {}\n        for param_name, param in sig.parameters.items():\n            if param.annotation != inspect.Parameter.empty:\n                type_hints[param_name] = param.annotation\n\n    for param_name, param in sig.parameters.items():\n        if param_name in (\"self\", \"cls\"):\n            continue\n\n        if param_name not in type_hints:\n            continue\n\n        annotation = type_hints[param_name]\n\n        origin = get_origin(annotation)\n        is_optional = False\n        if origin is Union:\n            args = get_args(annotation)\n            if type(None) in args:\n                is_optional = True\n\n        concrete_type = _extract_concrete_type(annotation)\n\n        if concrete_type is None:\n            continue\n\n        if Container.in_provider(concrete_type):\n            deps_to_inject[param_name] = concrete_type\n        elif is_optional:\n            deps_to_inject[param_name] = None\n\n    new_params = []\n    found_first_injectable = False\n\n    for param_name, param in sig.parameters.items():\n        if param_name in (\"self\", \"cls\"):\n            new_params.append(param)\n            continue\n\n        if param_name in deps_to_inject:\n            found_first_injectable = True\n\n        if found_first_injectable and param_name not in deps_to_inject:\n            if param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD:\n                new_param = param.replace(kind=inspect.Parameter.KEYWORD_ONLY)\n                new_params.append(new_param)\n            else:\n                new_params.append(param)\n        else:\n            new_params.append(param)\n\n    new_sig = sig.replace(parameters=new_params)\n\n    if inspect.iscoroutinefunction(func):\n\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            injected = _inject_dependencies(\n                sig, deps_to_inject, args, kwargs, func.__name__, is_async=True\n            )\n\n            for param_name, provider_instance in injected.items():\n                if inspect.isawaitable(provider_instance):\n                    kwargs[param_name] = await provider_instance\n                else:\n                    kwargs[param_name] = provider_instance\n\n            return await func(*args, **kwargs)\n\n        async_wrapper.__signature__ = new_sig  # type: ignore\n        return async_wrapper  # type: ignore\n    else:\n\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            injected = _inject_dependencies(\n                sig, deps_to_inject, args, kwargs, func.__name__, is_async=False\n            )\n            kwargs.update(injected)\n            return func(*args, **kwargs)\n\n        sync_wrapper.__signature__ = new_sig  # type: ignore\n        return sync_wrapper  # type: ignore\n</code></pre>"},{"location":"api/ioc/#config","title":"config","text":""},{"location":"api/ioc/#R5.ioc.configuration.config","title":"config","text":"<pre><code>config(cls: type[T], *, file: str | None = None, required: bool = True, env_override: bool = True, case_sensitive: bool = False) -&gt; type[T]\n</code></pre><pre><code>config(cls: None = None, *, file: str | None = None, required: bool = True, env_override: bool = True, case_sensitive: bool = False) -&gt; Callable[[type[T]], type[T]]\n</code></pre> <pre><code>config(cls: type[T] | None = None, *, file: str | None = None, required: bool = True, env_override: bool = True, case_sensitive: bool = False) -&gt; type[T] | Callable[[type[T]], type[T]]\n</code></pre> <p>Decorador para clases de configuraci\u00f3n con carga optimizada.</p> <p>Soporta m\u00faltiples formatos: .env, .json, .yml, .yaml, .properties</p> <p>Mejoras: - Carga \u00fanica del archivo (no repetida en cada instancia) - Cache autom\u00e1tico con @lru_cache - Soporte para variables de entorno como override - Mejor conversi\u00f3n de tipos (int, float, bool, list, dict, set, tuple) - Matching flexible de claves</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | None</code> <p>Ruta al archivo de configuraci\u00f3n</p> <code>None</code> <code>required</code> <code>bool</code> <p>Si True, el archivo debe existir</p> <code>True</code> <code>env_override</code> <code>bool</code> <p>Si True, variables de entorno sobreescriben valores del archivo</p> <code>True</code> <code>case_sensitive</code> <code>bool</code> <p>Si True, respeta may\u00fasculas/min\u00fasculas en nombres de campos</p> <code>False</code> Ejemplo <p>@config(file='config.json', env_override=True) class MyConfig:     host: str = 'localhost'     port: int = 8080</p> Source code in <code>R5/ioc/configuration.py</code> <pre><code>def config(\n    cls: type[T] | None = None, \n    *, \n    file: str | None = None, \n    required: bool = True,\n    env_override: bool = True,\n    case_sensitive: bool = False,\n) -&gt; type[T] | Callable[[type[T]], type[T]]:\n    \"\"\"Decorador para clases de configuraci\u00f3n con carga optimizada.\n\n    Soporta m\u00faltiples formatos: .env, .json, .yml, .yaml, .properties\n\n    Mejoras:\n    - Carga \u00fanica del archivo (no repetida en cada instancia)\n    - Cache autom\u00e1tico con @lru_cache\n    - Soporte para variables de entorno como override\n    - Mejor conversi\u00f3n de tipos (int, float, bool, list, dict, set, tuple)\n    - Matching flexible de claves\n\n    Args:\n        file: Ruta al archivo de configuraci\u00f3n\n        required: Si True, el archivo debe existir\n        env_override: Si True, variables de entorno sobreescriben valores del archivo\n        case_sensitive: Si True, respeta may\u00fasculas/min\u00fasculas en nombres de campos\n\n    Ejemplo:\n        @config(file='config.json', env_override=True)\n        class MyConfig:\n            host: str = 'localhost'\n            port: int = 8080\n    \"\"\"\n    def decorator(cls_to_decorate: type[T]) -&gt; type[T]:\n        config_data = _load_config_data(file, required)\n        type_hints = get_type_hints(cls_to_decorate)\n\n        class ConfigClass:\n            _config_data = config_data\n            _type_hints = type_hints\n            _env_override = env_override\n            _case_sensitive = case_sensitive\n\n            def __init__(self, **kwargs: Any):\n                processed_attrs = set()\n\n                for attr_name, attr_type in self._type_hints.items():\n                    if attr_name.startswith('_'):\n                        continue\n\n                    processed_attrs.add(attr_name)\n                    value = self._get_config_value(attr_name, attr_type)\n                    setattr(self, attr_name, value)\n\n                for attr_name in dir(cls_to_decorate):\n                    if attr_name.startswith('_') or attr_name in processed_attrs:\n                        continue\n\n                    attr_value = getattr(cls_to_decorate, attr_name, None)\n                    if callable(attr_value):\n                        continue\n\n                    setattr(self, attr_name, attr_value)\n\n                for key, value in kwargs.items():\n                    setattr(self, key, value)\n\n            def _get_config_value(self, attr_name: str, attr_type: Any) -&gt; Any:\n                value = None\n                source = \"default\"\n\n                if self._env_override:\n                    env_key = attr_name.upper()\n                    env_value = os.environ.get(env_key)\n                    if env_value is not None:\n                        value = env_value\n                        source = \"env\"\n\n                if value is None and self._config_data:\n                    file_value = _match_config_key(attr_name, self._config_data, self._case_sensitive)\n                    if file_value is not None:\n                        value = file_value\n                        source = \"file\"\n\n                if value is None and hasattr(cls_to_decorate, attr_name):\n                    value = getattr(cls_to_decorate, attr_name)\n                    source = \"default\"\n\n                if value is None and not _is_optional(attr_type):\n                    warnings.warn(\n                        f\"Required field '{attr_name}' in {cls_to_decorate.__name__} \"\n                        f\"has no value in config file, environment, or default.\",\n                        UserWarning,\n                    )\n                    return None\n\n                if value is not None and source in (\"env\", \"file\"):\n                    value = _TypeConverter.convert(value, attr_type)\n\n                return value\n\n        ConfigClass.__name__ = cls_to_decorate.__name__\n        ConfigClass.__qualname__ = cls_to_decorate.__qualname__\n        ConfigClass.__module__ = cls_to_decorate.__module__\n        ConfigClass.__annotations__ = getattr(cls_to_decorate, '__annotations__', {})\n\n        Container.registry_provider(ConfigClass, Scope.SINGLETON)\n        Container.alias_provider(cls_to_decorate, ConfigClass)\n\n        return cls_to_decorate\n\n    if cls is None:\n        return decorator\n    else:\n        return decorator(cls)\n</code></pre>"},{"location":"api/ioc/#errores","title":"Errores","text":""},{"location":"api/ioc/#iocerror","title":"IoCError","text":""},{"location":"api/ioc/#R5.ioc.errors.IoCError","title":"IoCError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"api/ioc/#circulardependencyerror","title":"CircularDependencyError","text":""},{"location":"api/ioc/#R5.ioc.errors.CircularDependencyError","title":"CircularDependencyError","text":"<pre><code>CircularDependencyError(dependency_chain: list[str])\n</code></pre> <p>               Bases: <code>IoCError</code></p> Source code in <code>R5/ioc/errors.py</code> <pre><code>def __init__(self, dependency_chain: list[str]):\n    self.dependency_chain = dependency_chain\n    chain_str = \" -&gt; \".join(dependency_chain)\n    super().__init__(\n        f\"Circular dependency detected: {chain_str}\"\n    )\n</code></pre>"},{"location":"api/ioc/#providernotfounderror","title":"ProviderNotFoundError","text":""},{"location":"api/ioc/#R5.ioc.errors.ProviderNotFoundError","title":"ProviderNotFoundError","text":"<pre><code>ProviderNotFoundError(provider_type: Type, available_providers: list[str])\n</code></pre> <p>               Bases: <code>IoCError</code></p> Source code in <code>R5/ioc/errors.py</code> <pre><code>def __init__(self, provider_type: Type, available_providers: list[str]):\n    self.provider_type = provider_type\n    self.available_providers = available_providers\n\n    message = (\n        f\"Provider for type '{provider_type.__name__}' not found in container.\\n\"\n        f\"Available providers: {', '.join(available_providers) if available_providers else 'None'}\\n\"\n        f\"Did you forget to decorate {provider_type.__name__} with @singleton or @factory?\"\n    )\n    super().__init__(message)\n</code></pre>"},{"location":"api/ioc/#asyncproviderinsynccontexterror","title":"AsyncProviderInSyncContextError","text":""},{"location":"api/ioc/#R5.ioc.errors.AsyncProviderInSyncContextError","title":"AsyncProviderInSyncContextError","text":"<pre><code>AsyncProviderInSyncContextError(provider_type: Type)\n</code></pre> <p>               Bases: <code>IoCError</code></p> Source code in <code>R5/ioc/errors.py</code> <pre><code>def __init__(self, provider_type: Type):\n    self.provider_type = provider_type\n    super().__init__(\n        f\"Dependency '{provider_type.__name__}' returned an awaitable in sync context. \"\n        f\"Make the function async or ensure the provider is sync.\"\n    )\n</code></pre>"},{"location":"api/ioc/#dependencyinjectionerror","title":"DependencyInjectionError","text":""},{"location":"api/ioc/#R5.ioc.errors.DependencyInjectionError","title":"DependencyInjectionError","text":"<pre><code>DependencyInjectionError(provider_type: Type, param_name: str, func_name: str, original_error: Exception)\n</code></pre> <p>               Bases: <code>IoCError</code></p> Source code in <code>R5/ioc/errors.py</code> <pre><code>def __init__(self, provider_type: Type, param_name: str, func_name: str, original_error: Exception):\n    self.provider_type = provider_type\n    self.param_name = param_name\n    self.func_name = func_name\n    self.original_error = original_error\n\n    super().__init__(\n        f\"Failed to inject dependency '{provider_type.__name__}' \"\n        f\"for parameter '{param_name}' in function '{func_name}': {original_error}\"\n    )\n</code></pre>"},{"location":"examples/patterns/","title":"Patrones de Dise\u00f1o con R5","text":"<p>Patrones que aprovechan las capacidades espec\u00edficas de R5.</p>"},{"location":"examples/patterns/#repository-service-layer","title":"Repository + Service Layer","text":"<pre><code>from abc import ABC, abstractmethod\nfrom R5.ioc import singleton, inject\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    def find(self, user_id: int) -&gt; dict | None: ...\n    @abstractmethod\n    def save(self, user: dict) -&gt; dict: ...\n\n@singleton\nclass UserRepository(IUserRepository):\n    def __init__(self, db: DatabaseService, logger: Logger):\n        self.db = db\n        self.logger = logger\n\n    def find(self, user_id: int):\n        self.logger.info(f\"Finding user {user_id}\")\n        return self.db.query(f\"SELECT * FROM users WHERE id = {user_id}\")\n\n    def save(self, user: dict):\n        self.db.execute(\"INSERT INTO users ...\")\n        return user\n\n@singleton\nclass UserService:\n    def __init__(self, repo: IUserRepository, email: EmailService):\n        self.repo = repo\n        self.email = email\n\n    async def register(self, username: str, email_addr: str):\n        user = self.repo.save({\"username\": username, \"email\": email_addr})\n        await self.email.send(email_addr, \"Welcome\", \"Thanks for joining!\")\n        return user\n\n# Intercambiar implementaci\u00f3n via alias\nContainer.alias_provider(IUserRepository, UserRepository)\n</code></pre>"},{"location":"examples/patterns/#observer-event-bus","title":"Observer / Event Bus","text":"<p>Patr\u00f3n especialmente \u00fatil con Background tasks para procesamiento as\u00edncrono de eventos:</p> <pre><code>@singleton\nclass EventBus:\n    def __init__(self):\n        self.subscribers: dict[str, list[Callable]] = {}\n\n    def subscribe(self, event_type: str, handler: Callable):\n        self.subscribers.setdefault(event_type, []).append(handler)\n\n    async def publish(self, bg: Background, event_type: str, data: dict):\n        for handler in self.subscribers.get(event_type, []):\n            await bg.add(handler, data=data)\n\n# Handlers reciben dependencias via IoC\ndef on_user_registered(logger: Logger, data: dict):\n    logger.info(f\"User registered: {data['email']}\")\n\ndef send_welcome(email: EmailService, data: dict):\n    email.send(data[\"email\"], \"Welcome!\", \"Thanks!\")\n\n@inject\nasync def main(bg: Background, bus: EventBus):\n    bus.subscribe(\"user.registered\", on_user_registered)\n    bus.subscribe(\"user.registered\", send_welcome)\n\n    await bus.publish(bg, \"user.registered\", {\"email\": \"john@example.com\"})\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"examples/patterns/#unit-of-work-resource-scope","title":"Unit of Work (Resource scope)","text":"<p>Aprovecha <code>@resource</code> para transacciones con commit/rollback autom\u00e1tico:</p> <pre><code>@resource\nclass UnitOfWork:\n    def __init__(self, db: DatabaseService):\n        self.db = db\n\n    async def __aenter__(self):\n        await self.db.begin_transaction()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            await self.db.rollback()\n        else:\n            await self.db.commit()\n\n@inject\nasync def create_order(uow: UnitOfWork):\n    # Si algo falla, se hace rollback autom\u00e1ticamente\n    uow.db.execute(\"INSERT INTO orders ...\")\n    uow.db.execute(\"UPDATE inventory ...\")\n</code></pre>"},{"location":"examples/patterns/#strategy-con-ioc","title":"Strategy con IoC","text":"<pre><code>class PaymentStrategy(ABC):\n    @abstractmethod\n    async def process(self, amount: float) -&gt; bool: ...\n\n@singleton\nclass CreditCardPayment(PaymentStrategy):\n    async def process(self, amount: float) -&gt; bool:\n        print(f\"Credit Card: ${amount}\")\n        return True\n\n@singleton\nclass PayPalPayment(PaymentStrategy):\n    async def process(self, amount: float) -&gt; bool:\n        print(f\"PayPal: ${amount}\")\n        return True\n\n@singleton\nclass PaymentService:\n    def __init__(self, cc: CreditCardPayment, paypal: PayPalPayment):\n        self.strategies = {\"credit_card\": cc, \"paypal\": paypal}\n\n    async def pay(self, method: str, amount: float):\n        strategy = self.strategies.get(method)\n        if not strategy:\n            raise ValueError(f\"Unknown method: {method}\")\n        return await strategy.process(amount)\n</code></pre>"},{"location":"examples/patterns/#saga-pattern","title":"Saga Pattern","text":"<p>Para transacciones distribuidas con compensaci\u00f3n:</p> <pre><code>@dataclass\nclass SagaStep:\n    action: Callable\n    compensate: Callable\n\n@singleton\nclass SagaOrchestrator:\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n    async def execute(self, steps: list[SagaStep]):\n        executed = []\n        try:\n            for step in steps:\n                await step.action()\n                executed.append(step)\n        except Exception as e:\n            self.logger.error(f\"Saga failed: {e}\")\n            for step in reversed(executed):\n                await step.compensate()\n            raise\n</code></pre>"},{"location":"examples/patterns/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Ejemplos simples - Ejemplos b\u00e1sicos</li> <li>Ejemplos reales - Aplicaciones completas</li> </ul>"},{"location":"examples/real-world/","title":"Ejemplos del Mundo Real","text":"<p>Aplicaciones completas usando R5.</p>"},{"location":"examples/real-world/#api-rest-con-autenticacion","title":"API REST con Autenticaci\u00f3n","text":"<pre><code># config.py\nfrom R5.ioc import config\n\n@config(file='.env')\nclass AppConfig:\n    database_url: str = \"sqlite:///app.db\"\n    secret_key: str = \"dev-secret\"\n    jwt_algorithm: str = \"HS256\"\n    token_expire_minutes: int = 30\n\n# services.py\nfrom R5.ioc import singleton\nimport jwt\nfrom datetime import datetime, timedelta\n\n@singleton\nclass Logger:\n    def info(self, msg: str): print(f\"[INFO] {msg}\")\n    def error(self, msg: str): print(f\"[ERROR] {msg}\")\n\n@singleton\nclass AuthService:\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n    def create_token(self, user_id: int) -&gt; str:\n        payload = {\n            \"user_id\": user_id,\n            \"exp\": datetime.utcnow() + timedelta(minutes=self.config.token_expire_minutes)\n        }\n        return jwt.encode(payload, self.config.secret_key, algorithm=self.config.jwt_algorithm)\n\n    def verify_token(self, token: str) -&gt; dict:\n        return jwt.decode(token, self.config.secret_key, algorithms=[self.config.jwt_algorithm])\n\n@singleton\nclass DatabaseService:\n    def __init__(self, config: AppConfig, logger: Logger):\n        self.url = config.database_url\n        self.logger = logger\n\n    def connect(self):\n        self.logger.info(f\"Connected to {self.url}\")\n\n# main.py\n@inject\nasync def main(db: DatabaseService, auth: AuthService, logger: Logger):\n    db.connect()\n    token = auth.create_token(user_id=123)\n    payload = auth.verify_token(token)\n    logger.info(f\"Verified user: {payload['user_id']}\")\n</code></pre>"},{"location":"examples/real-world/#web-scraper-concurrente","title":"Web Scraper Concurrente","text":"<pre><code>from R5.http import Http\nfrom R5.ioc import singleton, inject, config\nfrom R5.background import Background\n\n@config(file='.env')\nclass ScraperConfig:\n    max_concurrent: int = 5\n    request_delay: float = 1.0\n\n@singleton\nclass RateLimiter:\n    def __init__(self, config: ScraperConfig):\n        self.semaphore = asyncio.Semaphore(config.max_concurrent)\n        self.delay = config.request_delay\n\n    async def acquire(self):\n        await self.semaphore.acquire()\n        await asyncio.sleep(self.delay)\n\n    def release(self):\n        self.semaphore.release()\n\n@singleton\nclass Scraper:\n    def __init__(self, http: Http, limiter: RateLimiter):\n        self.http = http\n        self.limiter = limiter\n\n    async def scrape(self, url: str) -&gt; dict | None:\n        await self.limiter.acquire()\n        try:\n            result = await self.http.retry(attempts=3, delay=1.0).get(url)\n            if result.status == 200:\n                return {\"url\": url, \"status\": 200, \"size\": len(result.response.text)}\n            return None\n        finally:\n            self.limiter.release()\n\n@inject\nasync def main(scraper: Scraper):\n    urls = [\"https://example.com\", \"https://example.org\", \"https://example.net\"]\n    results = await asyncio.gather(*[scraper.scrape(url) for url in urls])\n    for r in results:\n        if r:\n            print(f\"{r['url']}: {r['size']} bytes\")\n</code></pre>"},{"location":"examples/real-world/#sistema-de-notificaciones-multi-canal","title":"Sistema de Notificaciones Multi-Canal","text":"<pre><code>from abc import ABC, abstractmethod\nfrom enum import Enum\n\nclass Channel(Enum):\n    EMAIL = \"email\"\n    SMS = \"sms\"\n    PUSH = \"push\"\n\nclass NotificationProvider(ABC):\n    @abstractmethod\n    async def send(self, recipient: str, message: str): ...\n\n@singleton\nclass EmailProvider(NotificationProvider):\n    async def send(self, recipient: str, message: str):\n        print(f\"Email to {recipient}: {message}\")\n\n@singleton\nclass SMSProvider(NotificationProvider):\n    async def send(self, recipient: str, message: str):\n        print(f\"SMS to {recipient}: {message}\")\n\n@singleton\nclass PushProvider(NotificationProvider):\n    async def send(self, recipient: str, message: str):\n        print(f\"Push to {recipient}: {message}\")\n\n@singleton\nclass NotificationService:\n    def __init__(self, email: EmailProvider, sms: SMSProvider, push: PushProvider):\n        self.providers = {\n            Channel.EMAIL: email,\n            Channel.SMS: sms,\n            Channel.PUSH: push,\n        }\n\n    async def send(self, channel: Channel, recipient: str, message: str):\n        provider = self.providers.get(channel)\n        if provider:\n            await provider.send(recipient, message)\n\n@inject\nasync def main(bg: Background, notif: NotificationService):\n    notifications = [\n        (Channel.EMAIL, \"user@example.com\", \"Welcome!\"),\n        (Channel.SMS, \"+1234567890\", \"Code: 123456\"),\n        (Channel.PUSH, \"device_token\", \"New message\"),\n    ]\n    for channel, recipient, msg in notifications:\n        await bg.add(notif.send, channel, recipient, msg)\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"examples/real-world/#task-queue-con-prioridades","title":"Task Queue con Prioridades","text":"<pre><code>from enum import Enum\nfrom dataclasses import dataclass\n\nclass Priority(Enum):\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n    CRITICAL = 3\n\n@dataclass\nclass Job:\n    id: int\n    name: str\n    handler: Callable\n    args: tuple\n    priority: Priority\n\n@singleton\nclass TaskQueue:\n    def __init__(self):\n        self.jobs: list[Job] = []\n        self.completed: set[int] = set()\n\n    def add(self, name: str, handler: Callable, priority: Priority = Priority.NORMAL, *args):\n        job = Job(len(self.jobs) + 1, name, handler, args, priority)\n        self.jobs.append(job)\n\n    def next(self) -&gt; Job | None:\n        pending = [j for j in self.jobs if j.id not in self.completed]\n        if not pending:\n            return None\n        pending.sort(key=lambda j: j.priority.value, reverse=True)\n        return pending[0]\n\n    def done(self, job_id: int):\n        self.completed.add(job_id)\n\n@inject\nasync def main(bg: Background, queue: TaskQueue):\n    queue.add(\"alert\", send_alert, Priority.CRITICAL, \"System down\")\n    queue.add(\"email\", send_email, Priority.HIGH, \"user@example.com\")\n    queue.add(\"cleanup\", cleanup, Priority.LOW)\n\n    while job := queue.next():\n        await bg.add(lambda j=job: (j.handler(*j.args), queue.done(j.id)))\n\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"examples/real-world/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Ejemplos simples - Ejemplos b\u00e1sicos</li> <li>Patrones - Patrones de dise\u00f1o</li> </ul>"},{"location":"examples/simple/","title":"Ejemplos Simples","text":"<p>Ejemplos b\u00e1sicos para empezar con R5. Para detalles de cada m\u00f3dulo, consulta las gu\u00edas espec\u00edficas.</p>"},{"location":"examples/simple/#ioc-hello-world","title":"IoC - Hello World","text":"<pre><code>import asyncio\nfrom R5.ioc import singleton, inject\n\n@singleton\nclass GreetingService:\n    def greet(self, name: str) -&gt; str:\n        return f\"Hello, {name}!\"\n\n@inject\nasync def main(service: GreetingService):\n    print(service.greet(\"World\"))\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/simple/#http-fetch-y-mapeo-a-dto","title":"HTTP - Fetch y Mapeo a DTO","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom R5.http import Http\nfrom R5.ioc import inject\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n\n@inject\nasync def main(http: Http):\n    user = (await http.get(\"https://jsonplaceholder.typicode.com/users/1\")).to(User)\n    if user:\n        print(f\"{user.name} ({user.email})\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/simple/#background-tareas-en-paralelo","title":"Background - Tareas en Paralelo","text":"<pre><code>import asyncio\nfrom R5.background import Background\nfrom R5.ioc import inject\n\ndef process(item_id: int):\n    print(f\"Processing {item_id}\")\n\n@inject\nasync def main(bg: Background):\n    for i in range(5):\n        await bg.add(process, i)\n    await asyncio.sleep(1)\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/simple/#configuration","title":"Configuration","text":"<pre><code>from R5.ioc import config, inject\n\n@config(file='.env')\nclass AppConfig:\n    app_name: str = \"MyApp\"\n    port: int = 3000\n    debug: bool = False\n\n@inject\nasync def main(cfg: AppConfig):\n    print(f\"{cfg.app_name} on port {cfg.port}\")\n</code></pre>"},{"location":"examples/simple/#requests-concurrentes","title":"Requests Concurrentes","text":"<pre><code>import asyncio\nfrom R5.http import Http\nfrom R5.ioc import inject\n\n@inject\nasync def main(http: Http):\n    results = await asyncio.gather(*[\n        http.get(f\"https://jsonplaceholder.typicode.com/users/{i}\")\n        for i in range(1, 4)\n    ])\n    for r in results:\n        user = r.to(dict)\n        if user:\n            print(user[\"name\"])\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/simple/#guias-detalladas","title":"Gu\u00edas detalladas","text":"<ul> <li>IoC Container - Inyecci\u00f3n de dependencias</li> <li>HTTP Client - Cliente HTTP</li> <li>Background Tasks - Tareas concurrentes</li> <li>Patrones - Patrones de dise\u00f1o con R5</li> <li>Ejemplos reales - Aplicaciones completas</li> </ul>"},{"location":"getting-started/core-concepts/","title":"Conceptos Fundamentales","text":"<p>R5 est\u00e1 construido sobre tres pilares:</p> <pre><code>graph TB\n    A[R5 Framework] --&gt; B[IoC Container]\n    A --&gt; C[HTTP Client]\n    A --&gt; D[Background Tasks]</code></pre>"},{"location":"getting-started/core-concepts/#ioc-container","title":"IoC Container","text":"<p>Gesti\u00f3n autom\u00e1tica de dependencias basada en type hints. Registras servicios con decoradores y se inyectan autom\u00e1ticamente.</p> <pre><code>from R5.ioc import singleton, inject\n\n@singleton\nclass UserService:\n    def __init__(self, db: DatabaseService):\n        self.db = db\n\n@inject\nasync def handler(service: UserService, user_id: int):\n    return service.find(user_id)\n\nawait handler(user_id=123)  # UserService y DatabaseService se inyectan\n</code></pre> <p>Scopes: <code>@singleton</code> (una instancia), <code>@factory</code> (nueva cada vez), <code>@resource</code> (con lifecycle/cleanup)</p> <p>Configuraci\u00f3n: <code>@config(file='.env')</code> carga desde .env, .json, .yml, .properties</p> <p>Ver Gu\u00eda IoC para detalles.</p>"},{"location":"getting-started/core-concepts/#http-client","title":"HTTP Client","text":"<p>Cliente as\u00edncrono con connection pooling, retry y Result pattern (sin excepciones):</p> <pre><code>from R5.http import Http\nfrom R5.ioc import inject\n\n@inject\nasync def fetch(http: Http):\n    result = await http.retry(attempts=3).get(\"https://api.example.com/users/1\")\n\n    user = result.to(User)           # Mapeo autom\u00e1tico a DTO\n    result.on_status(404, handle_404) # Handler por status\n    result.on_exception(log_error)    # Handler de errores\n</code></pre> <p>Ver Gu\u00eda HTTP para detalles.</p>"},{"location":"getting-started/core-concepts/#background-tasks","title":"Background Tasks","text":"<p>Ejecuci\u00f3n concurrente de tareas con anyio. Soporta sync (thread pool) y async (event loop), con inyecci\u00f3n IoC en las tareas:</p> <pre><code>from R5.background import Background\n\ndef task(logger: Logger, item_id: int):\n    logger.log(f\"Processing {item_id}\")  # Logger inyectado\n\n@inject\nasync def main(bg: Background):\n    for i in range(10):\n        await bg.add(task, item_id=i)\n    await asyncio.sleep(1)\n</code></pre> <p>Ver Gu\u00eda Background para detalles.</p>"},{"location":"getting-started/core-concepts/#principios-de-diseno","title":"Principios de Dise\u00f1o","text":"<ul> <li>Simplicidad - Solo decoradores, sin configuraci\u00f3n XML</li> <li>Type-safe - Resoluci\u00f3n autom\u00e1tica via type hints</li> <li>Modularidad - Usa solo lo que necesitas: <code>from R5.ioc import ...</code>, <code>from R5.http import ...</code></li> <li>Expl\u00edcito - Las dependencias son visibles en la firma de la funci\u00f3n</li> </ul>"},{"location":"getting-started/core-concepts/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>IoC Container - Inyecci\u00f3n de dependencias</li> <li>HTTP Client - Cliente HTTP</li> <li>Background Tasks - Tareas concurrentes</li> </ul>"},{"location":"getting-started/installation/","title":"Instalaci\u00f3n","text":"<p>Esta gu\u00eda te muestra c\u00f3mo instalar R5 en tu proyecto.</p>"},{"location":"getting-started/installation/#requisitos","title":"Requisitos","text":"<ul> <li>Python 3.14 o superior</li> <li><code>pip</code> o <code>uv</code> como gestor de paquetes</li> </ul>"},{"location":"getting-started/installation/#instalacion-con-pip","title":"Instalaci\u00f3n con pip","text":"<pre><code>pip install r5\n</code></pre>"},{"location":"getting-started/installation/#instalacion-con-uv-recomendado","title":"Instalaci\u00f3n con uv (Recomendado)","text":"<p>uv es un gestor de paquetes ultra r\u00e1pido para Python.</p> <pre><code># Instalar uv si no lo tienes\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Agregar R5 a tu proyecto\nuv add r5\n</code></pre>"},{"location":"getting-started/installation/#instalacion-desde-el-codigo-fuente","title":"Instalaci\u00f3n desde el c\u00f3digo fuente","text":"<pre><code>git clone https://github.com/grupor5/R5.git\ncd R5\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#dependencias","title":"Dependencias","text":"<p>R5 instala autom\u00e1ticamente las siguientes dependencias:</p> <ul> <li>anyio (&gt;=4.12.0) - Para tareas concurrentes</li> <li>dependency-injector (&gt;=4.48.3) - Motor de IoC</li> <li>httpx (&gt;=0.28.1) - Cliente HTTP as\u00edncrono</li> <li>pydantic (&gt;=2.12.5) - Validaci\u00f3n de datos</li> <li>pydantic-settings (&gt;=2.12.0) - Gesti\u00f3n de configuraci\u00f3n</li> <li>pyyaml (&gt;=6.0.3) - Soporte para archivos YAML</li> </ul>"},{"location":"getting-started/installation/#verificar-la-instalacion","title":"Verificar la instalaci\u00f3n","text":"<p>Verifica que R5 se instal\u00f3 correctamente:</p> <pre><code>import R5\nfrom R5.ioc import singleton, inject\nfrom R5.http import Http\nfrom R5.background import Background\n\nprint(\"\u2705 R5 instalado correctamente\")\n</code></pre>"},{"location":"getting-started/installation/#dependencias-opcionales","title":"Dependencias opcionales","text":""},{"location":"getting-started/installation/#para-desarrollo","title":"Para desarrollo","text":"<pre><code>uv add --dev pytest pytest-asyncio pytest-cov\n</code></pre>"},{"location":"getting-started/installation/#para-documentacion","title":"Para documentaci\u00f3n","text":"<pre><code>uv add --group docs mkdocs mkdocs-material mkdocstrings[python]\n</code></pre>"},{"location":"getting-started/installation/#actualizar-r5","title":"Actualizar R5","text":""},{"location":"getting-started/installation/#con-pip","title":"Con pip","text":"<pre><code>pip install --upgrade r5\n</code></pre>"},{"location":"getting-started/installation/#con-uv","title":"Con uv","text":"<pre><code>uv add --upgrade r5\n</code></pre>"},{"location":"getting-started/installation/#desinstalacion","title":"Desinstalaci\u00f3n","text":""},{"location":"getting-started/installation/#con-pip_1","title":"Con pip","text":"<pre><code>pip uninstall r5\n</code></pre>"},{"location":"getting-started/installation/#con-uv_1","title":"Con uv","text":"<pre><code>uv remove r5\n</code></pre>"},{"location":"getting-started/installation/#proximos-pasos","title":"Pr\u00f3ximos pasos","text":"<p>Una vez instalado R5, contin\u00faa con:</p> <ul> <li>Quick Start - Tu primera aplicaci\u00f3n con R5</li> <li>Core Concepts - Conceptos fundamentales del framework</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Aprende los fundamentos de R5 en 5 minutos.</p>"},{"location":"getting-started/quickstart/#tu-primera-aplicacion","title":"Tu primera aplicaci\u00f3n","text":"<pre><code>import asyncio\nfrom R5.ioc import singleton, inject\n\n@singleton\nclass GreetingService:\n    def greet(self, name: str) -&gt; str:\n        return f\"Hello, {name}!\"\n\n@inject\nasync def main(service: GreetingService):\n    print(service.greet(\"World\"))\n\nasyncio.run(main())\n</code></pre> <pre><code>uv run python app.py\n# Output: Hello, World!\n</code></pre>"},{"location":"getting-started/quickstart/#con-http-client","title":"Con HTTP Client","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom R5.http import Http\nfrom R5.ioc import inject\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n\n@inject\nasync def main(http: Http):\n    user = (await http.get(\"https://jsonplaceholder.typicode.com/users/1\")).to(User)\n    if user:\n        print(f\"{user.name} ({user.email})\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#ejemplo-completo-ioc-http-background","title":"Ejemplo Completo (IoC + HTTP + Background)","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom R5.ioc import singleton, inject, config\nfrom R5.http import Http\nfrom R5.background import Background\n\n@config(file='.env')\nclass AppConfig:\n    api_url: str = \"https://jsonplaceholder.typicode.com\"\n\n@singleton\nclass Logger:\n    def log(self, msg: str): print(f\"[LOG] {msg}\")\n\n@dataclass\nclass Post:\n    id: int\n    title: str\n    userId: int\n\n@inject\nasync def main(config: AppConfig, http: Http, bg: Background, log: Logger):\n    log.log(\"Started\")\n\n    post = (await http.get(f\"{config.api_url}/posts/1\")).to(Post)\n    if post:\n        log.log(f\"Fetched: {post.title}\")\n        await bg.add(lambda: log.log(f\"Processing post #{post.id}\"))\n\n    await asyncio.sleep(0.3)\n    log.log(\"Done\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#estructura-de-proyecto-recomendada","title":"Estructura de proyecto recomendada","text":"<pre><code>my_project/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2502   \u2514\u2500\u2500 email_service.py\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u2514\u2500\u2500 main.py\n\u251c\u2500\u2500 tests/\n\u251c\u2500\u2500 .env\n\u2514\u2500\u2500 pyproject.toml\n</code></pre>"},{"location":"getting-started/quickstart/#siguientes-pasos","title":"Siguientes pasos","text":"<ul> <li>Core Concepts - Arquitectura del framework</li> <li>IoC Container - Dependency injection</li> <li>HTTP Client - Cliente HTTP</li> <li>Background Tasks - Tareas concurrentes</li> </ul>"},{"location":"guides/background/basic-usage/","title":"Background Tasks - Uso B\u00e1sico","text":""},{"location":"guides/background/basic-usage/#setup","title":"Setup","text":"<p>Background se inyecta autom\u00e1ticamente via IoC:</p> <pre><code>from R5.background import Background\nfrom R5.ioc import inject\nimport asyncio\n\n@inject\nasync def my_service(bg: Background):\n    await bg.add(my_task, \"arg1\")\n    await asyncio.sleep(1)  # Esperar a que terminen\n</code></pre>"},{"location":"guides/background/basic-usage/#tareas-sincronas","title":"Tareas S\u00edncronas","text":"<p>Ejecutan en thread pool autom\u00e1ticamente:</p> <pre><code>def process_order(order_id: int, user_id: int, amount: float):\n    print(f\"Processing order {order_id}: ${amount}\")\n    time.sleep(0.2)\n\n@inject\nasync def queue_orders(bg: Background):\n    await bg.add(process_order, 1, 100, 99.99)\n    await bg.add(process_order, 2, 101, 149.99)\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/basic-usage/#tareas-asincronas","title":"Tareas As\u00edncronas","text":"<p>Ejecutan en el event loop:</p> <pre><code>async def fetch_and_process(url: str):\n    await asyncio.sleep(0.1)\n    print(f\"Processed: {url}\")\n\n@inject\nasync def queue_fetches(bg: Background):\n    await bg.add(fetch_and_process, \"https://api.example.com/data/1\")\n    await bg.add(fetch_and_process, \"https://api.example.com/data/2\")\n    await asyncio.sleep(2)\n</code></pre> <p>Background detecta autom\u00e1ticamente si la tarea es sync o async.</p>"},{"location":"guides/background/basic-usage/#batch-processing","title":"Batch Processing","text":"<pre><code>@inject\nasync def batch(bg: Background):\n    for i in range(100):\n        await bg.add(process_item, i)\n\n    print(\"100 tasks queued\")\n    await asyncio.sleep(5)\n</code></pre>"},{"location":"guides/background/basic-usage/#manejo-de-errores","title":"Manejo de Errores","text":"<p>Los errores en una tarea no detienen las dem\u00e1s:</p> <pre><code>def failing_task():\n    raise Exception(\"Failed\")\n\ndef ok_task():\n    print(\"This still runs\")\n\n@inject\nasync def with_errors(bg: Background):\n    await bg.add(failing_task)   # Falla, se loguea como WARNING\n    await bg.add(ok_task)        # Se ejecuta normalmente\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/basic-usage/#retry-dentro-de-la-tarea","title":"Retry dentro de la tarea","text":"<pre><code>def task_with_retry(item_id: int, max_retries: int = 3):\n    for attempt in range(max_retries):\n        try:\n            process_item(item_id)\n            break\n        except Exception:\n            if attempt == max_retries - 1:\n                raise\n            time.sleep(2 ** attempt)\n</code></pre>"},{"location":"guides/background/basic-usage/#lifecycle","title":"Lifecycle","text":"<pre><code># Autom\u00e1tico via @inject\n@inject\nasync def auto(bg: Background):\n    await bg.add(task1)\n    await asyncio.sleep(1)\n\n# Manual via context manager\nasync def manual():\n    bg = Container.resolve(Background)\n    async with bg:\n        await bg.add(task1)\n        await asyncio.sleep(1)\n    # Cleanup autom\u00e1tico\n</code></pre>"},{"location":"guides/background/basic-usage/#ejemplo-envio-de-emails","title":"Ejemplo: Env\u00edo de Emails","text":"<pre><code>def send_email(to: str, subject: str, body: str):\n    print(f\"Sending to {to}: {subject}\")\n    time.sleep(0.2)\n\n@inject\nasync def send_welcome_emails(bg: Background):\n    users = [(\"user1@example.com\", \"John\"), (\"user2@example.com\", \"Jane\")]\n\n    for email, name in users:\n        await bg.add(send_email, email, \"Welcome!\", f\"Hi {name}!\")\n\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/basic-usage/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>IoC Integration - Inyecci\u00f3n de dependencias en tareas</li> <li>Overview - Arquitectura y caracter\u00edsticas</li> </ul>"},{"location":"guides/background/ioc-integration/","title":"Background Tasks - Integraci\u00f3n con IoC","text":"<p>Las tareas en Background reciben dependencias inyectadas autom\u00e1ticamente.</p>"},{"location":"guides/background/ioc-integration/#inyeccion-automatica","title":"Inyecci\u00f3n Autom\u00e1tica","text":"<p>Background detecta type hints registrados en el container y los resuelve:</p> <pre><code>@singleton\nclass EmailService:\n    def send(self, to: str, subject: str):\n        print(f\"Email to {to}: {subject}\")\n\ndef send_welcome(email_service: EmailService, user_email: str):\n    email_service.send(user_email, \"Welcome!\")\n\n@inject\nasync def main(bg: Background):\n    # EmailService se inyecta, user_email se pasa manualmente\n    await bg.add(send_welcome, user_email=\"user@example.com\")\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"guides/background/ioc-integration/#multiples-dependencias","title":"M\u00faltiples Dependencias","text":"<pre><code>def process_order(logger: Logger, db: Database, order_id: int):\n    logger.log(f\"Processing order {order_id}\")\n    db.save(f\"order_{order_id}\")\n\n@inject\nasync def queue(bg: Background):\n    await bg.add(process_order, order_id=123)  # Logger y DB se inyectan\n</code></pre>"},{"location":"guides/background/ioc-integration/#async-tasks-con-ioc","title":"Async Tasks con IoC","text":"<pre><code>async def fetch_and_log(http: Http, logger: Logger, url: str):\n    logger.log(f\"Fetching {url}\")\n    result = await http.get(url)\n    logger.log(f\"Status: {result.status}\")\n\n@inject\nasync def queue_fetches(bg: Background):\n    await bg.add(fetch_and_log, url=\"https://api.example.com/data\")\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"guides/background/ioc-integration/#scopes-en-background","title":"Scopes en Background","text":""},{"location":"guides/background/ioc-integration/#singleton-instancia-compartida-entre-tareas","title":"Singleton - Instancia compartida entre tareas","text":"<pre><code>@singleton\nclass Counter:\n    def __init__(self):\n        self.count = 0\n\n    def increment(self):\n        self.count += 1\n\ndef task(counter: Counter):\n    counter.increment()\n    print(f\"Count: {counter.count}\")\n\n# Todas las tareas usan el mismo Counter\n</code></pre>"},{"location":"guides/background/ioc-integration/#factory-nueva-instancia-por-tarea","title":"Factory - Nueva instancia por tarea","text":"<pre><code>@factory\nclass RequestContext:\n    def __init__(self):\n        self.id = uuid4()\n\ndef task(ctx: RequestContext, item_id: int):\n    print(f\"Item {item_id} with context {ctx.id}\")\n\n# Cada tarea recibe un RequestContext diferente\n</code></pre>"},{"location":"guides/background/ioc-integration/#config-en-tareas","title":"Config en tareas","text":"<pre><code>@config(file='.env')\nclass AppConfig:\n    api_key: str = \"\"\n\ndef api_call(config: AppConfig, endpoint: str):\n    print(f\"Calling {endpoint} with key {config.api_key}\")\n</code></pre>"},{"location":"guides/background/ioc-integration/#ejemplo-worker-queue","title":"Ejemplo: Worker Queue","text":"<pre><code>@singleton\nclass JobRepository:\n    def get_pending(self):\n        return [\n            {\"id\": 1, \"type\": \"email\", \"data\": \"user@example.com\"},\n            {\"id\": 2, \"type\": \"sms\", \"data\": \"+1234567890\"},\n        ]\n\n    def mark_done(self, job_id: int):\n        print(f\"Job {job_id} done\")\n\n@singleton\nclass NotificationService:\n    def send_email(self, email: str): print(f\"Email to {email}\")\n    def send_sms(self, phone: str): print(f\"SMS to {phone}\")\n\ndef process_job(repo: JobRepository, notif: NotificationService, job: dict):\n    if job[\"type\"] == \"email\":\n        notif.send_email(job[\"data\"])\n    elif job[\"type\"] == \"sms\":\n        notif.send_sms(job[\"data\"])\n    repo.mark_done(job[\"id\"])\n\n@inject\nasync def worker(bg: Background, repo: JobRepository):\n    for job in repo.get_pending():\n        await bg.add(process_job, job=job)\n    await asyncio.sleep(2)\n</code></pre>"},{"location":"guides/background/ioc-integration/#testing","title":"Testing","text":"<pre><code>def test_background_with_mocks():\n    Container.reset()\n\n    @singleton\n    class MockLogger:\n        def __init__(self):\n            self.logs = []\n        def log(self, msg: str):\n            self.logs.append(msg)\n\n    def task(logger: MockLogger, message: str):\n        logger.log(message)\n\n    async def run():\n        bg = Container.resolve(Background)\n        logger = Container.resolve(MockLogger)\n        async with bg:\n            await bg.add(task, message=\"test\")\n            await asyncio.sleep(0.5)\n        assert \"test\" in logger.logs\n\n    asyncio.run(run())\n</code></pre>"},{"location":"guides/background/ioc-integration/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Basic Usage - Tareas sync, async, errores</li> <li>Overview - Arquitectura</li> </ul>"},{"location":"guides/background/overview/","title":"Background Tasks - Overview","text":"<p>Ejecuta tareas en paralelo con anyio, soporte para sync/async y inyecci\u00f3n IoC.</p>"},{"location":"guides/background/overview/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Ejecuci\u00f3n concurrente con anyio TaskGroup</li> <li>Sync y Async - Sync ejecuta en thread pool, async en event loop</li> <li>Inyecci\u00f3n IoC - Las tareas reciben dependencias autom\u00e1ticamente</li> <li>Error handling - Errores no detienen otras tareas</li> <li>Lifecycle management - Context manager integrado</li> </ul>"},{"location":"guides/background/overview/#arquitectura","title":"Arquitectura","text":"<pre><code>graph TB\n    A[Background] --&gt; B[TaskGroup]\n    A --&gt; C[Thread Pool]\n    A --&gt; D[IoC Integration]\n\n    B --&gt; E[Async Tasks]\n    C --&gt; F[Sync Tasks]\n    E --&gt; G[Concurrent Execution]\n    F --&gt; G</code></pre>"},{"location":"guides/background/overview/#ejemplo-rapido","title":"Ejemplo R\u00e1pido","text":"<pre><code>from R5.background import Background\nfrom R5.ioc import singleton, inject\n\n@singleton\nclass Logger:\n    def log(self, msg: str): print(msg)\n\ndef process(logger: Logger, item_id: int):\n    logger.log(f\"Processing {item_id}\")  # Logger inyectado autom\u00e1ticamente\n\n@inject\nasync def main(bg: Background):\n    await bg.add(process, item_id=1)\n    await bg.add(process, item_id=2)\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"guides/background/overview/#limitaciones","title":"Limitaciones","text":"<ul> <li>No retorna valores - Usa callbacks o side effects</li> <li>No garantiza orden - Las tareas se ejecutan concurrentemente</li> </ul>"},{"location":"guides/background/overview/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Basic Usage - Tareas sync, async, errores, patrones</li> <li>IoC Integration - Inyecci\u00f3n de dependencias en tareas</li> </ul>"},{"location":"guides/http/advanced/","title":"HTTP Client - Caracter\u00edsticas Avanzadas","text":""},{"location":"guides/http/advanced/#retry-automatico","title":"Retry Autom\u00e1tico","text":"<pre><code>@inject\nasync def fetch_with_retry(http: Http):\n    result = await http.retry(\n        attempts=5,\n        delay=0.5,\n        backoff=2.0,\n        when_status=(429, 500, 502, 503, 504),\n        when_exception=(httpx.TimeoutException, httpx.NetworkError)\n    ).get(\"https://api.example.com/data\")\n\n    return result\n</code></pre> Par\u00e1metro Descripci\u00f3n Default <code>attempts</code> N\u00famero m\u00e1ximo de intentos 3 <code>delay</code> Delay inicial entre intentos (segundos) 1.0 <code>backoff</code> Multiplicador exponencial del delay 2.0 <code>when_status</code> Tupla de status codes que disparan retry <code>()</code> <code>when_exception</code> Tupla de excepciones que disparan retry <code>()</code> <p>Ejemplo de backoff: delay=1.0, backoff=2.0 \u2192 esperas de 1s, 2s, 4s, 8s...</p>"},{"location":"guides/http/advanced/#handlers-globales","title":"Handlers Globales","text":"<p>Se ejecutan en todas las requests del cliente:</p> <pre><code>@inject\nasync def setup_handlers(http: Http):\n    # Before: se ejecuta antes de cada request\n    http.on_before(lambda req: print(f\"\u2192 {req.method} {req.url}\"))\n\n    # After: se ejecuta despu\u00e9s de cada request exitosa\n    http.on_after(lambda req, res: print(f\"\u2190 {res.status_code}\"))\n\n    # M\u00faltiples handlers se ejecutan en orden de registro\n    http.on_before(lambda req: metrics.record_request(req))\n</code></pre>"},{"location":"guides/http/advanced/#ejemplo-metricas","title":"Ejemplo: M\u00e9tricas","text":"<pre><code>@dataclass\nclass RequestMetrics:\n    total: int = 0\n    successful: int = 0\n    failed: int = 0\n\n@inject\nasync def track_metrics(http: Http):\n    metrics = RequestMetrics()\n\n    def before(request):\n        request._start_time = time.time()\n\n    def after(request, response):\n        metrics.total += 1\n        if 200 &lt;= response.status_code &lt; 300:\n            metrics.successful += 1\n        else:\n            metrics.failed += 1\n\n    http.on_before(before)\n    http.on_after(after)\n</code></pre>"},{"location":"guides/http/advanced/#configuracion-avanzada","title":"Configuraci\u00f3n Avanzada","text":""},{"location":"guides/http/advanced/#httpconfig","title":"HttpConfig","text":"<pre><code>from R5.ioc import config\nfrom R5.http.http import HttpConfig\n\n@config(file='.env')\nclass ProductionHttpConfig(HttpConfig):\n    max_connections: int = 200\n    max_keepalive_connections: int = 50\n    keepalive_expiry: float = 10.0\n    connect_timeout: float = 10.0\n    read_timeout: float = 60.0\n    write_timeout: float = 60.0\n    pool_timeout: float = 10.0\n    follow_redirects: bool = True\n    default_headers: dict[str, str] = {\n        \"User-Agent\": \"MyApp/1.0\",\n        \"Accept\": \"application/json\"\n    }\n</code></pre>"},{"location":"guides/http/advanced/#proxy-rotation","title":"Proxy Rotation","text":"<pre><code>@config(file='.env')\nclass ProxyConfig(HttpConfig):\n    proxies: list[str] = [\n        \"http://proxy1.example.com:8080\",\n        \"http://proxy2.example.com:8080\",\n        \"http://proxy3.example.com:8080\"\n    ]\n    proxy_rotation: bool = True  # Round-robin autom\u00e1tico\n</code></pre> <pre><code># .env\nPROXIES=http://proxy1:8080,http://proxy2:8080,http://proxy3:8080\nPROXY_ROTATION=true\n</code></pre>"},{"location":"guides/http/advanced/#rate-limiting","title":"Rate Limiting","text":"<pre><code>from asyncio import Semaphore\n\n@inject\nasync def rate_limited(http: Http):\n    semaphore = Semaphore(5)  # M\u00e1ximo 5 concurrentes\n\n    async def limited_get(url: str):\n        async with semaphore:\n            result = await http.get(url)\n            await asyncio.sleep(0.2)\n            return result\n\n    tasks = [limited_get(f\"https://api.example.com/items/{i}\") for i in range(100)]\n    return await asyncio.gather(*tasks)\n</code></pre>"},{"location":"guides/http/advanced/#circuit-breaker","title":"Circuit Breaker","text":"<pre><code>from enum import Enum\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"\n    OPEN = \"open\"\n    HALF_OPEN = \"half_open\"\n\nclass CircuitBreaker:\n    def __init__(self, failure_threshold: int = 5, timeout: float = 60.0):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n        self.last_failure_time = None\n\n    def record_success(self):\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n\n    def record_failure(self):\n        self.failures += 1\n        self.last_failure_time = time.time()\n        if self.failures &gt;= self.failure_threshold:\n            self.state = CircuitState.OPEN\n\n    def can_attempt(self) -&gt; bool:\n        if self.state == CircuitState.CLOSED:\n            return True\n        if self.state == CircuitState.OPEN:\n            if time.time() - self.last_failure_time &gt;= self.timeout:\n                self.state = CircuitState.HALF_OPEN\n                return True\n            return False\n        return True  # HALF_OPEN\n</code></pre>"},{"location":"guides/http/advanced/#autenticacion-avanzada","title":"Autenticaci\u00f3n Avanzada","text":""},{"location":"guides/http/advanced/#oauth-20-con-auto-refresh","title":"OAuth 2.0 con Auto-Refresh","text":"<pre><code>@singleton\nclass OAuth2Manager:\n    def __init__(self):\n        self.access_token = None\n        self.refresh_token = None\n        self.expires_at = 0\n\n    async def get_token(self, http: Http) -&gt; str:\n        if time.time() &lt; self.expires_at:\n            return self.access_token\n\n        result = await http.post(\n            \"https://auth.example.com/oauth/token\",\n            json={\n                \"grant_type\": \"refresh_token\",\n                \"refresh_token\": self.refresh_token,\n                \"client_id\": \"your-client-id\"\n            }\n        )\n        data = result.to(dict)\n        self.access_token = data[\"access_token\"]\n        self.expires_at = time.time() + data[\"expires_in\"]\n        return self.access_token\n</code></pre>"},{"location":"guides/http/advanced/#caching-de-responses","title":"Caching de Responses","text":"<pre><code>@singleton\nclass ResponseCache:\n    def __init__(self):\n        self._cache: dict[str, tuple[float, Any]] = {}\n        self.ttl = 300  # 5 minutos\n\n    def get(self, url: str) -&gt; Any | None:\n        if url in self._cache:\n            ts, value = self._cache[url]\n            if time.time() - ts &lt; self.ttl:\n                return value\n        return None\n\n    def set(self, url: str, value: Any):\n        self._cache[url] = (time.time(), value)\n\n@inject\nasync def cached_get(http: Http, cache: ResponseCache):\n    cached = cache.get(url)\n    if cached:\n        return cached\n\n    result = await http.get(url)\n    data = result.to(dict)\n    cache.set(url, data)\n    return data\n</code></pre>"},{"location":"guides/http/advanced/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Result Pattern - Manejo de respuestas y errores</li> <li>Basic Usage - Uso b\u00e1sico del cliente</li> </ul>"},{"location":"guides/http/basic-usage/","title":"HTTP Client - Uso B\u00e1sico","text":""},{"location":"guides/http/basic-usage/#setup","title":"Setup","text":"<p>El cliente HTTP se inyecta autom\u00e1ticamente via IoC:</p> <pre><code>from R5.http import Http\nfrom R5.ioc import inject\n\n@inject\nasync def my_function(http: Http):\n    result = await http.get(\"https://api.example.com/data\")\n    return result\n</code></pre>"},{"location":"guides/http/basic-usage/#get-requests","title":"GET Requests","text":"<pre><code>@inject\nasync def fetch_data(http: Http):\n    # Simple\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    # Con query params, headers y timeout\n    result = await http.get(\n        \"https://api.example.com/users\",\n        params={\"page\": 1, \"limit\": 10, \"sort\": \"name:asc\"},\n        headers={\n            \"Authorization\": \"Bearer eyJhbGc...\",\n            \"Accept\": \"application/json\"\n        },\n        timeout=5.0\n    )\n</code></pre>"},{"location":"guides/http/basic-usage/#post-requests","title":"POST Requests","text":"<pre><code>@inject\nasync def create_data(http: Http):\n    # JSON\n    result = await http.post(\n        \"https://api.example.com/users\",\n        json={\"name\": \"John Doe\", \"email\": \"john@example.com\"}\n    )\n\n    # Form data\n    result = await http.post(\n        \"https://api.example.com/form\",\n        data={\"username\": \"johndoe\", \"password\": \"secret123\"}\n    )\n    # Content-Type: application/x-www-form-urlencoded\n\n    # Bytes (upload)\n    with open(\"image.jpg\", \"rb\") as f:\n        result = await http.post(\n            \"https://api.example.com/upload\",\n            content=f.read(),\n            headers={\"Content-Type\": \"image/jpeg\"}\n        )\n</code></pre>"},{"location":"guides/http/basic-usage/#put-patch-delete","title":"PUT / PATCH / DELETE","text":"<pre><code>@inject\nasync def other_methods(http: Http):\n    # PUT - reemplazo completo\n    result = await http.put(\n        \"https://api.example.com/users/1\",\n        json={\"name\": \"Jane Doe\", \"email\": \"jane@example.com\"}\n    )\n\n    # PATCH - actualizaci\u00f3n parcial\n    result = await http.patch(\n        \"https://api.example.com/users/1\",\n        json={\"email\": \"newemail@example.com\"}\n    )\n\n    # DELETE\n    result = await http.delete(\"https://api.example.com/users/1\")\n</code></pre>"},{"location":"guides/http/basic-usage/#mapeo-a-dtos","title":"Mapeo a DTOs","text":"<pre><code>from dataclasses import dataclass\nfrom pydantic import BaseModel\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n\n@inject\nasync def get_user(http: Http):\n    result = await http.get(\"https://jsonplaceholder.typicode.com/users/1\")\n\n    user = result.to(User)       # Dataclass o Pydantic BaseModel\n    data = result.to(dict)       # Dict\n    items = result.to(list)      # List\n\n    if user:\n        print(f\"Name: {user.name}\")\n</code></pre> <p>Ver Result Pattern para detalles sobre <code>to()</code>, handlers y manejo de errores.</p>"},{"location":"guides/http/basic-usage/#handlers-por-request","title":"Handlers por Request","text":"<pre><code>@inject\nasync def with_handlers(http: Http):\n    result = await http.get(\n        \"https://api.example.com/users/1\",\n        on_before=lambda req: print(f\"\u2192 {req.method} {req.url}\"),\n        on_after=lambda req, res: print(f\"\u2190 {res.status_code}\"),\n        on_status={\n            200: lambda: print(\"Success\"),\n            404: lambda: print(\"Not found\")\n        },\n        on_exception=lambda e: print(f\"Error: {e}\")\n    )\n</code></pre> <p>Para handlers globales (todas las requests), ver Advanced.</p>"},{"location":"guides/http/basic-usage/#requests-concurrentes","title":"Requests Concurrentes","text":"<pre><code>import asyncio\n\n@inject\nasync def fetch_multiple(http: Http):\n    results = await asyncio.gather(\n        http.get(\"https://api.example.com/users/1\"),\n        http.get(\"https://api.example.com/users/2\"),\n        http.get(\"https://api.example.com/users/3\")\n    )\n\n    users = [r.to(User) for r in results if r.status == 200]\n    return users\n</code></pre>"},{"location":"guides/http/basic-usage/#ejemplo-crud-completo","title":"Ejemplo: CRUD Completo","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass Todo:\n    id: Optional[int]\n    title: str\n    completed: bool = False\n\n@inject\nasync def crud(http: Http):\n    base = \"https://jsonplaceholder.typicode.com/todos\"\n\n    # CREATE\n    created = (await http.post(base, json={\"title\": \"New\", \"completed\": False})).to(Todo)\n\n    # READ\n    todo = (await http.get(f\"{base}/1\")).to(Todo)\n\n    # UPDATE\n    updated = (await http.put(f\"{base}/1\", json={\"title\": \"Updated\", \"completed\": True})).to(Todo)\n\n    # DELETE\n    delete_result = await http.delete(f\"{base}/1\")\n    print(f\"Deleted: {delete_result.status}\")\n</code></pre>"},{"location":"guides/http/basic-usage/#paginacion","title":"Paginaci\u00f3n","text":"<pre><code>@inject\nasync def fetch_all_pages(http: Http):\n    all_users = []\n    page = 1\n\n    while True:\n        result = await http.get(\n            \"https://api.example.com/users\",\n            params={\"page\": page, \"limit\": 10}\n        )\n\n        if result.status != 200:\n            break\n\n        users = result.to(list)\n        if not users:\n            break\n\n        all_users.extend(users)\n        page += 1\n\n    return all_users\n</code></pre>"},{"location":"guides/http/basic-usage/#manejo-de-errores","title":"Manejo de Errores","text":"<pre><code>@inject\nasync def handle_errors(http: Http):\n    result = await http.get(\"https://api.example.com/data\")\n\n    if result.exception:\n        print(f\"Error de red: {result.exception}\")\n        return None\n\n    data = result.to(dict)  # None si falla el parsing JSON\n    if data is None:\n        print(\"JSON inv\u00e1lido\")\n        return {}\n\n    return data\n</code></pre>"},{"location":"guides/http/basic-usage/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Advanced Features - Retry, proxy rotation, handlers globales</li> <li>Result Pattern - Manejo avanzado de respuestas</li> </ul>"},{"location":"guides/http/overview/","title":"HTTP Client - Overview","text":"<p>Cliente HTTP as\u00edncrono con connection pooling, retry autom\u00e1tico y Result pattern.</p>"},{"location":"guides/http/overview/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Connection Pooling - Reutiliza conexiones TCP/TLS</li> <li>Async/Await - Basado en httpx</li> <li>Result Pattern - Manejo de errores sin excepciones</li> <li>Retry Autom\u00e1tico - Backoff exponencial configurable</li> <li>Handlers - Hooks before/after para logging, m\u00e9tricas</li> <li>Type-Safe - Mapeo autom\u00e1tico a DTOs (Pydantic, dataclasses)</li> <li>Proxy Rotation - Round-robin entre m\u00faltiples proxies</li> <li>IoC Integrado - Inyecci\u00f3n autom\u00e1tica via <code>@inject</code></li> </ul>"},{"location":"guides/http/overview/#arquitectura","title":"Arquitectura","text":"<pre><code>graph TB\n    A[Http Client] --&gt; B[httpx.AsyncClient]\n    A --&gt; C[Connection Pool]\n    A --&gt; D[Result Pattern]\n\n    B --&gt; E[Request]\n    E --&gt; F[Before Handlers]\n    F --&gt; G[Send]\n    G --&gt; H[After Handlers]\n    H --&gt; I[Result]\n\n    I --&gt; J[.to DTO]\n    I --&gt; K[.on_status]\n    I --&gt; L[.on_exception]</code></pre>"},{"location":"guides/http/overview/#componentes","title":"Componentes","text":"Componente Descripci\u00f3n <code>Http</code> Cliente principal. Se inyecta con <code>@inject</code> <code>Result</code> Wrapper de respuesta con <code>to()</code>, <code>on_status()</code>, <code>on_exception()</code> <code>HttpConfig</code> Configuraci\u00f3n (timeouts, pool, retry, proxies)"},{"location":"guides/http/overview/#ejemplo-rapido","title":"Ejemplo R\u00e1pido","text":"<pre><code>from dataclasses import dataclass\nfrom R5.http import Http\nfrom R5.ioc import inject\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n\n@inject\nasync def main(http: Http):\n    # GET con mapeo a DTO\n    user = (await http.get(\"https://api.example.com/users/1\")).to(User)\n\n    # POST con retry\n    result = await http.retry(attempts=3, delay=1.0).post(\n        \"https://api.example.com/users\",\n        json={\"name\": \"John\", \"email\": \"john@example.com\"}\n    )\n\n    # Handlers encadenados\n    (await http.get(\"https://api.example.com/users/1\"))\n        .on_status(404, lambda req, res: print(\"Not found\"))\n        .on_exception(lambda e: print(f\"Error: {e}\"))\n</code></pre>"},{"location":"guides/http/overview/#lifecycle","title":"Lifecycle","text":"<p>El cliente es un <code>@resource</code> del IoC container \u2014 se crea y cierra autom\u00e1ticamente:</p> <pre><code>@inject\nasync def my_service(http: Http):\n    result = await http.get(\"/data\")\n    # Al cerrar el container, el cliente se cierra autom\u00e1ticamente\n</code></pre>"},{"location":"guides/http/overview/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Basic Usage - GET, POST, PUT, DELETE, DTOs, handlers</li> <li>Advanced Features - Retry, proxy rotation, circuit breaker</li> <li>Result Pattern - Manejo de respuestas y errores</li> </ul>"},{"location":"guides/http/result/","title":"Result Pattern","text":"<p>El <code>Result</code> encapsula respuestas HTTP, permitiendo manejo de errores sin excepciones.</p>"},{"location":"guides/http/result/#propiedades","title":"Propiedades","text":"<ul> <li><code>response</code> - La respuesta HTTP (<code>None</code> si hubo excepci\u00f3n)</li> <li><code>request</code> - La request original</li> <li><code>status</code> - C\u00f3digo de estado HTTP (<code>0</code> si hubo excepci\u00f3n)</li> <li><code>exception</code> - Excepci\u00f3n capturada (<code>None</code> si fue exitosa)</li> </ul>"},{"location":"guides/http/result/#creacion","title":"Creaci\u00f3n","text":"<pre><code>from R5.http import Result\nimport httpx\n\n# Desde response\nresponse = httpx.Response(200, json={\"id\": 1, \"name\": \"John\"})\nresult = Result.from_response(response)\n\n# Desde excepci\u00f3n\nresult = Result.from_exception(Exception(\"Network error\"))\n# result.status == 0, result.response == None\n</code></pre>"},{"location":"guides/http/result/#verificacion-de-estado","title":"Verificaci\u00f3n de Estado","text":"<pre><code>@inject\nasync def check_status(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    if result.exception:\n        print(f\"Request failed: {result.exception}\")\n        return None\n\n    if result.status == 200:\n        return result.to(User)\n    elif result.status == 404:\n        print(\"Not found\")\n    elif result.status &gt;= 500:\n        print(\"Server error\")\n</code></pre>"},{"location":"guides/http/result/#handlers-encadenados","title":"Handlers Encadenados","text":"<p>Los handlers ejecutan side effects sin modificar el result. Retornan <code>self</code> para chaining:</p> <pre><code>@inject\nasync def chained_handlers(http: Http):\n    result = await http.get(\"https://api.example.com/users/1\")\n\n    user = (result\n        .on_status(404, lambda req, res: print(\"Not found\"))\n        .on_status(500, lambda req, res: print(\"Server error\"))\n        .on_exception(lambda e: log_error(e))\n        .to(User))\n\n    return user\n</code></pre>"},{"location":"guides/http/result/#mapeo-a-tipos-con-to","title":"Mapeo a Tipos con <code>to()</code>","text":"<p>Convierte la respuesta JSON al tipo especificado. Retorna <code>None</code> si falla:</p> <pre><code>from pydantic import BaseModel\nfrom dataclasses import dataclass\nfrom typing import TypedDict\n\n# Pydantic (con validaci\u00f3n autom\u00e1tica)\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\nuser = result.to(User)\n\n# Dataclass\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n\nproduct = result.to(Product)\n\n# Dict, List, TypedDict\ndata = result.to(dict)\nitems = result.to(list)\n</code></pre>"},{"location":"guides/http/result/#validacion-de-nulos-en-dataclasses","title":"Validaci\u00f3n de Nulos en Dataclasses","text":"<p>R5 valida que valores <code>None</code> del JSON sean compatibles con los type hints. Si un campo recibe <code>None</code> pero no es <code>Optional</code>, se emite un <code>UserWarning</code>:</p> <pre><code>@dataclass\nclass Product:\n    id: int\n    name: str                    # No Optional \u2192 warning si es None\n    description: Optional[str]   # Optional \u2192 sin warning\n\n# JSON: {\"id\": 1, \"name\": null, \"description\": null}\nproduct = result.to(Product)\n# \u26a0\ufe0f UserWarning: Fields ['name'] have None values but are not typed as Optional in Product\n</code></pre> Tipo Destino Validaci\u00f3n de nulos <code>@dataclass</code> Activa <code>Pydantic BaseModel</code> Delegada a Pydantic <code>dict</code> / <code>list</code> / <code>TypedDict</code> Inactiva"},{"location":"guides/http/result/#manejo-de-errores","title":"Manejo de Errores","text":"<pre><code>@inject\nasync def safe_fetch(http: Http):\n    result = await http.get(\"https://api.example.com/data\")\n\n    user = result.to(User)\n    if user is None:\n        # Fallo en mapping: JSON inv\u00e1lido, tipo incompatible, o error de red\n        print(f\"Status: {result.status}\")\n        return {\"default\": True}  # fallback\n\n    return user\n</code></pre>"},{"location":"guides/http/result/#acceso-a-responserequest","title":"Acceso a Response/Request","text":"<pre><code>if result.response:\n    print(result.response.headers)\n    print(result.response.text)\n    print(result.response.json())\n\nif result.request:\n    print(result.request.url)\n    print(result.request.method)\n</code></pre>"},{"location":"guides/http/result/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Basic Usage - Uso b\u00e1sico del cliente</li> <li>Advanced - Retry, proxy rotation, handlers globales</li> </ul>"},{"location":"guides/ioc/configuration/","title":"Configuration","text":"<p>El decorador <code>@config</code> carga valores desde archivos y variables de entorno, los convierte a los tipos correctos, y registra la clase como Singleton en el container.</p>"},{"location":"guides/ioc/configuration/#uso-basico","title":"Uso B\u00e1sico","text":"<pre><code>from R5.ioc import config\n\n@config(file='.env')\nclass AppConfig:\n    database_url: str = \"sqlite:///app.db\"\n    api_key: str = \"\"\n    debug: bool = False\n    port: int = 8000\n</code></pre> <p>Se inyecta autom\u00e1ticamente:</p> <pre><code>@inject\nasync def main(config: AppConfig):\n    print(config.database_url)\n</code></pre>"},{"location":"guides/ioc/configuration/#formatos-soportados","title":"Formatos Soportados","text":"Formato Extensi\u00f3n Ejemplo Variables de entorno <code>.env</code> <code>DATABASE_URL=postgres://...</code> JSON <code>.json</code> <code>{\"database_url\": \"...\"}</code> YAML <code>.yml</code> / <code>.yaml</code> <code>database_url: postgres://...</code> Properties <code>.properties</code> <code>database.url=postgres://...</code> <pre><code>@config(file='config.json')   # o .yml, .env, .properties\nclass AppConfig:\n    database_url: str\n    port: int\n</code></pre> <p>En <code>.env</code>, las listas se separan por comas: <code>ALLOWED_HOSTS=localhost,example.com</code></p>"},{"location":"guides/ioc/configuration/#conversion-de-tipos","title":"Conversi\u00f3n de Tipos","text":"<p>R5 convierte strings a los tipos indicados por los type hints:</p> <pre><code>@config(file='.env')\nclass Config:\n    app_name: str = \"MyApp\"\n    port: int = 8000\n    timeout: float = 30.5\n    debug: bool = False              # true/false/1/0/yes/no/on/off\n    allowed_hosts: list[str] = [\"localhost\"]\n    metadata: dict[str, str] = {}\n</code></pre>"},{"location":"guides/ioc/configuration/#variables-de-entorno-override","title":"Variables de Entorno Override","text":"<p>Por defecto las variables de entorno tienen prioridad sobre el archivo:</p> <pre><code>@config(file='config.json', env_override=True)  # default\nclass AppConfig:\n    port: int = 8000\n</code></pre> <p>Prioridad: Variables de entorno &gt; Archivo &gt; Defaults de la clase</p> <p>Deshabilitar: <code>env_override=False</code></p>"},{"location":"guides/ioc/configuration/#opciones","title":"Opciones","text":"<pre><code>@config(\n    file='.env',\n    required=True,          # FileNotFoundError si no existe (default: True)\n    env_override=True,      # Variables de entorno tienen prioridad (default: True)\n    case_sensitive=False     # Claves case-insensitive (default: False)\n)\nclass Config: ...\n</code></pre> <p>Sin archivo (solo defaults):</p> <pre><code>@config\nclass Config:\n    database_url: str = \"sqlite:///app.db\"\n</code></pre>"},{"location":"guides/ioc/configuration/#configuracion-anidada","title":"Configuraci\u00f3n Anidada","text":"<pre><code>@config(file='database.json')\nclass DatabaseConfig:\n    url: str\n    pool_size: int = 10\n\n@config(file='redis.json')\nclass RedisConfig:\n    host: str = \"localhost\"\n    port: int = 6379\n\n@singleton\nclass AppConfig:\n    def __init__(self, db: DatabaseConfig, redis: RedisConfig):\n        self.database = db\n        self.redis = redis\n</code></pre>"},{"location":"guides/ioc/configuration/#validacion-con-pydantic","title":"Validaci\u00f3n con Pydantic","text":"<pre><code>from pydantic import BaseModel, field_validator\n\n@config(file='.env')\nclass AppConfig(BaseModel):\n    port: int\n\n    @field_validator('port')\n    def validate_port(cls, v):\n        if v &lt; 1 or v &gt; 65535:\n            raise ValueError('Port must be between 1 and 65535')\n        return v\n</code></pre>"},{"location":"guides/ioc/configuration/#propiedades-computadas","title":"Propiedades Computadas","text":"<pre><code>@config(file='.env')\nclass AppConfig:\n    host: str = \"localhost\"\n    port: int = 8000\n\n    @property\n    def base_url(self) -&gt; str:\n        return f\"http://{self.host}:{self.port}\"\n</code></pre>"},{"location":"guides/ioc/configuration/#multi-entorno","title":"Multi-Entorno","text":"<pre><code>import os\n\n@config(file=f\"config.{os.getenv('ENV', 'development')}.json\")\nclass AppConfig:\n    database_url: str\n    debug: bool\n</code></pre>"},{"location":"guides/ioc/configuration/#warnings","title":"Warnings","text":"<ul> <li>Campo sin valor en ninguna fuente \u2192 <code>UserWarning</code> + <code>None</code></li> <li>Archivo no encontrado con <code>required=False</code> \u2192 <code>UserWarning</code> + usa defaults</li> </ul>"},{"location":"guides/ioc/configuration/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Overview - IoC Container</li> <li>Injection - <code>@inject</code></li> <li>Providers - Scopes</li> </ul>"},{"location":"guides/ioc/injection/","title":"Dependency Injection","text":"<p>El decorador <code>@inject</code> resuelve e inyecta dependencias autom\u00e1ticamente bas\u00e1ndose en type hints.</p>"},{"location":"guides/ioc/injection/#uso-basico","title":"Uso B\u00e1sico","text":"<pre><code>from R5.ioc import singleton, inject\n\n@singleton\nclass EmailService:\n    def send(self, to: str, message: str):\n        print(f\"Sending to {to}: {message}\")\n\n@inject\ndef send_welcome(email_service: EmailService, user_email: str):\n    email_service.send(user_email, \"Welcome!\")\n\nsend_welcome(user_email=\"user@example.com\")\n</code></pre>"},{"location":"guides/ioc/injection/#como-funciona","title":"C\u00f3mo Funciona","text":"<p><code>@inject</code> analiza la firma, identifica tipos registrados en el container y los inyecta. Los par\u00e1metros no registrados se pasan manualmente:</p> <pre><code>@inject\ndef handler(\n    service_a: ServiceA,  # Inyectado autom\u00e1ticamente\n    service_b: ServiceB,  # Inyectado autom\u00e1ticamente\n    user_id: int,         # Par\u00e1metro manual (keyword-only)\n    name: str = \"John\"    # Par\u00e1metro manual con default\n):\n    pass\n\nhandler(user_id=123)\n</code></pre> <p>Los par\u00e1metros no inyectables se convierten en keyword-only para prevenir errores de orden.</p>"},{"location":"guides/ioc/injection/#funciones-async","title":"Funciones Async","text":"<pre><code>@inject\nasync def fetch_users(db: DatabaseService):\n    return await db.query(\"SELECT * FROM users\")\n\nusers = await fetch_users()\n</code></pre>"},{"location":"guides/ioc/injection/#multiples-dependencias","title":"M\u00faltiples Dependencias","text":"<pre><code>@inject\ndef handler(cache: CacheService, log: LogService, email: EmailService, user_id: int):\n    log.log(f\"Processing {user_id}\")\n    data = cache.get(f\"user:{user_id}\")\n    email.send(\"admin@example.com\")\n    return data\n\nresult = handler(user_id=42)\n</code></pre>"},{"location":"guides/ioc/injection/#inyeccion-en-clases","title":"Inyecci\u00f3n en Clases","text":"<pre><code># En m\u00e9todos\nclass UserController:\n    @inject\n    def create_user(self, email: EmailService, username: str):\n        email.send(\"admin@example.com\")\n        return f\"Created: {username}\"\n\n# En constructores (el scope decorator registra y resuelve __init__)\n@singleton\nclass UserService:\n    def __init__(self, logger: Logger, cache: Cache):\n        self.logger = logger\n        self.cache = cache\n</code></pre>"},{"location":"guides/ioc/injection/#inyeccion-anidada","title":"Inyecci\u00f3n Anidada","text":"<p>R5 resuelve cadenas de dependencias autom\u00e1ticamente:</p> <pre><code>@singleton\nclass Logger: pass\n\n@singleton\nclass Cache:\n    def __init__(self, logger: Logger): ...\n\n@singleton\nclass UserRepo:\n    def __init__(self, cache: Cache, logger: Logger): ...\n\n@inject\ndef get_user(repo: UserRepo, user_id: int):\n    return repo.find(user_id)\n# Resuelve: UserRepo \u2192 Cache \u2192 Logger\n</code></pre>"},{"location":"guides/ioc/injection/#dependencias-opcionales","title":"Dependencias Opcionales","text":"<pre><code>from typing import Optional\n\n@inject\ndef handler(cache: Optional[CacheService], data: str):\n    if cache:\n        return cache.get(data)\n    return fetch_from_db(data)\n</code></pre>"},{"location":"guides/ioc/injection/#resource-injection","title":"Resource Injection","text":"<p><code>@resource</code> se gestiona autom\u00e1ticamente con context manager:</p> <pre><code>@resource\nclass DatabaseSession:\n    async def __aenter__(self):\n        self.session = create_session()\n        return self\n    async def __aexit__(self, *args):\n        await self.session.close()\n\n@inject\nasync def query(db: DatabaseSession):\n    # db ya pas\u00f3 por __aenter__\n    return await db.session.query(\"...\")\n    # __aexit__ se ejecuta al salir\n</code></pre>"},{"location":"guides/ioc/injection/#errores-comunes","title":"Errores Comunes","text":"Error Causa Soluci\u00f3n <code>ProviderNotFoundError</code> Tipo no registrado Decorar con <code>@singleton</code>/<code>@factory</code>/<code>@resource</code> <code>CircularDependencyError</code> A depende de B, B de A Refactorizar para eliminar ciclo Sin inyecci\u00f3n Falta type hint Agregar: <code>def handler(service: MyService)</code> <code>TypeError</code> en args Par\u00e1metro posicional Usar keyword: <code>handler(user_id=123)</code>"},{"location":"guides/ioc/injection/#alias-para-interfaces","title":"Alias para Interfaces","text":"<pre><code>Container.alias_provider(IUserRepository, PostgresUserRepository)\n\n@inject\ndef get_data(repo: IUserRepository):\n    return repo.find_all()\n</code></pre>"},{"location":"guides/ioc/injection/#testing","title":"Testing","text":"<pre><code>def test_handler():\n    Container.reset()\n\n    class MockEmail:\n        def send(self, to): pass\n\n    Container.registry_provider(MockEmail, Scope.SINGLETON)\n    Container.alias_provider(EmailService, MockEmail)\n\n    @inject\n    def handler(email: EmailService):\n        email.send(\"test@example.com\")\n\n    handler()  # Usa MockEmail\n</code></pre>"},{"location":"guides/ioc/injection/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Providers - Scopes y decoradores</li> <li>Configuration - <code>@config</code></li> </ul>"},{"location":"guides/ioc/overview/","title":"IoC Container - Overview","text":"<p>El contenedor de Inversi\u00f3n de Control (IoC) gestiona la creaci\u00f3n y resoluci\u00f3n de dependencias autom\u00e1ticamente usando type hints.</p>"},{"location":"guides/ioc/overview/#beneficios","title":"Beneficios","text":"<pre><code># Sin IoC: dependencias manuales\nclass UserService:\n    def __init__(self):\n        self.db = DatabaseConnection()\n        self.cache = CacheService()\n\n# Con IoC: inyecci\u00f3n autom\u00e1tica\n@singleton\nclass UserService:\n    def __init__(self, db: DatabaseConnection, cache: CacheService):\n        self.db = db\n        self.cache = cache\n</code></pre> <ul> <li>Desacoplamiento - Las clases no crean sus dependencias</li> <li>Testing - Reemplazar dependencias con mocks es trivial</li> <li>Type-safe - Resoluci\u00f3n autom\u00e1tica via type hints</li> </ul>"},{"location":"guides/ioc/overview/#componentes","title":"Componentes","text":"Componente Descripci\u00f3n <code>Container</code> Registro central de providers <code>@singleton</code> / <code>@factory</code> / <code>@resource</code> Decoradores de scope (detalle) <code>@inject</code> Inyecta dependencias en funciones (detalle) <code>@config</code> Carga configuraci\u00f3n desde archivos (detalle)"},{"location":"guides/ioc/overview/#ejemplo-rapido","title":"Ejemplo R\u00e1pido","text":"<pre><code>from R5.ioc import singleton, inject, Container\n\n@singleton\nclass Logger:\n    def log(self, msg: str):\n        print(msg)\n\n@singleton\nclass UserService:\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n@inject\nasync def handler(service: UserService, user_id: int):\n    service.logger.log(f\"Processing {user_id}\")\n\nawait handler(user_id=123)\n</code></pre>"},{"location":"guides/ioc/overview/#container-api","title":"Container API","text":"<pre><code># Registrar manualmente\nContainer.registry_provider(MyService, Scope.SINGLETON)\n\n# Verificar existencia\nContainer.in_provider(MyService)  # True/False\n\n# Resolver instancia\ninstance = Container.resolve(MyService)\n\n# Alias (interfaces)\nContainer.alias_provider(IRepository, PostgresRepository)\n\n# Snapshot/Restore (\u00fatil en tests)\nsnapshot = Container.snapshot()\nContainer.restore(snapshot)\n\n# Reset completo\nContainer.reset()\n</code></pre>"},{"location":"guides/ioc/overview/#resolucion-de-dependencias","title":"Resoluci\u00f3n de Dependencias","text":"<p>R5 resuelve cadenas de dependencias autom\u00e1ticamente y detecta ciclos:</p> <pre><code>@singleton\nclass Logger: pass\n\n@singleton\nclass Cache:\n    def __init__(self, logger: Logger): ...\n\n@singleton\nclass UserService:\n    def __init__(self, cache: Cache, logger: Logger): ...\n\n# Resuelve: UserService \u2192 Cache \u2192 Logger\nuser_service = Container.resolve(UserService)\n</code></pre> <pre><code># Dependencia circular \u2192 CircularDependencyError\n@singleton\nclass A:\n    def __init__(self, b: 'B'): ...\n\n@singleton\nclass B:\n    def __init__(self, a: A): ...\n</code></pre>"},{"location":"guides/ioc/overview/#debugging","title":"Debugging","text":"<pre><code>from R5.ioc.errors import ProviderNotFoundError, CircularDependencyError\n\ntry:\n    Container.resolve(UnknownService)\nexcept ProviderNotFoundError as e:\n    print(f\"Not found: {e.provider_type}\")\n    print(f\"Available: {e.available_providers}\")\n</code></pre>"},{"location":"guides/ioc/overview/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Injection - Gu\u00eda completa de <code>@inject</code></li> <li>Providers - Scopes: singleton, factory, resource</li> <li>Configuration - <code>@config</code> y formatos soportados</li> </ul>"},{"location":"guides/ioc/providers/","title":"Providers y Scopes","text":"<p>Los scopes determinan c\u00f3mo y cu\u00e1ndo se crean las instancias.</p>"},{"location":"guides/ioc/providers/#resumen","title":"Resumen","text":"Scope Decorator Comportamiento Uso t\u00edpico Singleton <code>@singleton</code> Una instancia compartida Servicios, configuraci\u00f3n, cach\u00e9 Factory <code>@factory</code> Nueva instancia cada vez Contextos, DTOs, commands Resource <code>@resource</code> Instancia con lifecycle (<code>__aenter__</code>/<code>__aexit__</code>) Conexiones, archivos, sesiones"},{"location":"guides/ioc/providers/#singleton","title":"Singleton","text":"<pre><code>from R5.ioc import singleton, Container\n\n@singleton\nclass ConfigService:\n    def __init__(self):\n        self.settings = load_settings()\n\nconfig1 = Container.resolve(ConfigService)\nconfig2 = Container.resolve(ConfigService)\nassert config1 is config2  # Misma instancia\n</code></pre>"},{"location":"guides/ioc/providers/#factory","title":"Factory","text":"<pre><code>from R5.ioc import factory\nfrom uuid import uuid4\n\n@factory\nclass RequestContext:\n    def __init__(self):\n        self.id = uuid4()\n        self.timestamp = datetime.now()\n\nctx1 = Container.resolve(RequestContext)\nctx2 = Container.resolve(RequestContext)\nassert ctx1 is not ctx2      # Instancias diferentes\nassert ctx1.id != ctx2.id\n</code></pre>"},{"location":"guides/ioc/providers/#resource","title":"Resource","text":"<p>Requiere implementar <code>__aenter__</code> y <code>__aexit__</code>:</p> <pre><code>from R5.ioc import resource\n\n@resource\nclass DatabaseSession:\n    async def __aenter__(self):\n        self.session = await create_async_session()\n        await self.session.begin()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            await self.session.rollback()\n        else:\n            await self.session.commit()\n        await self.session.close()\n\n@inject\nasync def query_users(db: DatabaseSession):\n    # db ya pas\u00f3 por __aenter__\n    users = await db.session.query(\"SELECT * FROM users\")\n    return users\n    # __aexit__ se ejecuta autom\u00e1ticamente\n</code></pre>"},{"location":"guides/ioc/providers/#scope-con-dependencias","title":"Scope con Dependencias","text":"<p>Los scopes se aplican al servicio, no a sus dependencias:</p> <pre><code>@singleton\nclass Logger: pass\n\n@factory\nclass Request:\n    def __init__(self, logger: Logger):\n        self.logger = logger  # Singleton compartido\n        self.id = uuid4()\n\nreq1 = Container.resolve(Request)\nreq2 = Container.resolve(Request)\nassert req1 is not req2              # Factory: diferentes\nassert req1.logger is req2.logger    # Singleton: mismo\n</code></pre>"},{"location":"guides/ioc/providers/#decorador-generico-component","title":"Decorador gen\u00e9rico <code>component</code>","text":"<pre><code>from R5.ioc import component, Scope\n\n@component(scope=Scope.SINGLETON)\nclass MyService: pass\n\n@component(scope=Scope.FACTORY)\nclass MyFactory: pass\n</code></pre>"},{"location":"guides/ioc/providers/#registro-manual","title":"Registro Manual","text":"<p>Para clases de terceros sin acceso al decorador:</p> <pre><code>Container.registry_provider(ThirdPartyService, Scope.SINGLETON)\n</code></pre>"},{"location":"guides/ioc/providers/#warnings-de-sobreescritura","title":"Warnings de Sobreescritura","text":"<p>Registrar el mismo tipo dos veces emite un <code>UserWarning</code>:</p> <pre><code>@singleton\nclass MyService: pass\n\n@singleton\nclass MyService: pass  # \u26a0\ufe0f UserWarning: Provider for 'MyService' is being overwritten\n</code></pre>"},{"location":"guides/ioc/providers/#testing","title":"Testing","text":"<pre><code>def test_service():\n    Container.reset()\n\n    class MockLogger:\n        def log(self, msg): pass\n\n    Container.registry_provider(MockLogger, Scope.SINGLETON)\n    Container.alias_provider(Logger, MockLogger)\n    # Tests usan MockLogger\n</code></pre>"},{"location":"guides/ioc/providers/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Injection - <code>@inject</code> decorator</li> <li>Configuration - <code>@config</code> y formatos</li> </ul>"}]}